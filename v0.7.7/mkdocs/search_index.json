{
    "docs": [
        {
            "location": "/", 
            "text": "LightGraphs\n\n\n \n \n \n\n\n \n \n \n\n\nAn optimized graphs package.\n\n\nSimple graphs (not multi- or hypergraphs) are represented in a memory- and time-efficient manner with adjacency lists and edge iterators. Both directed and undirected graphs are supported via separate types, and conversion is available from directed to undirected.\n\n\nThe project goal is to mirror the functionality of robust network and graph analysis libraries such as \nNetworkX\n while being simpler to use and more efficient than existing Julian graph libraries such as \nGraphs.jl\n. It is an explicit design decision that any data not required for graph manipulation (attributes and other information, for example) is expected to be stored outside of the graph structure itself. Such data lends itself to storage in more traditional and better-optimized mechanisms.\n\n\nAdditional functionality may be found in the companion package \nLightGraphsExtras.jl\n.\n\n\n\n\nDocumentation\n\n\nFull documentation is available at \nGitHub Pages\n. Documentation for methods is also available via the Julia REPL help system.\n\n\n\n\nCore Concepts\n\n\nA graph \nG\n is described by a set of vertices \nV\n and edges \nE\n: \nG = {V, E}\n. \nV\n is an integer range \n1:n\n; \nE\n is represented as forward (and, for directed graphs, backward) adjacency lists indexed by vertices. Edges may also be accessed via an iterator that yields \nEdge\n types containing \n(src::Int, dst::Int)\n values.\n\n\nLightGraphs.jl\n provides two graph types: \nGraph\n is an undirected graph, and \nDiGraph\n is its directed counterpart.\n\n\nGraphs are created using \nGraph()\n or \nDiGraph()\n; there are several options (see below for examples).\n\n\nEdges are added to a graph using \nadd_edge!(g, e)\n. Instead of an edge type integers may be passed denoting the source and destination vertices (e.g., \nadd_edge!(g, 1, 2)\n).\n\n\nMultiple edges between two given vertices are not allowed: an attempt to add an edge that already exists in a graph will result in a silent failure.\n\n\nEdges may be removed using \nrem_edge!(g, e)\n. Alternately, integers may be passed denoting the source and destination vertices (e.g., \nrem_edge!(g, 1, 2)\n). Note that, particularly for very large graphs, edge removal is a (relatively) expensive operation. An attempt to remove an edge that does not exist in the graph will result in an error.\n\n\nUse \nnv(g)\n and \nne(g)\n to compute the number of vertices and edges respectively.\n\n\nrem_vertex!(g, v)\n alters the vertex identifiers. In particular, calling \nn=nv(g)\n, it swaps \nv\n and \nn\n and then removes \nn\n.\n\n\nedges(g)\n returns an iterator to the edge set. Use \ncollect(edge(set))\n to fill an array with all edges in the graph.\n\n\n\n\nInstallation\n\n\nInstallation is straightforward:\n\n\njulia\n Pkg.add(\nLightGraphs\n)\n\n\n\n\n\n\nUsage Examples\n\n\n(all examples apply equally to \nDiGraph\n unless otherwise noted):\n\n\n# create an empty undirected graph\ng = Graph()\n\n# create a 10-node undirected graph with no edges\ng = Graph(10)\n@assert nv(g) == 10\n\n# create a 10-node undirected graph with 30 randomly-selected edges\ng = Graph(10,30)\n\n# add an edge between vertices 4 and 5\nadd_edge!(g, 4, 5)\n\n# remove an edge between vertices 9 and 10\nrem_edge!(g, 9, 10)\n\n# create vertex 11\nadd_vertex!(g)\n\n# remove vertex 2\n# attention: this changes the id of vertex nv(g) to 2\nrem_vertex!(g, 2)\n\n# get the neighbors of vertex 4\nneighbors(g, 4)\n\n# iterate over the edges\nm = 0\nfor e in edges(g)\n    m += 1\nend\n@assert m == ne(g)\n\n# show distances between vertex 4 and all other vertices\ndijkstra_shortest_paths(g, 4).dists\n\n# as above, but with non-default edge distances\ndistmx = zeros(10,10)\ndistmx[4,5] = 2.5\ndistmx[5,4] = 2.5\ndijkstra_shortest_paths(g, 4, distmx).dists\n\n# graph I/O\ng = loadgraph(\nmygraph.jgz\n, :lg)\nsavegraph(\nmygraph.gml\n, g, :gml)\n\n\n\n\n\n\nCurrent functionality\n\n\n\n\ncore functions:\n vertices and edges addition and removal, degree (in/out/histogram), neighbors (in/out/all/common)\n\n\ndistance within graphs:\n eccentricity, diameter, periphery, radius, center\n\n\ndistance between graphs:\n spectral_distance, edit_distance\n\n\nconnectivity:\n strongly- and weakly-connected components, bipartite checks, condensation, attracting components, neighborhood\n\n\noperators:\n complement, reverse, reverse!, union, join, intersect, difference,\n\n\n\n\nsymmetric difference, blkdiag, induced subgraphs, products (cartesian/scalar)\n\n\n\n\nshortest paths:\n Dijkstra, Dijkstra with predecessors, Bellman-Ford, Floyd-Warshall, A*\n\n\nsmall graph generators:\n see \nsmallgraphs.jl\n for list\n\n\nrandom graph generators:\n Erd\u0151s\u2013R\u00e9nyi, Watts-Strogatz, random regular, arbitrary degree sequence, stochastic block model\n\n\ncentrality:\n betweenness, closeness, degree, pagerank, Katz\n\n\ntraversal operations:\n cycle detection, BFS and DFS DAGs, BFS and DFS traversals with visitors, DFS topological sort, maximum adjacency / minimum cut, multiple random walks\n\n\nflow operations:\n maximum flow\n\n\nmatching:\n Matching functions have been moved to \nLightGraphsExtras.jl\n.\n\n\nclique enumeration:\n maximal cliques\n\n\nlinear algebra / spectral graph theory:\n adjacency matrix (works as input to \nGraphLayout\n and \nMetis\n), Laplacian matrix, non-backtracking matrix\n\n\ncommunity:\n modularity, community detection, core-periphery, clustering coefficients\n\n\npersistence formats:\n proprietary compressed, \nGraphML\n, \nGML\n, \nGexf\n, \nDOT\n, \nPajek NET\n\n\nvisualization:\n integration with \nGraphLayout\n, \nTikzGraphs\n, \nGraphPlot\n, \nNetworkViz\n\n\n\n\n\n\nCore API\n\n\nThese functions are defined as the public contract of the LightGraphs.AbstractGraph interface.\n\n\n\n\nConstructing and modifying the graph\n\n\n\n\nadd_edge!\n\n\nrem_edge!\n\n\nadd_vertex!\n\n\nadd_vertices!\n\n\nrem_vertex!\n\n\n\n\n\n\nEdge/Arc interface\n\n\n\n\nsrc\n\n\ndst\n\n\n\n\n\n\nAccessing state\n\n\n\n\nnv::Int\n\n\nne::Int\n\n\nvertices (Iterable)\n\n\nedges (Iterable)\n\n\nneighbors\n\n\nin_edges\n\n\nout_edges\n\n\nhas_vertex\n\n\nhas_edge\n\n\nhas_self_loops (though this might be a trait or an abstract graph type)\n\n\n\n\n\n\nNon-Core APIs\n\n\nThese functions can be constructed from the Core API functions but can be given specialized implementations in order to improve performance.\n\n\n\n\nadjacency_matrix\n\n\ndegree\n\n\n\n\nThis can be computed from neighbors by default \ndegree(g,v) = length(neighbors(g,v))\n so you don't need to implement this unless your type can compute degree faster than this method.\n\n\n\n\nSupported Versions\n\n\n\n\nLightGraphs master is designed to work with the latest stable version of Julia.\n\n\nJulia 0.3: LightGraphs v0.3.7 is the last version guaranteed to work with Julia 0.3.\n\n\nJulia 0.4: LightGraphs versions in the 0.6 series are designed to work with Julia 0.4.\n\n\nJulia 0.5: LightGraphs versions in the 0.7 series are designed to work with Julia 0.5.\n\n\nJulia 0.6: Some functionality might not work with prerelease / unstable / nightly versions of Julia. If you run into a problem on 0.6, please file an issue.\n\n\n\n\n\n\nContributing and Reporting Bugs\n\n\nWe welcome contributions and bug reports! Please see \nCONTRIBUTING.md\n for guidance on development and bug reporting.", 
            "title": "Getting Started"
        }, 
        {
            "location": "/#lightgraphs", 
            "text": "An optimized graphs package.  Simple graphs (not multi- or hypergraphs) are represented in a memory- and time-efficient manner with adjacency lists and edge iterators. Both directed and undirected graphs are supported via separate types, and conversion is available from directed to undirected.  The project goal is to mirror the functionality of robust network and graph analysis libraries such as  NetworkX  while being simpler to use and more efficient than existing Julian graph libraries such as  Graphs.jl . It is an explicit design decision that any data not required for graph manipulation (attributes and other information, for example) is expected to be stored outside of the graph structure itself. Such data lends itself to storage in more traditional and better-optimized mechanisms.  Additional functionality may be found in the companion package  LightGraphsExtras.jl .", 
            "title": "LightGraphs"
        }, 
        {
            "location": "/#documentation", 
            "text": "Full documentation is available at  GitHub Pages . Documentation for methods is also available via the Julia REPL help system.", 
            "title": "Documentation"
        }, 
        {
            "location": "/#core-concepts", 
            "text": "A graph  G  is described by a set of vertices  V  and edges  E :  G = {V, E} .  V  is an integer range  1:n ;  E  is represented as forward (and, for directed graphs, backward) adjacency lists indexed by vertices. Edges may also be accessed via an iterator that yields  Edge  types containing  (src::Int, dst::Int)  values.  LightGraphs.jl  provides two graph types:  Graph  is an undirected graph, and  DiGraph  is its directed counterpart.  Graphs are created using  Graph()  or  DiGraph() ; there are several options (see below for examples).  Edges are added to a graph using  add_edge!(g, e) . Instead of an edge type integers may be passed denoting the source and destination vertices (e.g.,  add_edge!(g, 1, 2) ).  Multiple edges between two given vertices are not allowed: an attempt to add an edge that already exists in a graph will result in a silent failure.  Edges may be removed using  rem_edge!(g, e) . Alternately, integers may be passed denoting the source and destination vertices (e.g.,  rem_edge!(g, 1, 2) ). Note that, particularly for very large graphs, edge removal is a (relatively) expensive operation. An attempt to remove an edge that does not exist in the graph will result in an error.  Use  nv(g)  and  ne(g)  to compute the number of vertices and edges respectively.  rem_vertex!(g, v)  alters the vertex identifiers. In particular, calling  n=nv(g) , it swaps  v  and  n  and then removes  n .  edges(g)  returns an iterator to the edge set. Use  collect(edge(set))  to fill an array with all edges in the graph.", 
            "title": "Core Concepts"
        }, 
        {
            "location": "/#installation", 
            "text": "Installation is straightforward:  julia  Pkg.add( LightGraphs )", 
            "title": "Installation"
        }, 
        {
            "location": "/#usage-examples", 
            "text": "(all examples apply equally to  DiGraph  unless otherwise noted):  # create an empty undirected graph\ng = Graph()\n\n# create a 10-node undirected graph with no edges\ng = Graph(10)\n@assert nv(g) == 10\n\n# create a 10-node undirected graph with 30 randomly-selected edges\ng = Graph(10,30)\n\n# add an edge between vertices 4 and 5\nadd_edge!(g, 4, 5)\n\n# remove an edge between vertices 9 and 10\nrem_edge!(g, 9, 10)\n\n# create vertex 11\nadd_vertex!(g)\n\n# remove vertex 2\n# attention: this changes the id of vertex nv(g) to 2\nrem_vertex!(g, 2)\n\n# get the neighbors of vertex 4\nneighbors(g, 4)\n\n# iterate over the edges\nm = 0\nfor e in edges(g)\n    m += 1\nend\n@assert m == ne(g)\n\n# show distances between vertex 4 and all other vertices\ndijkstra_shortest_paths(g, 4).dists\n\n# as above, but with non-default edge distances\ndistmx = zeros(10,10)\ndistmx[4,5] = 2.5\ndistmx[5,4] = 2.5\ndijkstra_shortest_paths(g, 4, distmx).dists\n\n# graph I/O\ng = loadgraph( mygraph.jgz , :lg)\nsavegraph( mygraph.gml , g, :gml)", 
            "title": "Usage Examples"
        }, 
        {
            "location": "/#current-functionality", 
            "text": "core functions:  vertices and edges addition and removal, degree (in/out/histogram), neighbors (in/out/all/common)  distance within graphs:  eccentricity, diameter, periphery, radius, center  distance between graphs:  spectral_distance, edit_distance  connectivity:  strongly- and weakly-connected components, bipartite checks, condensation, attracting components, neighborhood  operators:  complement, reverse, reverse!, union, join, intersect, difference,   symmetric difference, blkdiag, induced subgraphs, products (cartesian/scalar)   shortest paths:  Dijkstra, Dijkstra with predecessors, Bellman-Ford, Floyd-Warshall, A*  small graph generators:  see  smallgraphs.jl  for list  random graph generators:  Erd\u0151s\u2013R\u00e9nyi, Watts-Strogatz, random regular, arbitrary degree sequence, stochastic block model  centrality:  betweenness, closeness, degree, pagerank, Katz  traversal operations:  cycle detection, BFS and DFS DAGs, BFS and DFS traversals with visitors, DFS topological sort, maximum adjacency / minimum cut, multiple random walks  flow operations:  maximum flow  matching:  Matching functions have been moved to  LightGraphsExtras.jl .  clique enumeration:  maximal cliques  linear algebra / spectral graph theory:  adjacency matrix (works as input to  GraphLayout  and  Metis ), Laplacian matrix, non-backtracking matrix  community:  modularity, community detection, core-periphery, clustering coefficients  persistence formats:  proprietary compressed,  GraphML ,  GML ,  Gexf ,  DOT ,  Pajek NET  visualization:  integration with  GraphLayout ,  TikzGraphs ,  GraphPlot ,  NetworkViz", 
            "title": "Current functionality"
        }, 
        {
            "location": "/#core-api", 
            "text": "These functions are defined as the public contract of the LightGraphs.AbstractGraph interface.", 
            "title": "Core API"
        }, 
        {
            "location": "/#constructing-and-modifying-the-graph", 
            "text": "add_edge!  rem_edge!  add_vertex!  add_vertices!  rem_vertex!", 
            "title": "Constructing and modifying the graph"
        }, 
        {
            "location": "/#edgearc-interface", 
            "text": "src  dst", 
            "title": "Edge/Arc interface"
        }, 
        {
            "location": "/#accessing-state", 
            "text": "nv::Int  ne::Int  vertices (Iterable)  edges (Iterable)  neighbors  in_edges  out_edges  has_vertex  has_edge  has_self_loops (though this might be a trait or an abstract graph type)", 
            "title": "Accessing state"
        }, 
        {
            "location": "/#non-core-apis", 
            "text": "These functions can be constructed from the Core API functions but can be given specialized implementations in order to improve performance.   adjacency_matrix  degree   This can be computed from neighbors by default  degree(g,v) = length(neighbors(g,v))  so you don't need to implement this unless your type can compute degree faster than this method.", 
            "title": "Non-Core APIs"
        }, 
        {
            "location": "/#supported-versions", 
            "text": "LightGraphs master is designed to work with the latest stable version of Julia.  Julia 0.3: LightGraphs v0.3.7 is the last version guaranteed to work with Julia 0.3.  Julia 0.4: LightGraphs versions in the 0.6 series are designed to work with Julia 0.4.  Julia 0.5: LightGraphs versions in the 0.7 series are designed to work with Julia 0.5.  Julia 0.6: Some functionality might not work with prerelease / unstable / nightly versions of Julia. If you run into a problem on 0.6, please file an issue.", 
            "title": "Supported Versions"
        }, 
        {
            "location": "/#contributing-and-reporting-bugs", 
            "text": "We welcome contributions and bug reports! Please see  CONTRIBUTING.md  for guidance on development and bug reporting.", 
            "title": "Contributing and Reporting Bugs"
        }, 
        {
            "location": "/basicmeasures/", 
            "text": "Basic Functions\n\n\nLightGraphs.jl\n defines the following basic types and functionalities:\n\n\n\n\nLightGraphs.DiGraph\n\n\nLightGraphs.Edge\n\n\nLightGraphs.Graph\n\n\nLightGraphs.add_edge!\n\n\nLightGraphs.add_vertex!\n\n\nLightGraphs.add_vertices!\n\n\nLightGraphs.all_neighbors\n\n\nLightGraphs.attracting_components\n\n\nLightGraphs.badj\n\n\nLightGraphs.common_neighbors\n\n\nLightGraphs.condensation\n\n\nLightGraphs.condensation\n\n\nLightGraphs.connected_components\n\n\nLightGraphs.degree\n\n\nLightGraphs.degree_histogram\n\n\nLightGraphs.density\n\n\nLightGraphs.dst\n\n\nLightGraphs.edges\n\n\nLightGraphs.fadj\n\n\nLightGraphs.has_edge\n\n\nLightGraphs.has_self_loops\n\n\nLightGraphs.has_vertex\n\n\nLightGraphs.in_edges\n\n\nLightGraphs.in_neighbors\n\n\nLightGraphs.indegree\n\n\nLightGraphs.is_connected\n\n\nLightGraphs.is_directed\n\n\nLightGraphs.is_strongly_connected\n\n\nLightGraphs.is_weakly_connected\n\n\nLightGraphs.isgraphical\n\n\nLightGraphs.ne\n\n\nLightGraphs.neighborhood\n\n\nLightGraphs.neighbors\n\n\nLightGraphs.num_self_loops\n\n\nLightGraphs.nv\n\n\nLightGraphs.out_edges\n\n\nLightGraphs.out_neighbors\n\n\nLightGraphs.outdegree\n\n\nLightGraphs.period\n\n\nLightGraphs.rem_edge!\n\n\nLightGraphs.rem_vertex!\n\n\nLightGraphs.src\n\n\nLightGraphs.strongly_connected_components\n\n\nLightGraphs.vertices\n\n\nLightGraphs.weakly_connected_components\n\n\nLightGraphs.\u0394\n\n\nLightGraphs.\u0394in\n\n\nLightGraphs.\u0394out\n\n\nLightGraphs.\u03b4\n\n\nLightGraphs.\u03b4in\n\n\nLightGraphs.\u03b4out\n\n\n\n\n#\n\n\nLightGraphs.DiGraph\n \n \nType\n.\n\n\nA type representing a directed graph.\n\n\nsource\n\n\n#\n\n\nLightGraphs.Edge\n \n \nType\n.\n\n\nA type representing a single edge between two vertices of a graph.\n\n\nsource\n\n\n#\n\n\nLightGraphs.Graph\n \n \nType\n.\n\n\nA type representing an undirected graph.\n\n\nsource\n\n\n#\n\n\nLightGraphs.add_edge!\n \n \nMethod\n.\n\n\nadd_edge!(g, u, v)\n\n\n\n\nAdd a new edge to \ng\n from \nu\n to \nv\n. Will return false if add fails (e.g., if vertices are not in the graph); true otherwise.\n\n\nsource\n\n\n#\n\n\nLightGraphs.add_vertices!\n \n \nMethod\n.\n\n\nAdd \nn\n new vertices to the graph \ng\n. Returns true if all vertices were added successfully, false otherwise.\n\n\nsource\n\n\n#\n\n\nLightGraphs.common_neighbors\n \n \nMethod\n.\n\n\nReturns the neighbors common to vertices \nu\n and \nv\n in \ng\n.\n\n\nsource\n\n\n#\n\n\nLightGraphs.degree_histogram\n \n \nMethod\n.\n\n\ndegree_histogram(g)\n\n\n\n\nReturns a \nStatsBase.Histogram\n of the degrees of vertices in \ng\n.\n\n\nsource\n\n\n#\n\n\nLightGraphs.dst\n \n \nMethod\n.\n\n\nReturn destination of an edge.\n\n\nsource\n\n\n#\n\n\nLightGraphs.edges\n \n \nMethod\n.\n\n\nReturn an iterator to the edges of a graph. The returned iterator is valid for one pass over the edges, and is invalidated by changes to \ng\n.\n\n\nsource\n\n\n#\n\n\nLightGraphs.fadj\n \n \nMethod\n.\n\n\nReturns the forward adjacency list of a graph.\n\n\nThe Array, where each vertex the Array of destinations for each of the edges eminating from that vertex. This is equivalent to:\n\n\nfadj = [Vector{Int}() for _ in vertices(g)]\nfor e in edges(g)\n    push!(fadj[src(e)], dst(e))\nend\nfadj\n\n\n\n\nFor most graphs types this is pre-calculated.\n\n\nThe optional second argument take the \nv\nth vertex adjacency list, that is:\n\n\nfadj(g, v::Int) == fadj(g)[v]\n\n\n\n\nNOTE: returns a reference, not a copy. Do not modify result.\n\n\nsource\n\n\n#\n\n\nLightGraphs.has_edge\n \n \nMethod\n.\n\n\nReturn true if the graph \ng\n has an edge from \nu\n to \nv\n.\n\n\nsource\n\n\n#\n\n\nLightGraphs.has_self_loops\n \n \nMethod\n.\n\n\nReturns true if \ng\n has any self loops.\n\n\nsource\n\n\n#\n\n\nLightGraphs.has_vertex\n \n \nMethod\n.\n\n\nReturn true if \nv\n is a vertex of \ng\n.\n\n\nsource\n\n\n#\n\n\nLightGraphs.in_edges\n \n \nMethod\n.\n\n\nin_edges(g, v)\n\n\n\n\nReturns an Array of the edges in \ng\n that arrive at vertex \nv\n. \nv=dst(e)\n for each returned edge \ne\n.\n\n\nsource\n\n\n#\n\n\nLightGraphs.in_neighbors\n \n \nMethod\n.\n\n\nReturns a list of all neighbors connected to vertex \nv\n by an incoming edge.\n\n\nNOTE: returns a reference, not a copy. Do not modify result.\n\n\nsource\n\n\n#\n\n\nLightGraphs.indegree\n \n \nMethod\n.\n\n\nReturn the number of edges which start at vertex \nv\n.\n\n\nsource\n\n\n#\n\n\nLightGraphs.ne\n \n \nMethod\n.\n\n\nne(g)\n\n\n\n\nThe number of edges in \ng\n.\n\n\nsource\n\n\n#\n\n\nLightGraphs.neighbors\n \n \nMethod\n.\n\n\nReturns a list of all neighbors of vertex \nv\n in \ng\n.\n\n\nFor DiGraphs, this is equivalent to \nout_neighbors(g, v)\n.\n\n\nNOTE: returns a reference, not a copy. Do not modify result.\n\n\nsource\n\n\n#\n\n\nLightGraphs.num_self_loops\n \n \nMethod\n.\n\n\nReturns the number of self loops in \ng\n.\n\n\nsource\n\n\n#\n\n\nLightGraphs.nv\n \n \nMethod\n.\n\n\nnv(g)\n\n\n\n\nThe number of vertices in \ng\n.\n\n\nsource\n\n\n#\n\n\nLightGraphs.out_edges\n \n \nMethod\n.\n\n\nout_edges(g, v)\n\n\n\n\nReturns an Array of the edges in \ng\n that depart from vertex \nv\n. \nv = src(e)\n for each returned edge \ne\n.\n\n\nsource\n\n\n#\n\n\nLightGraphs.out_neighbors\n \n \nMethod\n.\n\n\nReturns a list of all neighbors connected to vertex \nv\n by an outgoing edge.\n\n\nNOTE: returns a reference, not a copy. Do not modify result.\n\n\nsource\n\n\n#\n\n\nLightGraphs.outdegree\n \n \nMethod\n.\n\n\nReturn the number of edges which end at vertex \nv\n.\n\n\nsource\n\n\n#\n\n\nLightGraphs.rem_edge!\n \n \nMethod\n.\n\n\nrem_edge!(g, u, v)\n\n\n\n\nRemove the edge from \nu\n to \nv\n.\n\n\nReturns false if edge removal fails (e.g., if edge does not exist); true otherwise.\n\n\nsource\n\n\n#\n\n\nLightGraphs.rem_vertex!\n \n \nMethod\n.\n\n\nrem_vertex!(g, v)\n\n\n\n\nRemove the vertex \nv\n from graph \ng\n. This operation has to be performed carefully if one keeps external data structures indexed by edges or vertices in the graph, since internally the removal is performed swapping the vertices \nv\n  and \nn=nv(g)\n, and removing the vertex \nn\n from the graph. After removal the vertices in the \ng\n will be indexed by 1:n-1. This is an O(k^2) operation, where \nk\n is the max of the degrees of vertices \nv\n and \nn\n. Returns false if removal fails (e.g., if vertex is not in the graph); true otherwise.\n\n\nsource\n\n\n#\n\n\nLightGraphs.src\n \n \nMethod\n.\n\n\nReturn source of an edge.\n\n\nsource\n\n\n#\n\n\nLightGraphs.vertices\n \n \nMethod\n.\n\n\nReturn the vertices of a graph.\n\n\nsource\n\n\n#\n\n\nLightGraphs.\u0394\n \n \nMethod\n.\n\n\nReturn the maximum \ndegree\n of vertices in \ng\n.\n\n\nsource\n\n\n#\n\n\nLightGraphs.\u0394in\n \n \nMethod\n.\n\n\nReturn the minimum \nindegree\n of vertices in \ng\n.\n\n\nsource\n\n\n#\n\n\nLightGraphs.\u0394out\n \n \nMethod\n.\n\n\nReturn the maxium \noutdegree\n of vertices in \ng\n.\n\n\nsource\n\n\n#\n\n\nLightGraphs.\u03b4\n \n \nMethod\n.\n\n\nReturn the minimum \ndegree\n of vertices in \ng\n.\n\n\nsource\n\n\n#\n\n\nLightGraphs.\u03b4in\n \n \nMethod\n.\n\n\nReturn the maximum \nindegree\n of vertices in \ng\n.\n\n\nsource\n\n\n#\n\n\nLightGraphs.\u03b4out\n \n \nMethod\n.\n\n\nReturn the minimum \noutdegree\n of vertices in \ng\n.\n\n\nsource\n\n\n#\n\n\nLightGraphs.add_vertex!\n \n \nMethod\n.\n\n\nAdd a new vertex to the graph \ng\n.\n\n\nsource\n\n\n#\n\n\nLightGraphs.all_neighbors\n \n \nMethod\n.\n\n\nReturns all the vertices which share an edge with \nv\n.\n\n\nsource\n\n\n#\n\n\nLightGraphs.badj\n \n \nMethod\n.\n\n\nReturns the backwards adjacency list of a graph. For each vertex the Array of \ndst\n for each edge eminating from that vertex.\n\n\nNOTE: returns a reference, not a copy. Do not modify result.\n\n\nsource\n\n\n#\n\n\nLightGraphs.degree\n \n \nMethod\n.\n\n\nReturn the number of edges (both ingoing and outgoing) from the vertex \nv\n.\n\n\nsource\n\n\n#\n\n\nLightGraphs.density\n \n \nMethod\n.\n\n\nDensity is defined as the ratio of the number of actual edges to the number of possible edges. This is $|v| |v-1|$ for directed graphs and $(|v| |v-1|) / 2$ for undirected graphs.\n\n\nsource\n\n\n#\n\n\nLightGraphs.is_directed\n \n \nMethod\n.\n\n\nReturns \ntrue\n if \ng\n is a \nDiGraph\n.\n\n\nsource\n\n\n#\n\n\nLightGraphs.attracting_components\n \n \nMethod\n.\n\n\nReturns a vector of vectors of integers representing lists of attracting components in \ng\n. The attracting components are a subset of the strongly connected components in which the components do not have any leaving edges.\n\n\nsource\n\n\n#\n\n\nLightGraphs.condensation\n \n \nMethod\n.\n\n\nComputes the condensation graph of the strongly connected components.\n\n\nsource\n\n\n#\n\n\nLightGraphs.condensation\n \n \nMethod\n.\n\n\nReturns the condensation graph associated with \ng\n. The condensation \nh\n of a graph \ng\n is the directed graph where every node in \nh\n represents a strongly connected component in \ng\n, and the presence of an edge between between nodes in \nh\n indicates that there is at least one edge between the associated strongly connected components in \ng\n. The node numbering in \nh\n corresponds to the ordering of the components output from \nstrongly_connected_components\n.\n\n\nsource\n\n\n#\n\n\nLightGraphs.connected_components\n \n \nMethod\n.\n\n\nconnected_components(g)\n\n\n\n\nReturns the \nconnected components\n of \ng\n as a vector of components, each represented by a vector of vertices belonging to the component.\n\n\nsource\n\n\n#\n\n\nLightGraphs.is_connected\n \n \nMethod\n.\n\n\nis_connected(g)\n\n\n\n\nReturns \ntrue\n if \ng\n is connected. For DiGraphs, this is equivalent to a test of weak connectivity.\n\n\nsource\n\n\n#\n\n\nLightGraphs.is_strongly_connected\n \n \nMethod\n.\n\n\nReturns \ntrue\n if \ng\n is (strongly) connected.\n\n\nsource\n\n\n#\n\n\nLightGraphs.is_weakly_connected\n \n \nMethod\n.\n\n\nReturns \ntrue\n if the undirected graph of \ng\n is connected.\n\n\nsource\n\n\n#\n\n\nLightGraphs.isgraphical\n \n \nMethod\n.\n\n\nisgraphical(degs::Vector{Int})\n\n\n\n\nCheck whether the degree sequence \ndegs\n is graphical, according to \nErd\u00f6s-Gallai condition\n.\n\n\nTime complexity: O(length(degs)^2)\n\n\nsource\n\n\n#\n\n\nLightGraphs.neighborhood\n \n \nMethod\n.\n\n\nneighborhood(g, v::Int, d::Int; dir=:out)\n\n\n\n\nReturns a vector of the vertices in \ng\n at distance less or equal to \nd\n from \nv\n. If \ng\n is a \nDiGraph\n the \ndir\n optional argument specifies the edge direction the edge direction with respect to \nv\n (i.e. \n:in\n or \n:out\n) to be considered.\n\n\nsource\n\n\n#\n\n\nLightGraphs.period\n \n \nMethod\n.\n\n\nComputes the (common) period for all nodes in a strongly connected graph.\n\n\nsource\n\n\n#\n\n\nLightGraphs.strongly_connected_components\n \n \nMethod\n.\n\n\nComputes the (strongly) connected components of a directed graph.\n\n\nsource\n\n\n#\n\n\nLightGraphs.weakly_connected_components\n \n \nMethod\n.\n\n\nReturns connected components of the undirected graph of \ng\n.\n\n\nsource", 
            "title": "Basic Functions"
        }, 
        {
            "location": "/basicmeasures/#basic-functions", 
            "text": "LightGraphs.jl  defines the following basic types and functionalities:   LightGraphs.DiGraph  LightGraphs.Edge  LightGraphs.Graph  LightGraphs.add_edge!  LightGraphs.add_vertex!  LightGraphs.add_vertices!  LightGraphs.all_neighbors  LightGraphs.attracting_components  LightGraphs.badj  LightGraphs.common_neighbors  LightGraphs.condensation  LightGraphs.condensation  LightGraphs.connected_components  LightGraphs.degree  LightGraphs.degree_histogram  LightGraphs.density  LightGraphs.dst  LightGraphs.edges  LightGraphs.fadj  LightGraphs.has_edge  LightGraphs.has_self_loops  LightGraphs.has_vertex  LightGraphs.in_edges  LightGraphs.in_neighbors  LightGraphs.indegree  LightGraphs.is_connected  LightGraphs.is_directed  LightGraphs.is_strongly_connected  LightGraphs.is_weakly_connected  LightGraphs.isgraphical  LightGraphs.ne  LightGraphs.neighborhood  LightGraphs.neighbors  LightGraphs.num_self_loops  LightGraphs.nv  LightGraphs.out_edges  LightGraphs.out_neighbors  LightGraphs.outdegree  LightGraphs.period  LightGraphs.rem_edge!  LightGraphs.rem_vertex!  LightGraphs.src  LightGraphs.strongly_connected_components  LightGraphs.vertices  LightGraphs.weakly_connected_components  LightGraphs.\u0394  LightGraphs.\u0394in  LightGraphs.\u0394out  LightGraphs.\u03b4  LightGraphs.\u03b4in  LightGraphs.\u03b4out   #  LightGraphs.DiGraph     Type .  A type representing a directed graph.  source  #  LightGraphs.Edge     Type .  A type representing a single edge between two vertices of a graph.  source  #  LightGraphs.Graph     Type .  A type representing an undirected graph.  source  #  LightGraphs.add_edge!     Method .  add_edge!(g, u, v)  Add a new edge to  g  from  u  to  v . Will return false if add fails (e.g., if vertices are not in the graph); true otherwise.  source  #  LightGraphs.add_vertices!     Method .  Add  n  new vertices to the graph  g . Returns true if all vertices were added successfully, false otherwise.  source  #  LightGraphs.common_neighbors     Method .  Returns the neighbors common to vertices  u  and  v  in  g .  source  #  LightGraphs.degree_histogram     Method .  degree_histogram(g)  Returns a  StatsBase.Histogram  of the degrees of vertices in  g .  source  #  LightGraphs.dst     Method .  Return destination of an edge.  source  #  LightGraphs.edges     Method .  Return an iterator to the edges of a graph. The returned iterator is valid for one pass over the edges, and is invalidated by changes to  g .  source  #  LightGraphs.fadj     Method .  Returns the forward adjacency list of a graph.  The Array, where each vertex the Array of destinations for each of the edges eminating from that vertex. This is equivalent to:  fadj = [Vector{Int}() for _ in vertices(g)]\nfor e in edges(g)\n    push!(fadj[src(e)], dst(e))\nend\nfadj  For most graphs types this is pre-calculated.  The optional second argument take the  v th vertex adjacency list, that is:  fadj(g, v::Int) == fadj(g)[v]  NOTE: returns a reference, not a copy. Do not modify result.  source  #  LightGraphs.has_edge     Method .  Return true if the graph  g  has an edge from  u  to  v .  source  #  LightGraphs.has_self_loops     Method .  Returns true if  g  has any self loops.  source  #  LightGraphs.has_vertex     Method .  Return true if  v  is a vertex of  g .  source  #  LightGraphs.in_edges     Method .  in_edges(g, v)  Returns an Array of the edges in  g  that arrive at vertex  v .  v=dst(e)  for each returned edge  e .  source  #  LightGraphs.in_neighbors     Method .  Returns a list of all neighbors connected to vertex  v  by an incoming edge.  NOTE: returns a reference, not a copy. Do not modify result.  source  #  LightGraphs.indegree     Method .  Return the number of edges which start at vertex  v .  source  #  LightGraphs.ne     Method .  ne(g)  The number of edges in  g .  source  #  LightGraphs.neighbors     Method .  Returns a list of all neighbors of vertex  v  in  g .  For DiGraphs, this is equivalent to  out_neighbors(g, v) .  NOTE: returns a reference, not a copy. Do not modify result.  source  #  LightGraphs.num_self_loops     Method .  Returns the number of self loops in  g .  source  #  LightGraphs.nv     Method .  nv(g)  The number of vertices in  g .  source  #  LightGraphs.out_edges     Method .  out_edges(g, v)  Returns an Array of the edges in  g  that depart from vertex  v .  v = src(e)  for each returned edge  e .  source  #  LightGraphs.out_neighbors     Method .  Returns a list of all neighbors connected to vertex  v  by an outgoing edge.  NOTE: returns a reference, not a copy. Do not modify result.  source  #  LightGraphs.outdegree     Method .  Return the number of edges which end at vertex  v .  source  #  LightGraphs.rem_edge!     Method .  rem_edge!(g, u, v)  Remove the edge from  u  to  v .  Returns false if edge removal fails (e.g., if edge does not exist); true otherwise.  source  #  LightGraphs.rem_vertex!     Method .  rem_vertex!(g, v)  Remove the vertex  v  from graph  g . This operation has to be performed carefully if one keeps external data structures indexed by edges or vertices in the graph, since internally the removal is performed swapping the vertices  v   and  n=nv(g) , and removing the vertex  n  from the graph. After removal the vertices in the  g  will be indexed by 1:n-1. This is an O(k^2) operation, where  k  is the max of the degrees of vertices  v  and  n . Returns false if removal fails (e.g., if vertex is not in the graph); true otherwise.  source  #  LightGraphs.src     Method .  Return source of an edge.  source  #  LightGraphs.vertices     Method .  Return the vertices of a graph.  source  #  LightGraphs.\u0394     Method .  Return the maximum  degree  of vertices in  g .  source  #  LightGraphs.\u0394in     Method .  Return the minimum  indegree  of vertices in  g .  source  #  LightGraphs.\u0394out     Method .  Return the maxium  outdegree  of vertices in  g .  source  #  LightGraphs.\u03b4     Method .  Return the minimum  degree  of vertices in  g .  source  #  LightGraphs.\u03b4in     Method .  Return the maximum  indegree  of vertices in  g .  source  #  LightGraphs.\u03b4out     Method .  Return the minimum  outdegree  of vertices in  g .  source  #  LightGraphs.add_vertex!     Method .  Add a new vertex to the graph  g .  source  #  LightGraphs.all_neighbors     Method .  Returns all the vertices which share an edge with  v .  source  #  LightGraphs.badj     Method .  Returns the backwards adjacency list of a graph. For each vertex the Array of  dst  for each edge eminating from that vertex.  NOTE: returns a reference, not a copy. Do not modify result.  source  #  LightGraphs.degree     Method .  Return the number of edges (both ingoing and outgoing) from the vertex  v .  source  #  LightGraphs.density     Method .  Density is defined as the ratio of the number of actual edges to the number of possible edges. This is $|v| |v-1|$ for directed graphs and $(|v| |v-1|) / 2$ for undirected graphs.  source  #  LightGraphs.is_directed     Method .  Returns  true  if  g  is a  DiGraph .  source  #  LightGraphs.attracting_components     Method .  Returns a vector of vectors of integers representing lists of attracting components in  g . The attracting components are a subset of the strongly connected components in which the components do not have any leaving edges.  source  #  LightGraphs.condensation     Method .  Computes the condensation graph of the strongly connected components.  source  #  LightGraphs.condensation     Method .  Returns the condensation graph associated with  g . The condensation  h  of a graph  g  is the directed graph where every node in  h  represents a strongly connected component in  g , and the presence of an edge between between nodes in  h  indicates that there is at least one edge between the associated strongly connected components in  g . The node numbering in  h  corresponds to the ordering of the components output from  strongly_connected_components .  source  #  LightGraphs.connected_components     Method .  connected_components(g)  Returns the  connected components  of  g  as a vector of components, each represented by a vector of vertices belonging to the component.  source  #  LightGraphs.is_connected     Method .  is_connected(g)  Returns  true  if  g  is connected. For DiGraphs, this is equivalent to a test of weak connectivity.  source  #  LightGraphs.is_strongly_connected     Method .  Returns  true  if  g  is (strongly) connected.  source  #  LightGraphs.is_weakly_connected     Method .  Returns  true  if the undirected graph of  g  is connected.  source  #  LightGraphs.isgraphical     Method .  isgraphical(degs::Vector{Int})  Check whether the degree sequence  degs  is graphical, according to  Erd\u00f6s-Gallai condition .  Time complexity: O(length(degs)^2)  source  #  LightGraphs.neighborhood     Method .  neighborhood(g, v::Int, d::Int; dir=:out)  Returns a vector of the vertices in  g  at distance less or equal to  d  from  v . If  g  is a  DiGraph  the  dir  optional argument specifies the edge direction the edge direction with respect to  v  (i.e.  :in  or  :out ) to be considered.  source  #  LightGraphs.period     Method .  Computes the (common) period for all nodes in a strongly connected graph.  source  #  LightGraphs.strongly_connected_components     Method .  Computes the (strongly) connected components of a directed graph.  source  #  LightGraphs.weakly_connected_components     Method .  Returns connected components of the undirected graph of  g .  source", 
            "title": "Basic Functions"
        }, 
        {
            "location": "/operators/", 
            "text": "Operators\n\n\nLightGraphs.jl\n implements the following graph operators. In general, functions with two graph arguments will require them to be of the same type (either both \nGraph\n or both \nDiGraph\n).\n\n\n\n\nBase.SparseArrays.blkdiag\n\n\nBase.intersect\n\n\nBase.join\n\n\nBase.reverse\n\n\nBase.reverse!\n\n\nBase.union\n\n\nLightGraphs.cartesian_product\n\n\nLightGraphs.complement\n\n\nLightGraphs.crosspath\n\n\nLightGraphs.difference\n\n\nLightGraphs.egonet\n\n\nLightGraphs.induced_subgraph\n\n\nLightGraphs.symmetric_difference\n\n\nLightGraphs.tensor_product\n\n\n\n\n#\n\n\nBase.SparseArrays.blkdiag\n \n \nMethod\n.\n\n\nblkdiag(g, h)\n\n\n\n\nProduces a graph with $|V(g)| + |V(h)|$ vertices and $|E(g)| + |E(h)|$ edges.\n\n\nPut simply, the vertices and edges from graph \nh\n are appended to graph \ng\n.\n\n\nsource\n\n\n#\n\n\nBase.intersect\n \n \nMethod\n.\n\n\nintersect(g, h)\n\n\n\n\nProduces a graph with edges that are only in both graph \ng\n and graph \nh\n.\n\n\nNote that this function may produce a graph with 0-degree vertices.\n\n\nsource\n\n\n#\n\n\nBase.join\n \n \nMethod\n.\n\n\njoin(g, h)\n\n\n\n\nMerges graphs \ng\n and \nh\n using \nblkdiag\n and then adds all the edges between  the vertices in \ng\n and those in \nh\n.\n\n\nsource\n\n\n#\n\n\nBase.reverse!\n \n \nMethod\n.\n\n\nreverse!(g::DiGraph)\n\n\n\n\nIn-place reverse (modifies the original graph).\n\n\nsource\n\n\n#\n\n\nBase.reverse\n \n \nMethod\n.\n\n\nreverse(g::DiGraph)\n\n\n\n\nProduces a graph where all edges are reversed from the original.\n\n\nsource\n\n\n#\n\n\nBase.union\n \n \nMethod\n.\n\n\nunion(g, h)\n\n\n\n\nMerges graphs \ng\n and \nh\n by taking the set union of all vertices and edges.\n\n\nsource\n\n\n#\n\n\nLightGraphs.cartesian_product\n \n \nMethod\n.\n\n\ncartesian_product(g, h)\n\n\n\n\nReturns the (cartesian product)[https://en.wikipedia.org/wiki/Tensor_product_of_graphs] of \ng\n and \nh\n\n\nsource\n\n\n#\n\n\nLightGraphs.complement\n \n \nMethod\n.\n\n\ncomplement(g)\n\n\n\n\nProduces the \ngraph complement\n of a graph.\n\n\nsource\n\n\n#\n\n\nLightGraphs.crosspath\n \n \nMethod\n.\n\n\ncrosspath(len::Integer, g::Graph)\n\n\n\n\nReplicate \nlen\n times \nh\n and connect each vertex with its copies in a path\n\n\nsource\n\n\n#\n\n\nLightGraphs.difference\n \n \nMethod\n.\n\n\ndifference(g, h)\n\n\n\n\nProduces a graph with edges in graph \ng\n that are not in graph \nh\n.\n\n\nNote that this function may produce a graph with 0-degree vertices.\n\n\nsource\n\n\n#\n\n\nLightGraphs.egonet\n \n \nMethod\n.\n\n\negonet(g, v::Int, d::Int; dir=:out)\n\n\n\n\nReturns the subgraph of \ng\n induced by the neighbors of \nv\n up to distance \nd\n. If \ng\n is a \nDiGraph\n the \ndir\n optional argument specifies the edge direction the edge direction with respect to \nv\n (i.e. \n:in\n or \n:out\n) to be considered. This is equivalent to \ninduced_subgraph\n(g, neighborhood(g, v, d, dir=dir))[1].\n\n\nsource\n\n\n#\n\n\nLightGraphs.induced_subgraph\n \n \nMethod\n.\n\n\ninduced_subgraph(g, vlist)\n\n\n\n\nReturns the subgraph of \ng\n induced by the vertices in  \nvlist\n.\n\n\nThe returned graph has \nlength(vlist)\n vertices, with the new vertex \ni\n corresponding to the vertex of the original graph in the \ni\n-th position of \nvlist\n.\n\n\nReturns  also a vector \nvmap\n mapping the new vertices to the old ones: the  vertex \ni\n in the subgraph corresponds to the vertex \nvmap[i]\n in \ng\n.\n\n\ninduced_subgraph(g, elist)\n\n\n\n\nReturns the subgraph of \ng\n induced by the edges in \nelist\n, along with the associated vector \nvmap\n mapping new vertices to the old ones.\n\n\nUsage Examples:\n\n\ng = CompleteGraph(10)\nsg, vmap = subgraph(g, 5:8)\n@assert g[5:8] == sg\n@assert nv(sg) == 4\n@assert ne(sg) == 6\n@assert vm[4] == 8\n\nsg, vmap = subgraph(g, [2,8,3,4])\n@asssert sg == g[[2,8,3,4]]\n\nelist = [Edge(1,2), Edge(3,4), Edge(4,8)]\nsg, vmap = subgraph(g, elist)\n@asssert sg == g[elist]\n\n\n\n\nsource\n\n\n#\n\n\nLightGraphs.symmetric_difference\n \n \nMethod\n.\n\n\nsymmetric_difference(g, h)\n\n\n\n\nProduces a graph with edges from graph \ng\n that do not exist in graph \nh\n, and vice versa.\n\n\nNote that this function may produce a graph with 0-degree vertices.\n\n\nsource\n\n\n#\n\n\nLightGraphs.tensor_product\n \n \nMethod\n.\n\n\ntensor_product(g, h)\n\n\n\n\nReturns the (tensor product)[https://en.wikipedia.org/wiki/Tensor_product_of_graphs] of \ng\n and \nh\n\n\nsource", 
            "title": "Operators"
        }, 
        {
            "location": "/operators/#operators", 
            "text": "LightGraphs.jl  implements the following graph operators. In general, functions with two graph arguments will require them to be of the same type (either both  Graph  or both  DiGraph ).   Base.SparseArrays.blkdiag  Base.intersect  Base.join  Base.reverse  Base.reverse!  Base.union  LightGraphs.cartesian_product  LightGraphs.complement  LightGraphs.crosspath  LightGraphs.difference  LightGraphs.egonet  LightGraphs.induced_subgraph  LightGraphs.symmetric_difference  LightGraphs.tensor_product   #  Base.SparseArrays.blkdiag     Method .  blkdiag(g, h)  Produces a graph with $|V(g)| + |V(h)|$ vertices and $|E(g)| + |E(h)|$ edges.  Put simply, the vertices and edges from graph  h  are appended to graph  g .  source  #  Base.intersect     Method .  intersect(g, h)  Produces a graph with edges that are only in both graph  g  and graph  h .  Note that this function may produce a graph with 0-degree vertices.  source  #  Base.join     Method .  join(g, h)  Merges graphs  g  and  h  using  blkdiag  and then adds all the edges between  the vertices in  g  and those in  h .  source  #  Base.reverse!     Method .  reverse!(g::DiGraph)  In-place reverse (modifies the original graph).  source  #  Base.reverse     Method .  reverse(g::DiGraph)  Produces a graph where all edges are reversed from the original.  source  #  Base.union     Method .  union(g, h)  Merges graphs  g  and  h  by taking the set union of all vertices and edges.  source  #  LightGraphs.cartesian_product     Method .  cartesian_product(g, h)  Returns the (cartesian product)[https://en.wikipedia.org/wiki/Tensor_product_of_graphs] of  g  and  h  source  #  LightGraphs.complement     Method .  complement(g)  Produces the  graph complement  of a graph.  source  #  LightGraphs.crosspath     Method .  crosspath(len::Integer, g::Graph)  Replicate  len  times  h  and connect each vertex with its copies in a path  source  #  LightGraphs.difference     Method .  difference(g, h)  Produces a graph with edges in graph  g  that are not in graph  h .  Note that this function may produce a graph with 0-degree vertices.  source  #  LightGraphs.egonet     Method .  egonet(g, v::Int, d::Int; dir=:out)  Returns the subgraph of  g  induced by the neighbors of  v  up to distance  d . If  g  is a  DiGraph  the  dir  optional argument specifies the edge direction the edge direction with respect to  v  (i.e.  :in  or  :out ) to be considered. This is equivalent to  induced_subgraph (g, neighborhood(g, v, d, dir=dir))[1].  source  #  LightGraphs.induced_subgraph     Method .  induced_subgraph(g, vlist)  Returns the subgraph of  g  induced by the vertices in   vlist .  The returned graph has  length(vlist)  vertices, with the new vertex  i  corresponding to the vertex of the original graph in the  i -th position of  vlist .  Returns  also a vector  vmap  mapping the new vertices to the old ones: the  vertex  i  in the subgraph corresponds to the vertex  vmap[i]  in  g .  induced_subgraph(g, elist)  Returns the subgraph of  g  induced by the edges in  elist , along with the associated vector  vmap  mapping new vertices to the old ones.  Usage Examples:  g = CompleteGraph(10)\nsg, vmap = subgraph(g, 5:8)\n@assert g[5:8] == sg\n@assert nv(sg) == 4\n@assert ne(sg) == 6\n@assert vm[4] == 8\n\nsg, vmap = subgraph(g, [2,8,3,4])\n@asssert sg == g[[2,8,3,4]]\n\nelist = [Edge(1,2), Edge(3,4), Edge(4,8)]\nsg, vmap = subgraph(g, elist)\n@asssert sg == g[elist]  source  #  LightGraphs.symmetric_difference     Method .  symmetric_difference(g, h)  Produces a graph with edges from graph  g  that do not exist in graph  h , and vice versa.  Note that this function may produce a graph with 0-degree vertices.  source  #  LightGraphs.tensor_product     Method .  tensor_product(g, h)  Returns the (tensor product)[https://en.wikipedia.org/wiki/Tensor_product_of_graphs] of  g  and  h  source", 
            "title": "Operators"
        }, 
        {
            "location": "/pathing/", 
            "text": "Path and Traversal\n\n\nLightGraphs.jl\n provides several traversal and shortest-path algorithms, along with various utility functions. Where appropriate, edge distances may be passed in as a matrix of real number values.\n\n\nEdge distances for most traversals may be passed in as a sparse or dense matrix of  values, indexed by \n[src,dst]\n vertices. That is, \ndistmx[2,4] = 2.5\n assigns the distance \n2.5\n to the (directed) edge connecting vertex 2 and vertex 4. Note that also for undirected graphs \ndistmx[4,2]\n has to be set.\n\n\nAny graph traversal  will traverse an edge only if it is present in the graph. When a distance matrix is passed in,\n\n\n\n\ndistance values for undefined edges will be ignored, and\n\n\nany unassigned values (in sparse distance matrices), for edges that are present in the graph, will be assumed to take the default value of 1.0.\n\n\nany zero values (in sparse/dense distance matrices), for edges that are present in the graph, will instead have an implicit edge cost of 1.0.\n\n\n\n\n\n\nGraph Traversal\n\n\nGraph traversal\n refers to a process that traverses vertices of a graph following certain order (starting from user-input sources). This package implements three traversal schemes:\n\n\n\n\nBreadthFirst\n,\n\n\nDepthFirst\n, and\n\n\nMaximumAdjacency\n.\n\n\n\n\n#\n\n\nLightGraphs.bfs_tree\n \n \nFunction\n.\n\n\nProvides a breadth-first traversal of the graph \ng\n starting with source vertex \ns\n, and returns a directed acyclic graph of vertices in the order they were discovered.\n\n\nThis function is a high level wrapper around bfs_tree!, use that function for more performance.\n\n\nsource\n\n\n#\n\n\nLightGraphs.dfs_tree\n \n \nFunction\n.\n\n\ndfs_tree(g, s::Int)\n\n\n\n\nProvides a depth-first traversal of the graph \ng\n starting with source vertex \ns\n, and returns a directed acyclic graph of vertices in the order they were discovered.\n\n\nsource\n\n\n#\n\n\nLightGraphs.maximum_adjacency_visit\n \n \nFunction\n.\n\n\nReturns the vertices in \ng\n traversed by maximum adjacency search. An optional \ndistmx\n matrix may be specified; if omitted, edge distances are assumed to be 1. If \nlog\n (default \nfalse\n) is \ntrue\n, visitor events will be printed to \nio\n, which defaults to \nSTDOUT\n; otherwise, no event information will be displayed.\n\n\nsource\n\n\n\n\nRandom walks\n\n\nLightGraphs\n includes uniform random walks and self avoiding walks:\n\n\n#\n\n\nLightGraphs.randomwalk\n \n \nFunction\n.\n\n\nPerforms a random walk on graph \ng\n starting at vertex \ns\n and continuing for a maximum of \nniter\n steps. Returns a vector of vertices visited in order.\n\n\nsource\n\n\n#\n\n\nLightGraphs.saw\n \n \nFunction\n.\n\n\nPerforms a \nself-avoiding walk\n on graph \ng\n starting at vertex \ns\n and continuing for a maximum of \nniter\n steps. Returns a vector of vertices visited in order.\n\n\nsource\n\n\n\n\nConnectivity / Bipartiteness\n\n\nGraph connectivity\n functions are defined on both undirected and directed graphs:\n\n\nis_connected\nis_strongly_connected\nis_weakly_connected\nconnected_components\nstrongly_connected_components\nweakly_connected_components\nhas_self_loop\nattracting_components\nis_bipartite\ncondensation\nperiod\n\n\n\n\n\n\nCycle Detection\n\n\nIn graph theory, a cycle is defined to be a path that starts from some vertex \nv\n and ends up at \nv\n.\n\n\n#\n\n\nLightGraphs.is_cyclic\n \n \nFunction\n.\n\n\nis_cyclic(g)\n\n\n\n\nTests whether a graph contains a cycle through depth-first search. It returns \ntrue\n when it finds a cycle, otherwise \nfalse\n.\n\n\nsource\n\n\n\n\nShortest-Path Algorithms\n\n\n\n\nGeneral properties of shortest path algorithms\n\n\n\n\nThe distance from a vertex to itself is always \n0\n.\n\n\nThe distance between two vertices with no connecting edge is always \nInf\n.\n\n\n\n\n#\n\n\nLightGraphs.a_star\n \n \nFunction\n.\n\n\nComputes the shortest path between vertices \ns\n and \nt\n using the \nA* search algorithm\n. An optional heuristic function and edge distance matrix may be supplied.\n\n\nsource\n\n\n#\n\n\nLightGraphs.dijkstra_shortest_paths\n \n \nFunction\n.\n\n\nPerforms \nDijkstra's algorithm\n on a graph, computing shortest distances between a source vertex \ns\n and all other nodes. Returns a \nDijkstraState\n that contains various traversal information (see below).\n\n\nWith \nallpaths=true\n, returns a \nDijkstraState\n that keeps track of all predecessors of a given vertex (see below).\n\n\nsource\n\n\n#\n\n\nLightGraphs.bellman_ford_shortest_paths\n \n \nFunction\n.\n\n\nUses the \nBellman-Ford algorithm\n to compute shortest paths between a source vertex \ns\n or a set of source vertices \nss\n. Returns a \nBellmanFordState\n with relevant traversal information (see below).\n\n\nsource\n\n\n#\n\n\nLightGraphs.floyd_warshall_shortest_paths\n \n \nFunction\n.\n\n\nUses the \nFloyd-Warshall algorithm\n to compute shortest paths between all pairs of vertices in graph \ng\n. Returns a \nFloydWarshallState\n with relevant traversal information, each is a vertex-indexed vector of vectors containing the metric for each vertex in the graph.\n\n\nNote that this algorithm may return a large amount of data (it will allocate on the order of $\\mathcal{O}(nv^2)$).\n\n\nsource\n\n\n\n\nPath discovery / enumeration\n\n\n#\n\n\nLightGraphs.gdistances\n \n \nFunction\n.\n\n\ngdistances(g, source) -\n dists\n\n\n\n\nReturns a vector filled with the geodesic distances of vertices in  \ng\n from vertex/vertices \nsource\n. If \nsource\n is a collection of vertices they should be unique (not checked). For vertices in disconnected components the default distance is -1.\n\n\nsource\n\n\n#\n\n\nLightGraphs.gdistances!\n \n \nFunction\n.\n\n\ngdistances!(g, source, dists) -\n dists\n\n\n\n\nFills \ndists\n with the geodesic distances of vertices in \ng\n from vertex/vertices \nsource\n. \ndists\n should be a vector of length \nnv(g)\n.\n\n\nsource\n\n\n#\n\n\nLightGraphs.enumerate_paths\n \n \nFunction\n.\n\n\nGiven a path state \nstate\n of type \nAbstractPathState\n (see below), returns a vector (indexed by vertex) of the paths between the source vertex used to compute the path state and a destination vertex \nv\n, a set of destination vertices \nvs\n, or the entire graph. For multiple destination vertices, each path is represented by a vector of vertices on the path between the source and the destination. Nonexistent paths will be indicated by an empty vector. For single destinations, the path is represented by a single vector of vertices, and will be length 0 if the path does not exist.\n\n\nFor Floyd-Warshall path states, please note that the output is a bit different, since this algorithm calculates all shortest paths for all pairs of vertices: \nenumerate_paths(state)\n will return a vector (indexed by source vertex) of vectors (indexed by destination vertex) of paths. \nenumerate_paths(state, v)\n will return a vector (indexed by destination vertex) of paths from source \nv\n to all other vertices. In addition, \nenumerate_paths(state, v, d)\n will return a vector representing the path from vertex \nv\n to vertex \nd\n.\n\n\nsource\n\n\nFor Floyd-Warshall path states, please note that the output is a bit different, since this algorithm calculates all shortest paths for all pairs of vertices: \nenumerate_paths(state)\n will return a vector (indexed by source vertex) of vectors (indexed by destination vertex) of paths. \nenumerate_paths(state, v)\n will return a vector (indexed by destination vertex) of paths from source \nv\n to all other vertices. In addition, \nenumerate_paths(state, v, d)\n will return a vector representing the path from vertex \nv\n to vertex \nd\n.\n\n\n\n\nPath States\n\n\nThe \nfloyd_warshall_shortest_paths\n, \nbellman_ford_shortest_paths\n, \ndijkstra_shortest_paths\n, and \ndijkstra_predecessor_and_distance\n functions return a state that contains various information about the graph learned during traversal. The three state types have the following common information, accessible via the type:\n\n\n.dists\n Holds a vector of distances computed, indexed by source vertex.\n\n\n.parents\n Holds a vector of parents of each source vertex. The parent of a source vertex is always \n0\n.\n\n\nIn addition, the \ndijkstra_predecessor_and_distance\n function stores the following information:\n\n\n.predecessors\n Holds a vector, indexed by vertex, of all the predecessors discovered during shortest-path calculations. This keeps track of all parents when there are multiple shortest paths available from the source.\n\n\n.pathcounts\n Holds a vector, indexed by vertex, of the path counts discovered during traversal. This equals the length of each subvector in the \n.predecessors\n output above.", 
            "title": "Path and Traversal"
        }, 
        {
            "location": "/pathing/#path-and-traversal", 
            "text": "LightGraphs.jl  provides several traversal and shortest-path algorithms, along with various utility functions. Where appropriate, edge distances may be passed in as a matrix of real number values.  Edge distances for most traversals may be passed in as a sparse or dense matrix of  values, indexed by  [src,dst]  vertices. That is,  distmx[2,4] = 2.5  assigns the distance  2.5  to the (directed) edge connecting vertex 2 and vertex 4. Note that also for undirected graphs  distmx[4,2]  has to be set.  Any graph traversal  will traverse an edge only if it is present in the graph. When a distance matrix is passed in,   distance values for undefined edges will be ignored, and  any unassigned values (in sparse distance matrices), for edges that are present in the graph, will be assumed to take the default value of 1.0.  any zero values (in sparse/dense distance matrices), for edges that are present in the graph, will instead have an implicit edge cost of 1.0.", 
            "title": "Path and Traversal"
        }, 
        {
            "location": "/pathing/#graph-traversal", 
            "text": "Graph traversal  refers to a process that traverses vertices of a graph following certain order (starting from user-input sources). This package implements three traversal schemes:   BreadthFirst ,  DepthFirst , and  MaximumAdjacency .   #  LightGraphs.bfs_tree     Function .  Provides a breadth-first traversal of the graph  g  starting with source vertex  s , and returns a directed acyclic graph of vertices in the order they were discovered.  This function is a high level wrapper around bfs_tree!, use that function for more performance.  source  #  LightGraphs.dfs_tree     Function .  dfs_tree(g, s::Int)  Provides a depth-first traversal of the graph  g  starting with source vertex  s , and returns a directed acyclic graph of vertices in the order they were discovered.  source  #  LightGraphs.maximum_adjacency_visit     Function .  Returns the vertices in  g  traversed by maximum adjacency search. An optional  distmx  matrix may be specified; if omitted, edge distances are assumed to be 1. If  log  (default  false ) is  true , visitor events will be printed to  io , which defaults to  STDOUT ; otherwise, no event information will be displayed.  source", 
            "title": "Graph Traversal"
        }, 
        {
            "location": "/pathing/#random-walks", 
            "text": "LightGraphs  includes uniform random walks and self avoiding walks:  #  LightGraphs.randomwalk     Function .  Performs a random walk on graph  g  starting at vertex  s  and continuing for a maximum of  niter  steps. Returns a vector of vertices visited in order.  source  #  LightGraphs.saw     Function .  Performs a  self-avoiding walk  on graph  g  starting at vertex  s  and continuing for a maximum of  niter  steps. Returns a vector of vertices visited in order.  source", 
            "title": "Random walks"
        }, 
        {
            "location": "/pathing/#connectivity-bipartiteness", 
            "text": "Graph connectivity  functions are defined on both undirected and directed graphs:  is_connected\nis_strongly_connected\nis_weakly_connected\nconnected_components\nstrongly_connected_components\nweakly_connected_components\nhas_self_loop\nattracting_components\nis_bipartite\ncondensation\nperiod", 
            "title": "Connectivity / Bipartiteness"
        }, 
        {
            "location": "/pathing/#cycle-detection", 
            "text": "In graph theory, a cycle is defined to be a path that starts from some vertex  v  and ends up at  v .  #  LightGraphs.is_cyclic     Function .  is_cyclic(g)  Tests whether a graph contains a cycle through depth-first search. It returns  true  when it finds a cycle, otherwise  false .  source", 
            "title": "Cycle Detection"
        }, 
        {
            "location": "/pathing/#shortest-path-algorithms", 
            "text": "", 
            "title": "Shortest-Path Algorithms"
        }, 
        {
            "location": "/pathing/#general-properties-of-shortest-path-algorithms", 
            "text": "The distance from a vertex to itself is always  0 .  The distance between two vertices with no connecting edge is always  Inf .   #  LightGraphs.a_star     Function .  Computes the shortest path between vertices  s  and  t  using the  A* search algorithm . An optional heuristic function and edge distance matrix may be supplied.  source  #  LightGraphs.dijkstra_shortest_paths     Function .  Performs  Dijkstra's algorithm  on a graph, computing shortest distances between a source vertex  s  and all other nodes. Returns a  DijkstraState  that contains various traversal information (see below).  With  allpaths=true , returns a  DijkstraState  that keeps track of all predecessors of a given vertex (see below).  source  #  LightGraphs.bellman_ford_shortest_paths     Function .  Uses the  Bellman-Ford algorithm  to compute shortest paths between a source vertex  s  or a set of source vertices  ss . Returns a  BellmanFordState  with relevant traversal information (see below).  source  #  LightGraphs.floyd_warshall_shortest_paths     Function .  Uses the  Floyd-Warshall algorithm  to compute shortest paths between all pairs of vertices in graph  g . Returns a  FloydWarshallState  with relevant traversal information, each is a vertex-indexed vector of vectors containing the metric for each vertex in the graph.  Note that this algorithm may return a large amount of data (it will allocate on the order of $\\mathcal{O}(nv^2)$).  source", 
            "title": "General properties of shortest path algorithms"
        }, 
        {
            "location": "/pathing/#path-discovery-enumeration", 
            "text": "#  LightGraphs.gdistances     Function .  gdistances(g, source) -  dists  Returns a vector filled with the geodesic distances of vertices in   g  from vertex/vertices  source . If  source  is a collection of vertices they should be unique (not checked). For vertices in disconnected components the default distance is -1.  source  #  LightGraphs.gdistances!     Function .  gdistances!(g, source, dists) -  dists  Fills  dists  with the geodesic distances of vertices in  g  from vertex/vertices  source .  dists  should be a vector of length  nv(g) .  source  #  LightGraphs.enumerate_paths     Function .  Given a path state  state  of type  AbstractPathState  (see below), returns a vector (indexed by vertex) of the paths between the source vertex used to compute the path state and a destination vertex  v , a set of destination vertices  vs , or the entire graph. For multiple destination vertices, each path is represented by a vector of vertices on the path between the source and the destination. Nonexistent paths will be indicated by an empty vector. For single destinations, the path is represented by a single vector of vertices, and will be length 0 if the path does not exist.  For Floyd-Warshall path states, please note that the output is a bit different, since this algorithm calculates all shortest paths for all pairs of vertices:  enumerate_paths(state)  will return a vector (indexed by source vertex) of vectors (indexed by destination vertex) of paths.  enumerate_paths(state, v)  will return a vector (indexed by destination vertex) of paths from source  v  to all other vertices. In addition,  enumerate_paths(state, v, d)  will return a vector representing the path from vertex  v  to vertex  d .  source  For Floyd-Warshall path states, please note that the output is a bit different, since this algorithm calculates all shortest paths for all pairs of vertices:  enumerate_paths(state)  will return a vector (indexed by source vertex) of vectors (indexed by destination vertex) of paths.  enumerate_paths(state, v)  will return a vector (indexed by destination vertex) of paths from source  v  to all other vertices. In addition,  enumerate_paths(state, v, d)  will return a vector representing the path from vertex  v  to vertex  d .", 
            "title": "Path discovery / enumeration"
        }, 
        {
            "location": "/pathing/#path-states", 
            "text": "The  floyd_warshall_shortest_paths ,  bellman_ford_shortest_paths ,  dijkstra_shortest_paths , and  dijkstra_predecessor_and_distance  functions return a state that contains various information about the graph learned during traversal. The three state types have the following common information, accessible via the type:  .dists  Holds a vector of distances computed, indexed by source vertex.  .parents  Holds a vector of parents of each source vertex. The parent of a source vertex is always  0 .  In addition, the  dijkstra_predecessor_and_distance  function stores the following information:  .predecessors  Holds a vector, indexed by vertex, of all the predecessors discovered during shortest-path calculations. This keeps track of all parents when there are multiple shortest paths available from the source.  .pathcounts  Holds a vector, indexed by vertex, of the path counts discovered during traversal. This equals the length of each subvector in the  .predecessors  output above.", 
            "title": "Path States"
        }, 
        {
            "location": "/distance/", 
            "text": "Distance\n\n\nLightGraphs.jl\n includes the following distance measurements:\n\n\n#\n\n\nLightGraphs.BoundedMinkowskiCost\n \n \nMethod\n.\n\n\nSimilar to MinkowskiCost, but ensures costs smaller than 2\u03c4.\n\n\nsource\n\n\n#\n\n\nLightGraphs.MinkowskiCost\n \n \nMethod\n.\n\n\nFor labels \u03bc\u2081 on the vertices of graph G\u2081 and labels \u03bc\u2082 on the vertices of graph G\u2082, compute the p-norm cost of substituting vertex u \u2208 G\u2081 by vertex v \u2208 G\u2082.\n\n\nsource\n\n\n#\n\n\nLightGraphs.center\n \n \nMethod\n.\n\n\nReturns the set of all vertices whose eccentricity is equal to the graph's radius (that is, the set of vertices with the smallest eccentricity).\n\n\nsource\n\n\n#\n\n\nLightGraphs.diameter\n \n \nMethod\n.\n\n\nReturns the maximum eccentricity of the graph.\n\n\nsource\n\n\n#\n\n\nLightGraphs.eccentricity\n \n \nFunction\n.\n\n\nCalculates the eccentricity[ies] of a vertex \nv\n, vertex vector \nvs\n, or the entire graph. An optional matrix of edge distances may be supplied.\n\n\nThe eccentricity of a vertex is the maximum shortest-path distance between it and all other vertices in the graph.\n\n\nBecause this function must calculate shortest paths for all vertices supplied in the argument list, it may take a long time.\n\n\nThe output is either a single float (when a single vertex is provided) or a vector of floats corresponding to the vertex vector. If no vertex vector is provided, the vector returned corresponds to each vertex in the graph.\n\n\nNote: the eccentricity vector returned by \neccentricity()\n may be used as input for the rest of the distance measures below. If an eccentricity vector is provided, it will be used. Otherwise, an eccentricity vector will be calculated for each call to the function. It may therefore be more efficient to calculate, store, and pass the eccentricities if multiple distance measures are desired.\n\n\nsource\n\n\n#\n\n\nLightGraphs.edit_distance\n \n \nMethod\n.\n\n\nComputes the edit distance between graphs G\u2081 and G\u2082.\n\n\nReturns the minimum edit cost and edit path to transform graph G\u2081 into graph G\u2082. An edit path consists of a sequence of pairs of vertices (u,v) \u2208 [0,|G\u2081|] \u00d7 [0,|G\u2082|] representing vertex operations:\n\n\n\n\n(0,v): insertion of vertex v \u2208 G\u2082\n\n\n(u,0): deletion of vertex u \u2208 G\u2081\n\n\n(u\n0,v\n0): substitution of vertex u \u2208 G\u2081 by vertex v \u2208 G\u2082\n\n\n\n\nBy default, the algorithm uses constant operation costs. The user can provide classical Minkowski costs computed from vertex labels \u03bc\u2081 (for G\u2081) and \u03bc\u2082 (for G\u2082) in order to further guide the search, for example:\n\n\nedit_distance(G\u2081, G\u2082, subst_cost=MinkowskiCost(\u03bc\u2081, \u03bc\u2082))\n\n\n\n\nA custom heuristic can be provided to the A* search in case the default heuristic is not satisfactory.\n\n\nPerformance tips:\n\n\n\n\nGiven two graphs |G\u2081| \n |G\u2082|, \nedit_distance(G\u2081, G\u2082)\n is faster to\n\n\n\n\ncompute than \nedit_distance(G\u2082, G\u2081)\n. Consider swapping the arguments if involved costs are ``symmetric''.\n\n\n\n\nThe use of simple Minkowski costs can improve performance considerably.\n\n\nExploit vertex attributes when designing operation costs.\n\n\n\n\nFor further details, please refer to:\n\n\nRIESEN, K., 2015. Structural Pattern Recognition with Graph Edit Distance: Approximation Algorithms and Applications. (Chapter 2)\n\n\nAuthor: J\u00falio Hoffimann Mendes (juliohm@stanford.edu)\n\n\nsource\n\n\n#\n\n\nLightGraphs.periphery\n \n \nMethod\n.\n\n\nReturns the set of all vertices whose eccentricity is equal to the graph's diameter (that is, the set of vertices with the largest eccentricity).\n\n\nsource\n\n\n#\n\n\nLightGraphs.radius\n \n \nMethod\n.\n\n\nReturns the minimum eccentricity of the graph.\n\n\nsource", 
            "title": "Distance"
        }, 
        {
            "location": "/distance/#distance", 
            "text": "LightGraphs.jl  includes the following distance measurements:  #  LightGraphs.BoundedMinkowskiCost     Method .  Similar to MinkowskiCost, but ensures costs smaller than 2\u03c4.  source  #  LightGraphs.MinkowskiCost     Method .  For labels \u03bc\u2081 on the vertices of graph G\u2081 and labels \u03bc\u2082 on the vertices of graph G\u2082, compute the p-norm cost of substituting vertex u \u2208 G\u2081 by vertex v \u2208 G\u2082.  source  #  LightGraphs.center     Method .  Returns the set of all vertices whose eccentricity is equal to the graph's radius (that is, the set of vertices with the smallest eccentricity).  source  #  LightGraphs.diameter     Method .  Returns the maximum eccentricity of the graph.  source  #  LightGraphs.eccentricity     Function .  Calculates the eccentricity[ies] of a vertex  v , vertex vector  vs , or the entire graph. An optional matrix of edge distances may be supplied.  The eccentricity of a vertex is the maximum shortest-path distance between it and all other vertices in the graph.  Because this function must calculate shortest paths for all vertices supplied in the argument list, it may take a long time.  The output is either a single float (when a single vertex is provided) or a vector of floats corresponding to the vertex vector. If no vertex vector is provided, the vector returned corresponds to each vertex in the graph.  Note: the eccentricity vector returned by  eccentricity()  may be used as input for the rest of the distance measures below. If an eccentricity vector is provided, it will be used. Otherwise, an eccentricity vector will be calculated for each call to the function. It may therefore be more efficient to calculate, store, and pass the eccentricities if multiple distance measures are desired.  source  #  LightGraphs.edit_distance     Method .  Computes the edit distance between graphs G\u2081 and G\u2082.  Returns the minimum edit cost and edit path to transform graph G\u2081 into graph G\u2082. An edit path consists of a sequence of pairs of vertices (u,v) \u2208 [0,|G\u2081|] \u00d7 [0,|G\u2082|] representing vertex operations:   (0,v): insertion of vertex v \u2208 G\u2082  (u,0): deletion of vertex u \u2208 G\u2081  (u 0,v 0): substitution of vertex u \u2208 G\u2081 by vertex v \u2208 G\u2082   By default, the algorithm uses constant operation costs. The user can provide classical Minkowski costs computed from vertex labels \u03bc\u2081 (for G\u2081) and \u03bc\u2082 (for G\u2082) in order to further guide the search, for example:  edit_distance(G\u2081, G\u2082, subst_cost=MinkowskiCost(\u03bc\u2081, \u03bc\u2082))  A custom heuristic can be provided to the A* search in case the default heuristic is not satisfactory.  Performance tips:   Given two graphs |G\u2081|   |G\u2082|,  edit_distance(G\u2081, G\u2082)  is faster to   compute than  edit_distance(G\u2082, G\u2081) . Consider swapping the arguments if involved costs are ``symmetric''.   The use of simple Minkowski costs can improve performance considerably.  Exploit vertex attributes when designing operation costs.   For further details, please refer to:  RIESEN, K., 2015. Structural Pattern Recognition with Graph Edit Distance: Approximation Algorithms and Applications. (Chapter 2)  Author: J\u00falio Hoffimann Mendes (juliohm@stanford.edu)  source  #  LightGraphs.periphery     Method .  Returns the set of all vertices whose eccentricity is equal to the graph's diameter (that is, the set of vertices with the largest eccentricity).  source  #  LightGraphs.radius     Method .  Returns the minimum eccentricity of the graph.  source", 
            "title": "Distance"
        }, 
        {
            "location": "/centrality/", 
            "text": "Centrality Measures\n\n\nCentrality measures\n describe the importance of a vertex to the rest of the graph using some set of criteria. Centrality measures implemented in \nLightGraphs.jl\n include the following:\n\n\n\n\nLightGraphs.betweenness_centrality\n\n\nLightGraphs.closeness_centrality\n\n\nLightGraphs.degree_centrality\n\n\nLightGraphs.indegree_centrality\n\n\nLightGraphs.katz_centrality\n\n\nLightGraphs.outdegree_centrality\n\n\nLightGraphs.pagerank\n\n\n\n\n#\n\n\nLightGraphs.betweenness_centrality\n \n \nFunction\n.\n\n\nbetweenness_centrality(g, k=0; normalize=true, endpoints=false)\n\n\n\n\nCalculates the \nbetweenness centrality\n of the graph \ng\n, or, optionally, of a random subset of \nk\n vertices. Can optionally include endpoints in the calculations. Normalization is enabled by default.\n\n\nBetweenness centrality is defined as:\n\n\n$$\nbc(v) = \\frac{1}{\\mathcal{N}} \\sum_{s \\neq t \\neq v}\n        \\frac{\\sigma_{st}(v)}{\\sigma_{st}}\n$$\n\n\n.\n\n\nParameters\n\n\ng: SimpleGraph     A Graph, directed or undirected.\n\n\nk: Integer, optional     Use \nk\n nodes sample to estimate the betweenness centrality. If none,     betweenness centrality is computed using the \nn\n nodes in the graph.\n\n\nnormalize: bool, optional     If true, the betweenness values are normalized by the total number     of possible distinct paths between all pairs in the graphs. For an undirected graph,     this number if \n((n-1)*(n-2))/2\n and for a directed graph, \n(n-1)*(n-2)\n     where \nn\n is the number of nodes in the graph.\n\n\nendpoints: bool, optional     If true, endpoints are included in the shortest path count.\n\n\nReturns\n\n\nbetweenness: Array{Float64}     Betweenness centrality value per node id.\n\n\nReferences\n\n\n[1] Brandes 2001 \n Brandes 2008\n\n\nsource\n\n\n#\n\n\nLightGraphs.closeness_centrality\n \n \nMethod\n.\n\n\nCalculates the \ncloseness centrality\n of the graph \ng\n.\n\n\nsource\n\n\n#\n\n\nLightGraphs.degree_centrality\n \n \nMethod\n.\n\n\nCalculates the \ndegree centrality\n of the graph \ng\n, with optional (default) normalization.\n\n\nsource\n\n\n#\n\n\nLightGraphs.indegree_centrality\n \n \nMethod\n.\n\n\nCalculates the \ndegree centrality\n of the graph \ng\n, with optional (default) normalization.\n\n\nsource\n\n\n#\n\n\nLightGraphs.outdegree_centrality\n \n \nMethod\n.\n\n\nCalculates the \ndegree centrality\n of the graph \ng\n, with optional (default) normalization.\n\n\nsource\n\n\n#\n\n\nLightGraphs.katz_centrality\n \n \nFunction\n.\n\n\nCalculates the \nKatz centrality\n of the graph \ng\n.\n\n\nsource\n\n\n#\n\n\nLightGraphs.pagerank\n \n \nFunction\n.\n\n\nCalculates the \nPageRank\n of the graph \ng\n. Can optionally specify a different damping factor (\n\u03b1\n), number of iterations (\nn\n), and convergence threshold (\n\u03f5\n). If convergence is not reached within \nn\n iterations, an error will be returned.\n\n\nsource", 
            "title": "Centrality Measures"
        }, 
        {
            "location": "/centrality/#centrality-measures", 
            "text": "Centrality measures  describe the importance of a vertex to the rest of the graph using some set of criteria. Centrality measures implemented in  LightGraphs.jl  include the following:   LightGraphs.betweenness_centrality  LightGraphs.closeness_centrality  LightGraphs.degree_centrality  LightGraphs.indegree_centrality  LightGraphs.katz_centrality  LightGraphs.outdegree_centrality  LightGraphs.pagerank   #  LightGraphs.betweenness_centrality     Function .  betweenness_centrality(g, k=0; normalize=true, endpoints=false)  Calculates the  betweenness centrality  of the graph  g , or, optionally, of a random subset of  k  vertices. Can optionally include endpoints in the calculations. Normalization is enabled by default.  Betweenness centrality is defined as:  $$\nbc(v) = \\frac{1}{\\mathcal{N}} \\sum_{s \\neq t \\neq v}\n        \\frac{\\sigma_{st}(v)}{\\sigma_{st}}\n$$  .  Parameters  g: SimpleGraph     A Graph, directed or undirected.  k: Integer, optional     Use  k  nodes sample to estimate the betweenness centrality. If none,     betweenness centrality is computed using the  n  nodes in the graph.  normalize: bool, optional     If true, the betweenness values are normalized by the total number     of possible distinct paths between all pairs in the graphs. For an undirected graph,     this number if  ((n-1)*(n-2))/2  and for a directed graph,  (n-1)*(n-2)      where  n  is the number of nodes in the graph.  endpoints: bool, optional     If true, endpoints are included in the shortest path count.  Returns  betweenness: Array{Float64}     Betweenness centrality value per node id.  References  [1] Brandes 2001   Brandes 2008  source  #  LightGraphs.closeness_centrality     Method .  Calculates the  closeness centrality  of the graph  g .  source  #  LightGraphs.degree_centrality     Method .  Calculates the  degree centrality  of the graph  g , with optional (default) normalization.  source  #  LightGraphs.indegree_centrality     Method .  Calculates the  degree centrality  of the graph  g , with optional (default) normalization.  source  #  LightGraphs.outdegree_centrality     Method .  Calculates the  degree centrality  of the graph  g , with optional (default) normalization.  source  #  LightGraphs.katz_centrality     Function .  Calculates the  Katz centrality  of the graph  g .  source  #  LightGraphs.pagerank     Function .  Calculates the  PageRank  of the graph  g . Can optionally specify a different damping factor ( \u03b1 ), number of iterations ( n ), and convergence threshold ( \u03f5 ). If convergence is not reached within  n  iterations, an error will be returned.  source", 
            "title": "Centrality Measures"
        }, 
        {
            "location": "/linalg/", 
            "text": "Linear Algebra\n\n\nLightGraphs.jl\n provides the following matrix operations on both directed and undirected graphs:\n\n\n#\n\n\nLightGraphs.adjacency_matrix\n \n \nFunction\n.\n\n\nReturns a sparse boolean adjacency matrix for a graph, indexed by \n[u, v]\n vertices. \ntrue\n values indicate an edge between \nu\n and \nv\n. Users may specify a direction (\n:in\n, \n:out\n, or \n:both\n are currently supported; \n:out\n is default for both directed and undirected graphs) and a data type for the matrix (defaults to \nInt\n).\n\n\nNote: This function is optimized for speed.\n\n\nsource\n\n\n#\n\n\nLightGraphs.adjacency_spectrum\n \n \nFunction\n.\n\n\nReturns the eigenvalues of the adjacency matrix for a graph \ng\n, indexed by vertex. Warning: Converts the matrix to dense with $nv^2$ memory usage. Use \neigs(adjacency_matrix(g);kwargs...)\n to compute some of the eigenvalues/eigenvectors. Default values for \ndir\n and \nT\n are the same as \nadjacency_matrix\n.\n\n\nsource\n\n\n#\n\n\nLightGraphs.incidence_matrix\n \n \nFunction\n.\n\n\nReturns a sparse node-arc incidence matrix for a graph, indexed by \n[v, i]\n, where \ni\n is in \n1:ne(g)\n, indexing an edge \ne\n. For directed graphs, a value of \n-1\n indicates that \nsrc(e) == v\n, while a value of \n1\n indicates that \ndst(e) == v\n. Otherwise, the value is \n0\n. For undirected graphs, if the optional keyword \noriented\n is \nfalse\n,  both entries are \n1\n, otherwise, an arbitrary orientation is chosen.\n\n\nsource\n\n\n#\n\n\nLightGraphs.laplacian_matrix\n \n \nFunction\n.\n\n\nReturns a sparse \nLaplacian matrix\n for a graph \ng\n, indexed by \n[u, v]\n vertices. For undirected graphs, \ndir\n defaults to \n:out\n; for directed graphs, \ndir\n defaults to \n:both\n. \nT\n defaults to \nInt\n for both graph types.\n\n\nsource\n\n\n#\n\n\nLightGraphs.laplacian_spectrum\n \n \nFunction\n.\n\n\nReturns the eigenvalues of the Laplacian matrix for a graph \ng\n, indexed by vertex. Warning: Converts the matrix to dense with $nv^2$ memory usage. Use \neigs(laplacian_matrix(g);  kwargs...)\n to compute some of the eigenvalues/eigenvectors. Default values for \ndir\n and \nT\n are the same as \nlaplacian_matrix\n.\n\n\nsource\n\n\n#\n\n\nLightGraphs.spectral_distance\n \n \nMethod\n.\n\n\nspectral_distance(G\u2081, G\u2082 [, k]) Compute the spectral distance between undirected n-vertex graphs G\u2081 and G\u2082 using the top k \u2264 n greatest eigenvalues. If k is ommitted, uses full spectrum.\n\n\nFor further details, please refer to:\n\n\nJOVANOVIC, I.; STANIC, Z., 2014. Spectral Distances of Graphs Based on their Different Matrix Representations\n\n\nsource", 
            "title": "Linear Algebra"
        }, 
        {
            "location": "/linalg/#linear-algebra", 
            "text": "LightGraphs.jl  provides the following matrix operations on both directed and undirected graphs:  #  LightGraphs.adjacency_matrix     Function .  Returns a sparse boolean adjacency matrix for a graph, indexed by  [u, v]  vertices.  true  values indicate an edge between  u  and  v . Users may specify a direction ( :in ,  :out , or  :both  are currently supported;  :out  is default for both directed and undirected graphs) and a data type for the matrix (defaults to  Int ).  Note: This function is optimized for speed.  source  #  LightGraphs.adjacency_spectrum     Function .  Returns the eigenvalues of the adjacency matrix for a graph  g , indexed by vertex. Warning: Converts the matrix to dense with $nv^2$ memory usage. Use  eigs(adjacency_matrix(g);kwargs...)  to compute some of the eigenvalues/eigenvectors. Default values for  dir  and  T  are the same as  adjacency_matrix .  source  #  LightGraphs.incidence_matrix     Function .  Returns a sparse node-arc incidence matrix for a graph, indexed by  [v, i] , where  i  is in  1:ne(g) , indexing an edge  e . For directed graphs, a value of  -1  indicates that  src(e) == v , while a value of  1  indicates that  dst(e) == v . Otherwise, the value is  0 . For undirected graphs, if the optional keyword  oriented  is  false ,  both entries are  1 , otherwise, an arbitrary orientation is chosen.  source  #  LightGraphs.laplacian_matrix     Function .  Returns a sparse  Laplacian matrix  for a graph  g , indexed by  [u, v]  vertices. For undirected graphs,  dir  defaults to  :out ; for directed graphs,  dir  defaults to  :both .  T  defaults to  Int  for both graph types.  source  #  LightGraphs.laplacian_spectrum     Function .  Returns the eigenvalues of the Laplacian matrix for a graph  g , indexed by vertex. Warning: Converts the matrix to dense with $nv^2$ memory usage. Use  eigs(laplacian_matrix(g);  kwargs...)  to compute some of the eigenvalues/eigenvectors. Default values for  dir  and  T  are the same as  laplacian_matrix .  source  #  LightGraphs.spectral_distance     Method .  spectral_distance(G\u2081, G\u2082 [, k]) Compute the spectral distance between undirected n-vertex graphs G\u2081 and G\u2082 using the top k \u2264 n greatest eigenvalues. If k is ommitted, uses full spectrum.  For further details, please refer to:  JOVANOVIC, I.; STANIC, Z., 2014. Spectral Distances of Graphs Based on their Different Matrix Representations  source", 
            "title": "Linear Algebra"
        }, 
        {
            "location": "/matching/", 
            "text": "Matching\n\n\nMaximum weight matching  is supperted in the companion package \nLightGraphsExtras.jl", 
            "title": "Matching"
        }, 
        {
            "location": "/matching/#matching", 
            "text": "Maximum weight matching  is supperted in the companion package  LightGraphsExtras.jl", 
            "title": "Matching"
        }, 
        {
            "location": "/community/", 
            "text": "Community Structures\n\n\nLightGraphs.jl\n contains many algorithm to detect and analyze community structures in graphs.\n\n\n#\n\n\nLightGraphs.global_clustering_coefficient\n \n \nMethod\n.\n\n\nglobal_clustering_coefficient(g)\n\n\n\n\nComputes the \nglobal clustering coefficient\n.\n\n\nsource\n\n\n#\n\n\nLightGraphs.local_clustering\n \n \nFunction\n.\n\n\nlocal_clustering(g, vlist = vertices(g))\n\n\n\n\nReturns two vectors, respectively containing  the first and second result of \nlocal_clustering_coefficients(g, v)\n for each \nv\n in \nvlist\n.\n\n\nsource\n\n\n#\n\n\nLightGraphs.local_clustering\n \n \nMethod\n.\n\n\nlocal_clustering(g, v)\n\n\n\n\nReturns a tuple \n(a,b)\n, where \na\n is the number of triangles in the neighborhood of \nv\n and \nb\n is the maximum number of possible triangles. It is related to the local clustering coefficient  by \nr=a/b\n.\n\n\nsource\n\n\n#\n\n\nLightGraphs.local_clustering_coefficient\n \n \nFunction\n.\n\n\nlocal_clustering_coefficient(g, vlist = vertices(g))\n\n\n\n\nReturns a vector containing  the \nlocal clustering coefficients\n for vertices \nvlist\n.\n\n\nsource\n\n\n#\n\n\nLightGraphs.local_clustering_coefficient\n \n \nMethod\n.\n\n\nlocal_clustering_coefficient(g, v)\n\n\n\n\nComputes the \nlocal clustering coefficient\n for node \nv\n.\n\n\nsource\n\n\n#\n\n\nLightGraphs.triangles\n \n \nFunction\n.\n\n\ntriangles(g, vlist = vertices(g))\n\n\n\n\nReturns a vector containing the number of triangles for vertices \nvlist\n.\n\n\nsource\n\n\n#\n\n\nLightGraphs.triangles\n \n \nMethod\n.\n\n\ntriangles(g, v)\n\n\n\n\nReturns the number of triangles in the neighborhood for node \nv\n.\n\n\nsource\n\n\n#\n\n\nLightGraphs.core_periphery_deg\n \n \nMethod\n.\n\n\ncore_periphery_deg(g)\n\n\n\n\nA simple degree-based core-periphery detection algorithm (see \nLip\n). Returns the vertex assignments (1 for core and 2 for periphery).\n\n\nsource\n\n\n#\n\n\nLightGraphs.label_propagation\n \n \nMethod\n.\n\n\nCommunity detection using the label propagation algorithm (see \nRaghavan et al.\n). \ng\n: input Graph \nmaxiter\n: maximum number of iterations return : vertex assignments and the convergence history\n\n\nsource\n\n\n#\n\n\nLightGraphs.modularity\n \n \nMethod\n.\n\n\nmodularity(g, c)\n\n\n\n\nComputes Newman's modularity \nQ\n for graph \ng\n given the partitioning \nc\n.\n\n\nsource\n\n\n#\n\n\nLightGraphs.maximal_cliques\n \n \nMethod\n.\n\n\nFinds all maximal cliques of an undirected graph.\n\n\njulia\n using LightGraphs\njulia\n g = Graph(3)\njulia\n add_edge!(g, 1, 2)\njulia\n add_edge!(g, 2, 3)\njulia\n maximal_cliques(g)\n2-element Array{Array{Int64,N},1}:\n [2,3]\n [2,1]\n\n\n\n\nsource", 
            "title": "Community Structures"
        }, 
        {
            "location": "/community/#community-structures", 
            "text": "LightGraphs.jl  contains many algorithm to detect and analyze community structures in graphs.  #  LightGraphs.global_clustering_coefficient     Method .  global_clustering_coefficient(g)  Computes the  global clustering coefficient .  source  #  LightGraphs.local_clustering     Function .  local_clustering(g, vlist = vertices(g))  Returns two vectors, respectively containing  the first and second result of  local_clustering_coefficients(g, v)  for each  v  in  vlist .  source  #  LightGraphs.local_clustering     Method .  local_clustering(g, v)  Returns a tuple  (a,b) , where  a  is the number of triangles in the neighborhood of  v  and  b  is the maximum number of possible triangles. It is related to the local clustering coefficient  by  r=a/b .  source  #  LightGraphs.local_clustering_coefficient     Function .  local_clustering_coefficient(g, vlist = vertices(g))  Returns a vector containing  the  local clustering coefficients  for vertices  vlist .  source  #  LightGraphs.local_clustering_coefficient     Method .  local_clustering_coefficient(g, v)  Computes the  local clustering coefficient  for node  v .  source  #  LightGraphs.triangles     Function .  triangles(g, vlist = vertices(g))  Returns a vector containing the number of triangles for vertices  vlist .  source  #  LightGraphs.triangles     Method .  triangles(g, v)  Returns the number of triangles in the neighborhood for node  v .  source  #  LightGraphs.core_periphery_deg     Method .  core_periphery_deg(g)  A simple degree-based core-periphery detection algorithm (see  Lip ). Returns the vertex assignments (1 for core and 2 for periphery).  source  #  LightGraphs.label_propagation     Method .  Community detection using the label propagation algorithm (see  Raghavan et al. ).  g : input Graph  maxiter : maximum number of iterations return : vertex assignments and the convergence history  source  #  LightGraphs.modularity     Method .  modularity(g, c)  Computes Newman's modularity  Q  for graph  g  given the partitioning  c .  source  #  LightGraphs.maximal_cliques     Method .  Finds all maximal cliques of an undirected graph.  julia  using LightGraphs\njulia  g = Graph(3)\njulia  add_edge!(g, 1, 2)\njulia  add_edge!(g, 2, 3)\njulia  maximal_cliques(g)\n2-element Array{Array{Int64,N},1}:\n [2,3]\n [2,1]  source", 
            "title": "Community Structures"
        }, 
        {
            "location": "/flowcut/", 
            "text": "Flow and Cut\n\n\nLightGraphs.jl\n provides different algorithms for \nmaximum flow\n and minimum cut computations.\n\n\n#\n\n\nLightGraphs.BoykovKolmogorovAlgorithm\n \n \nType\n.\n\n\nForces the maximum_flow function to use the Boykov-Kolmogorov algorithm.\n\n\nsource\n\n\n#\n\n\nLightGraphs.DinicAlgorithm\n \n \nType\n.\n\n\nForces the maximum_flow function to use Dinic's algorithm.\n\n\nsource\n\n\n#\n\n\nLightGraphs.EdmondsKarpAlgorithm\n \n \nType\n.\n\n\nForces the maximum_flow function to use the Edmonds\u2013Karp algorithm.\n\n\nsource\n\n\n#\n\n\nLightGraphs.PushRelabelAlgorithm\n \n \nType\n.\n\n\nForces the maximum_flow function to use the Push-Relabel algorithm.\n\n\nsource\n\n\n#\n\n\nLightGraphs.maximum_flow\n \n \nFunction\n.\n\n\nGeneric maximum_flow function. Requires arguments:\n\n\n\n\nflow_graph::DiGraph                   # the input graph\n\n\nsource::Int                           # the source vertex\n\n\ntarget::Int                           # the target vertex\n\n\ncapacity_matrix::AbstractArray{T,2}   # edge flow capacities\n\n\nalgorithm::AbstractFlowAlgorithm      # keyword argument for algorithm\n\n\nrestriction::T                        # keyword argument for a restriction\n\n\n\n\nThe function defaults to the Push-relabel algorithm. Alternatively, the algorithm to be used can also be specified through a keyword argument. A default capacity of 1 is assumed for each link if no capacity matrix is provided. If the restriction is bigger than 0, it is applied to capacity_matrix.\n\n\nAll algorithms return a tuple with 1) the maximum flow and 2) the flow matrix. For the Boykov-Kolmogorov algorithm, the associated mincut is returned as a third output.\n\n\nUsage Example:\n\n\n\n# Create a flow-graph and a capacity matrix\nflow_graph = DiGraph(8)\nflow_edges = [\n    (1,2,10),(1,3,5),(1,4,15),(2,3,4),(2,5,9),\n    (2,6,15),(3,4,4),(3,6,8),(4,7,16),(5,6,15),\n    (5,8,10),(6,7,15),(6,8,10),(7,3,6),(7,8,10)\n]\ncapacity_matrix = zeros(Int, 8, 8)\nfor e in flow_edges\n    u, v, f = e\n    add_edge!(flow_graph, u, v)\n    capacity_matrix[u,v] = f\nend\n\n# Run default maximum_flow without the capacity_matrix\nf, F = maximum_flow(flow_graph, 1, 8)\n\n# Run default maximum_flow with the capacity_matrix\nf, F = maximum_flow(flow_graph, 1, 8)\n\n# Run Endmonds-Karp algorithm\nf, F = maximum_flow(flow_graph,1,8,capacity_matrix,algorithm=EdmondsKarpAlgorithm())\n\n# Run Dinic's algorithm\nf, F = maximum_flow(flow_graph,1,8,capacity_matrix,algorithm=DinicAlgorithm())\n\n# Run Boykov-Kolmogorov algorithm\nf, F, labels = maximum_flow(flow_graph,1,8,capacity_matrix,algorithm=BoykovKolmogorovAlgorithm())\n\n\n\n\n\nsource\n\n\n#\n\n\nLightGraphs.ExtendedMultirouteFlowAlgorithm\n \n \nType\n.\n\n\nForces the multiroute_flow function to use the Extended Multiroute Flow algorithm.\n\n\nsource\n\n\n#\n\n\nLightGraphs.KishimotoAlgorithm\n \n \nType\n.\n\n\nForces the multiroute_flow function to use the Kishimoto algorithm.\n\n\nsource\n\n\n#\n\n\nLightGraphs.multiroute_flow\n \n \nFunction\n.\n\n\nThe generic multiroute_flow function will output three kinds of results:\n\n\n\n\nWhen the number of routes is 0 or non-specified, the set of breaking points of\n\n\n\n\nthe multiroute flow is returned.\n\n\n\n\nWhen the input is limited to a set of breaking points and a route value k,\n\n\n\n\nonly the value of the k-route flow is returned\n\n\n\n\nOtherwise, a tuple with 1) the maximum flow and 2) the flow matrix. When the\n\n\n\n\nmax-flow subroutine is the Boykov-Kolmogorov algorithm, the associated mincut is returned as a third output.\n\n\nWhen the input is a network, it requires the following arguments:\n\n\n\n\nflow_graph::DiGraph                   # the input graph\n\n\nsource::Int                           # the source vertex\n\n\ntarget::Int                           # the target vertex\n\n\ncapacity_matrix::AbstractArray{T, 2}  # edge flow capacities with T\n:Real\n\n\nflow_algorithm::AbstractFlowAlgorithm # keyword argument for flow algorithm\n\n\nmrf_algorithm::AbstractFlowAlgorithm  # keyword argument for multiroute flow algorithm\n\n\nroutes::R\n:Real                       # keyword argument for the number of routes\n\n\n\n\nWhen the input is only the set of (breaking) points and the number of route, it requires the following arguments:\n\n\n\n\nbreakingpoints::Vector{Tuple{T, T, Int}},    # vector of breaking points\n\n\nroutes::R\n:Real,                             # number of routes\n\n\n\n\nWhen the input is the set of (breaking) points, the number of routes, and the network descriptors, it requires the following arguments:\n\n\n\n\nbreakingpoints::Vector{Tuple{T1, T1, Int}} # vector of breaking points (T1\n:Real)\n\n\nroutes::R\n:Real                            # number of routes\n\n\nflow_graph::DiGraph                        # the input graph\n\n\nsource::Int                                # the source vertex\n\n\ntarget::Int                                # the target vertex\n\n\ncapacity_matrix::AbstractArray{T2, 2}      # optional edge flow capacities (T2\n:Real)\n\n\nflow_algorithm::AbstractFlowAlgorithm      # keyword argument for algorithm\n\n\n\n\nThe function defaults to the Push-relabel (classical flow) and Kishimoto (multiroute) algorithms. Alternatively, the algorithms to be used can also be specified through  keyword arguments. A default capacity of 1 is assumed for each link if no capacity matrix is provided.\n\n\nThe mrf_algorithm keyword is inforced to Extended Multiroute Flow in the following cases:\n\n\n\n\nThe number of routes is non-integer\n\n\nThe number of routes is 0 or non-specified\n\n\n\n\nUsage Example :\n\n\n(please consult the  max_flow section for options about flow_algorithm and capacity_matrix)\n\n\n\n# Create a flow-graph and a capacity matrix\nflow_graph = DiGraph(8)\nflow_edges = [\n    (1, 2, 10), (1, 3, 5),  (1, 4, 15), (2, 3, 4),  (2, 5, 9),\n    (2, 6, 15), (3, 4, 4),  (3, 6, 8),  (4, 7, 16), (5, 6, 15),\n    (5, 8, 10), (6, 7, 15), (6, 8, 10), (7, 3, 6),  (7, 8, 10)\n]\ncapacity_matrix = zeros(Int, 8, 8)\nfor e in flow_edges\n    u, v, f = e\n    add_edge!(flow_graph, u, v)\n    capacity_matrix[u, v] = f\nend\n\n# Run default multiroute_flow with an integer number of routes = 2\nf, F = multiroute_flow(flow_graph, 1, 8, capacity_matrix, routes = 2)\n\n# Run default multiroute_flow with a noninteger number of routes = 1.5\nf, F = multiroute_flow(flow_graph, 1, 8, capacity_matrix, routes = 1.5)\n\n# Run default multiroute_flow for all the breaking points values\npoints = multiroute_flow(flow_graph, 1, 8, capacity_matrix)\n# Then run multiroute flow algorithm for any positive number of routes\nf, F = multiroute_flow(points, 1.5)\nf = multiroute_flow(points, 1.5, valueonly = true)\n\n# Run multiroute flow algorithm using Boykov-Kolmogorov algorithm as max_flow routine\nf, F, labels = multiroute_flow(flow_graph, 1, 8, capacity_matrix,\n               algorithm = BoykovKolmogorovAlgorithm(), routes = 2)\n\n\n\n\n\nsource", 
            "title": "Flow and Cut"
        }, 
        {
            "location": "/flowcut/#flow-and-cut", 
            "text": "LightGraphs.jl  provides different algorithms for  maximum flow  and minimum cut computations.  #  LightGraphs.BoykovKolmogorovAlgorithm     Type .  Forces the maximum_flow function to use the Boykov-Kolmogorov algorithm.  source  #  LightGraphs.DinicAlgorithm     Type .  Forces the maximum_flow function to use Dinic's algorithm.  source  #  LightGraphs.EdmondsKarpAlgorithm     Type .  Forces the maximum_flow function to use the Edmonds\u2013Karp algorithm.  source  #  LightGraphs.PushRelabelAlgorithm     Type .  Forces the maximum_flow function to use the Push-Relabel algorithm.  source  #  LightGraphs.maximum_flow     Function .  Generic maximum_flow function. Requires arguments:   flow_graph::DiGraph                   # the input graph  source::Int                           # the source vertex  target::Int                           # the target vertex  capacity_matrix::AbstractArray{T,2}   # edge flow capacities  algorithm::AbstractFlowAlgorithm      # keyword argument for algorithm  restriction::T                        # keyword argument for a restriction   The function defaults to the Push-relabel algorithm. Alternatively, the algorithm to be used can also be specified through a keyword argument. A default capacity of 1 is assumed for each link if no capacity matrix is provided. If the restriction is bigger than 0, it is applied to capacity_matrix.  All algorithms return a tuple with 1) the maximum flow and 2) the flow matrix. For the Boykov-Kolmogorov algorithm, the associated mincut is returned as a third output.  Usage Example:  \n# Create a flow-graph and a capacity matrix\nflow_graph = DiGraph(8)\nflow_edges = [\n    (1,2,10),(1,3,5),(1,4,15),(2,3,4),(2,5,9),\n    (2,6,15),(3,4,4),(3,6,8),(4,7,16),(5,6,15),\n    (5,8,10),(6,7,15),(6,8,10),(7,3,6),(7,8,10)\n]\ncapacity_matrix = zeros(Int, 8, 8)\nfor e in flow_edges\n    u, v, f = e\n    add_edge!(flow_graph, u, v)\n    capacity_matrix[u,v] = f\nend\n\n# Run default maximum_flow without the capacity_matrix\nf, F = maximum_flow(flow_graph, 1, 8)\n\n# Run default maximum_flow with the capacity_matrix\nf, F = maximum_flow(flow_graph, 1, 8)\n\n# Run Endmonds-Karp algorithm\nf, F = maximum_flow(flow_graph,1,8,capacity_matrix,algorithm=EdmondsKarpAlgorithm())\n\n# Run Dinic's algorithm\nf, F = maximum_flow(flow_graph,1,8,capacity_matrix,algorithm=DinicAlgorithm())\n\n# Run Boykov-Kolmogorov algorithm\nf, F, labels = maximum_flow(flow_graph,1,8,capacity_matrix,algorithm=BoykovKolmogorovAlgorithm())  source  #  LightGraphs.ExtendedMultirouteFlowAlgorithm     Type .  Forces the multiroute_flow function to use the Extended Multiroute Flow algorithm.  source  #  LightGraphs.KishimotoAlgorithm     Type .  Forces the multiroute_flow function to use the Kishimoto algorithm.  source  #  LightGraphs.multiroute_flow     Function .  The generic multiroute_flow function will output three kinds of results:   When the number of routes is 0 or non-specified, the set of breaking points of   the multiroute flow is returned.   When the input is limited to a set of breaking points and a route value k,   only the value of the k-route flow is returned   Otherwise, a tuple with 1) the maximum flow and 2) the flow matrix. When the   max-flow subroutine is the Boykov-Kolmogorov algorithm, the associated mincut is returned as a third output.  When the input is a network, it requires the following arguments:   flow_graph::DiGraph                   # the input graph  source::Int                           # the source vertex  target::Int                           # the target vertex  capacity_matrix::AbstractArray{T, 2}  # edge flow capacities with T :Real  flow_algorithm::AbstractFlowAlgorithm # keyword argument for flow algorithm  mrf_algorithm::AbstractFlowAlgorithm  # keyword argument for multiroute flow algorithm  routes::R :Real                       # keyword argument for the number of routes   When the input is only the set of (breaking) points and the number of route, it requires the following arguments:   breakingpoints::Vector{Tuple{T, T, Int}},    # vector of breaking points  routes::R :Real,                             # number of routes   When the input is the set of (breaking) points, the number of routes, and the network descriptors, it requires the following arguments:   breakingpoints::Vector{Tuple{T1, T1, Int}} # vector of breaking points (T1 :Real)  routes::R :Real                            # number of routes  flow_graph::DiGraph                        # the input graph  source::Int                                # the source vertex  target::Int                                # the target vertex  capacity_matrix::AbstractArray{T2, 2}      # optional edge flow capacities (T2 :Real)  flow_algorithm::AbstractFlowAlgorithm      # keyword argument for algorithm   The function defaults to the Push-relabel (classical flow) and Kishimoto (multiroute) algorithms. Alternatively, the algorithms to be used can also be specified through  keyword arguments. A default capacity of 1 is assumed for each link if no capacity matrix is provided.  The mrf_algorithm keyword is inforced to Extended Multiroute Flow in the following cases:   The number of routes is non-integer  The number of routes is 0 or non-specified   Usage Example :  (please consult the  max_flow section for options about flow_algorithm and capacity_matrix)  \n# Create a flow-graph and a capacity matrix\nflow_graph = DiGraph(8)\nflow_edges = [\n    (1, 2, 10), (1, 3, 5),  (1, 4, 15), (2, 3, 4),  (2, 5, 9),\n    (2, 6, 15), (3, 4, 4),  (3, 6, 8),  (4, 7, 16), (5, 6, 15),\n    (5, 8, 10), (6, 7, 15), (6, 8, 10), (7, 3, 6),  (7, 8, 10)\n]\ncapacity_matrix = zeros(Int, 8, 8)\nfor e in flow_edges\n    u, v, f = e\n    add_edge!(flow_graph, u, v)\n    capacity_matrix[u, v] = f\nend\n\n# Run default multiroute_flow with an integer number of routes = 2\nf, F = multiroute_flow(flow_graph, 1, 8, capacity_matrix, routes = 2)\n\n# Run default multiroute_flow with a noninteger number of routes = 1.5\nf, F = multiroute_flow(flow_graph, 1, 8, capacity_matrix, routes = 1.5)\n\n# Run default multiroute_flow for all the breaking points values\npoints = multiroute_flow(flow_graph, 1, 8, capacity_matrix)\n# Then run multiroute flow algorithm for any positive number of routes\nf, F = multiroute_flow(points, 1.5)\nf = multiroute_flow(points, 1.5, valueonly = true)\n\n# Run multiroute flow algorithm using Boykov-Kolmogorov algorithm as max_flow routine\nf, F, labels = multiroute_flow(flow_graph, 1, 8, capacity_matrix,\n               algorithm = BoykovKolmogorovAlgorithm(), routes = 2)  source", 
            "title": "Flow and Cut"
        }, 
        {
            "location": "/generators/", 
            "text": "Generators\n\n\n\n\nRandom Graphs\n\n\nLightGraphs.jl\n implements some common random graph generators:\n\n\n#\n\n\nLightGraphs.StochasticBlockModel\n \n \nType\n.\n\n\ntype StochasticBlockModel{T\n:Integer,P\n:Real}\n    n::T\n    nodemap::Array{T}\n    affinities::Matrix{P}\n    rng::MersenneTwister\nend\n\n\n\n\nA type capturing the parameters of the SBM. Each vertex is assigned to a block and the probability of edge \n(i,j)\n depends only on the block labels of vertex \ni\n and vertex \nj\n.\n\n\nThe assignement is stored in nodemap and the block affinities a \nk\n by \nk\n matrix is stored in affinities.\n\n\naffinities[k,l]\n is the probability of an edge between any vertex in block k and any vertex in block \nl\n.\n\n\nWe are generating the graphs by taking random \ni,j in vertices(g)\n and flipping a coin with probability \naffinities[nodemap[i],nodemap[j]]\n.\n\n\nsource\n\n\n#\n\n\nLightGraphs.StochasticBlockModel\n \n \nMethod\n.\n\n\nA constructor for StochasticBlockModel that uses the sizes of the blocks and the affinity matrix. This construction implies that consecutive vertices will be in the same blocks, except for the block boundaries.\n\n\nsource\n\n\n#\n\n\nLightGraphs.barabasi_albert!\n \n \nMethod\n.\n\n\nbarabasi_albert!(g::SimpleGraph, n::Integer, k::Integer; seed::Int = -1)\n\n\n\n\nCreates a \nBarab\u00e1si\u2013Albert model\n random graph with \nn\n vertices. It is grown by adding new vertices to an initial graph \ng\n. Each new vertex is attached with \nk\n edges to \nk\n different vertices already present in the system by preferential attachment.\n\n\nsource\n\n\n#\n\n\nLightGraphs.barabasi_albert\n \n \nMethod\n.\n\n\nbarabasi_albert(n::Integer, n0::Integer, k::Integer; is_directed::Bool = false, complete::Bool = false, seed::Int = -1)\n\n\n\n\nCreates a \nBarab\u00e1si\u2013Albert model\n random graph with \nn\n vertices. It is grown by adding new vertices to an initial graph with \nn0\n vertices. Each new vertex is attached with \nk\n edges to \nk\n different vertices already present in the system by preferential attachment. Initial graphs are undirected and consist of isolated vertices by default; use \nis_directed=true\n and \ncomplete=true\n for directed and complete initial graphs.\n\n\nsource\n\n\n#\n\n\nLightGraphs.barabasi_albert\n \n \nMethod\n.\n\n\nbarabasi_albert(n::Integer, k::Integer; is_directed::Bool = false, complete::Bool = false, seed::Int = -1)\n\n\n\n\nCreates a \nBarab\u00e1si\u2013Albert model\n random graph with \nn\n vertices. It is grown by adding new vertices to an initial graph with \nk\n vertices. Each new vertex is attached with \nk\n edges to \nk\n different vertices already present in the system by preferential attachment. Initial graphs are undirected and consist of isolated vertices by default; use \nis_directed=true\n and \ncomplete=true\n for directed and complete initial graphs.\n\n\nsource\n\n\n#\n\n\nLightGraphs.blockcounts\n \n \nMethod\n.\n\n\ncounts the number of edges that go between each block\n\n\nsource\n\n\n#\n\n\nLightGraphs.erdos_renyi\n \n \nMethod\n.\n\n\nerdos_renyi(n::Integer, p::Real; is_directed=false, seed=-1)\nerdos_renyi(n::Integer, ne::Integer; is_directed=false, seed=-1)\n\n\n\n\nCreates an \nErd\u0151s\u2013R\u00e9nyi\n random graph with \nn\n vertices. Edges are added between pairs of vertices with probability \np\n. Undirected graphs are created by default; use \nis_directed=true\n to override.\n\n\nNote also that Erd\u0151s\u2013R\u00e9nyi graphs may be generated quickly using \nerdos_renyi(n, ne)\n or the  \nGraph(nv, ne)\n constructor, which randomly select \nne\n edges among all the potential edges.\n\n\nsource\n\n\n#\n\n\nLightGraphs.make_edgestream\n \n \nMethod\n.\n\n\nmake_edgestream(sbm::StochasticBlockModel)\n\n\n\n\nTake an infinite sample from the sbm. Pass to \nGraph(nvg, neg, edgestream)\n to get a Graph object.\n\n\nsource\n\n\n#\n\n\nLightGraphs.random_configuration_model\n \n \nMethod\n.\n\n\nrandom_configuration_model(n::Int, k::Array{Int}; seed=-1, check_graphical=false)\n\n\n\n\nCreates a random undirected graph according to the \nconfiguration model\n. It contains \nn\n vertices, the vertex \ni\n having degree \nk[i]\n.\n\n\nDefining \nc = mean(k)\n, it allocates an array of \nnc\n \nInt\ns, and takes approximately $nc^2$ time.\n\n\nIf \ncheck_graphical=true\n makes sure that \nk\n is a graphical sequence (see \nisgraphical\n).\n\n\nsource\n\n\n#\n\n\nLightGraphs.random_regular_digraph\n \n \nMethod\n.\n\n\nrandom_regular_digraph(n::Int, k::Int; dir::Symbol=:out, seed=-1)\n\n\n\n\nCreates a random directed \nregular graph\n with \nn\n vertices, each with degree \nk\n. The degree (in or out) can be specified using \ndir=:in\n or \ndir=:out\n. The default is \ndir=:out\n.\n\n\nFor directed graphs, allocates an $n \\times n$ sparse matrix of boolean as an adjacency matrix and uses that to generate the directed graph.\n\n\nsource\n\n\n#\n\n\nLightGraphs.random_regular_graph\n \n \nMethod\n.\n\n\nrandom_regular_graph(n::Int, k::Int; seed=-1)\n\n\n\n\nCreates a random undirected \nregular graph\n with \nn\n vertices, each with degree \nk\n.\n\n\nFor undirected graphs, allocates an array of \nnk\n \nInt\ns, and takes approximately $nk^2$ time. For $k \n n/2$, generates a graph of degree \nn-k-1\n and returns its complement.\n\n\nsource\n\n\n#\n\n\nLightGraphs.static_fitness_model\n \n \nMethod\n.\n\n\nstatic_fitness_model{T\n:Real}(m::Int, fitness::Vector{T}; seed::Int=-1)\n\n\n\n\nGenerates a random graph with \nlength(fitness)\n nodes and \nm\n edges, in which the probability of the existence of edge \n(i, j)\n is proportional to \nfitness[i]*fitness[j]\n. Time complexity is O(|V| + |E| log |E|).\n\n\nReference:\n\n\n\n\nGoh K-I, Kahng B, Kim D: Universal behaviour of load distribution\n\n\n\n\nin scale-free networks. Phys Rev Lett 87(27):278701, 2001.\n\n\nsource\n\n\n#\n\n\nLightGraphs.static_scale_free\n \n \nMethod\n.\n\n\nfunction static_scale_free(n::Int, m::Int, \u03b1::Float64; seed::Int=-1, finite_size_correction::Bool=true)\n\n\n\n\nGenerates a random graph with \nn\n vertices, \nm\n edges and expected power-law degree distribution with exponent \n\u03b1\n. \nfinite_size_correction\n determines whether to use the finite size correction proposed by Cho et al. This generator calls internally the \nstatic_fitness_model function\n. Time complexity is O(|V| + |E| log |E|).\n\n\nReferences:\n\n\n\n\nGoh K-I, Kahng B, Kim D: Universal behaviour of load distribution in scale-free networks. Phys Rev Lett 87(27):278701, 2001.\n\n\nChung F and Lu L: Connected components in a random graph with given degree sequences. Annals of Combinatorics 6, 125-145, 2002.\n\n\nCho YS, Kim JS, Park J, Kahng B, Kim D: Percolation transitions in scale-free networks under the Achlioptas process. Phys Rev Lett 103:135702, 2009.\n\n\n\n\nsource\n\n\n#\n\n\nLightGraphs.stochastic_block_model\n \n \nMethod\n.\n\n\nstochastic_block_model(c::Matrix{Float64}, n::Vector{Int}; seed::Int = -1)\nstochastic_block_model(cin::Float64, coff::Float64, n::Vector{Int}; seed::Int = -1)\n\n\n\n\nReturns a Graph generated according to the Stochastic Block Model (SBM).\n\n\nc[a,b]\n : Mean number of neighbors of a vertex in block \na\n belonging to block \nb\n.            Only the upper triangular part is considered, since the lower traingular is            determined by $c[b,a] = c[a,b] * n[a]/n[b]$. \nn[a]\n : Number of vertices in block \na\n\n\nThe second form samples from a SBM with \nc[a,a]=cin\n, and \nc[a,b]=coff\n.\n\n\nFor a dynamic version of the SBM see the \nStochasticBlockModel\n type and related functions.\n\n\nsource\n\n\n#\n\n\nLightGraphs.watts_strogatz\n \n \nMethod\n.\n\n\nCreates a \nWatts-Strogatz\n small model random graph with \nn\n vertices, each with degree \nk\n. Edges are randomized per the model based on probability \n\u03b2\n. Undirected graphs are created by default; use \nis_directed=true\n to override.\n\n\nsource\n\n\n\n\nStatic Graphs\n\n\nLightGraphs.jl\n also implements a collection of classic graph generators:\n\n\n#\n\n\nLightGraphs.BinaryTree\n \n \nMethod\n.\n\n\ncreate a binary tree with k-levels vertices are numbered 1:2^levels-1\n\n\nsource\n\n\n#\n\n\nLightGraphs.CliqueGraph\n \n \nMethod\n.\n\n\nThis function generates \nn\n connected k-cliques \n\n\nsource\n\n\n#\n\n\nLightGraphs.CompleteBipartiteGraph\n \n \nMethod\n.\n\n\nCreates a complete bipartite graph with \nn1+n2\n vertices. It has edges connecting each pair of vertices in the two sets.\n\n\nsource\n\n\n#\n\n\nLightGraphs.CompleteDiGraph\n \n \nMethod\n.\n\n\nCreates a complete digraph with \nn\n vertices. A complete digraph has edges connecting each pair of vertices (both an ingoing and outgoing edge).\n\n\nsource\n\n\n#\n\n\nLightGraphs.CompleteGraph\n \n \nMethod\n.\n\n\nCreates a complete graph with \nn\n vertices. A complete graph has edges connecting each pair of vertices.\n\n\nsource\n\n\n#\n\n\nLightGraphs.CycleDiGraph\n \n \nMethod\n.\n\n\nCreates a cycle digraph with \nn\n vertices. A cycle digraph is a closed path digraph.\n\n\nsource\n\n\n#\n\n\nLightGraphs.CycleGraph\n \n \nMethod\n.\n\n\nCreates a cycle graph with \nn\n vertices. A cycle graph is a closed path graph.\n\n\nsource\n\n\n#\n\n\nLightGraphs.DoubleBinaryTree\n \n \nMethod\n.\n\n\ncreate a double complete binary tree with k-levels used as an example for spectral clustering by Guattery and Miller 1998.\n\n\nsource\n\n\n#\n\n\nLightGraphs.Grid\n \n \nMethod\n.\n\n\nGrid{T\n:Integer}(dims::AbstractVector{T}; periodic=false)\n\n\n\n\nCreates a \nd\n-dimensional cubic lattice, with \nd=length(dims)\n and length  \ndims[i]\n in dimension \ni\n. If \nperiodic=true\n the resulting lattice will have periodic boundary condition in each dimension.\n\n\nsource\n\n\n#\n\n\nLightGraphs.PathDiGraph\n \n \nMethod\n.\n\n\nCreates a path digraph with \nn\n vertices. A path graph connects each successive vertex by a single directed edge.\n\n\nsource\n\n\n#\n\n\nLightGraphs.PathGraph\n \n \nMethod\n.\n\n\nCreates a path graph with \nn\n vertices. A path graph connects each successive vertex by a single edge.\n\n\nsource\n\n\n#\n\n\nLightGraphs.RoachGraph\n \n \nMethod\n.\n\n\nThe Roach Graph from Guattery and Miller 1998\n\n\nsource\n\n\n#\n\n\nLightGraphs.StarDiGraph\n \n \nMethod\n.\n\n\nCreates a star digraph with \nn\n vertices. A star digraph has a central vertex with directed edges to every other vertex.\n\n\nsource\n\n\n#\n\n\nLightGraphs.StarGraph\n \n \nMethod\n.\n\n\nCreates a star graph with \nn\n vertices. A star graph has a central vertex with edges to each other vertex.\n\n\nsource\n\n\n#\n\n\nLightGraphs.WheelDiGraph\n \n \nMethod\n.\n\n\nCreates a wheel digraph with \nn\n vertices. A wheel graph is a star digraph with the outer vertices connected via a closed path graph.\n\n\nsource\n\n\n#\n\n\nLightGraphs.WheelGraph\n \n \nMethod\n.\n\n\nCreates a wheel graph with \nn\n vertices. A wheel graph is a star graph with the outer vertices connected via a closed path graph.\n\n\nsource\n\n\n\n\nSmall Graphs\n\n\nOther classical graphs can be generated by the following function:\n\n\n#\n\n\nLightGraphs.smallgraph\n \n \nMethod\n.\n\n\nsmallgraph(s::Symbol)\nsmallgraph(s::AbstractString)\n\n\n\n\nCreates a small graph of type \ns\n. Admissible values for \ns\n are:\n\n\n\n\n\n\n\n\ns\n\n\ngraph type\n\n\n\n\n\n\n\n\n\n\n:bull\n\n\nA \nbull graph\n.\n\n\n\n\n\n\n:chvatal\n\n\nA \nChv\u00e1tal graph\n.\n\n\n\n\n\n\n:cubical\n\n\nA \nPlatonic cubical graph\n.\n\n\n\n\n\n\n:desargues\n\n\nA \nDesarguesgraph\n.\n\n\n\n\n\n\n:diamond\n\n\nA \ndiamond graph\n.\n\n\n\n\n\n\n:dodecahedral\n\n\nA \nPlatonic dodecahedral  graph\n.\n\n\n\n\n\n\n:frucht\n\n\nA \nFrucht graph\n.\n\n\n\n\n\n\n:heawood\n\n\nA \nHeawood graph\n.\n\n\n\n\n\n\n:house\n\n\nA graph mimicing the classic outline of a house.\n\n\n\n\n\n\n:housex\n\n\nA house graph, with two edges crossing the bottom square.\n\n\n\n\n\n\n:icosahedral\n\n\nA \nPlatonic icosahedral   graph\n.\n\n\n\n\n\n\n:krackhardtkite\n\n\nA \nKrackhardt-Kite social network  graph\n.\n\n\n\n\n\n\n:moebiuskantor\n\n\nA \nM\u00f6bius-Kantor graph\n.\n\n\n\n\n\n\n:octahedral\n\n\nA \nPlatonic octahedral graph\n.\n\n\n\n\n\n\n:pappus\n\n\nA \nPappus graph\n.\n\n\n\n\n\n\n:petersen\n\n\nA \nPetersen graph\n.\n\n\n\n\n\n\n:sedgewickmaze\n\n\nA simple maze graph used in Sedgewick's \nAlgorithms in C++: Graph  Algorithms (3rd ed.)\n\n\n\n\n\n\n:tetrahedral\n\n\nA \nPlatonic tetrahedral  graph\n.\n\n\n\n\n\n\n:truncatedcube\n\n\nA skeleton of the \ntruncated cube graph\n.\n\n\n\n\n\n\n:truncatedtetrahedron\n\n\nA skeleton of the \ntruncated tetrahedron  graph\n.\n\n\n\n\n\n\n:truncatedtetrahedron_dir\n\n\nA skeleton of the \ntruncated tetrahedron digraph\n.\n\n\n\n\n\n\n:tutte\n\n\nA \nTutte graph\n.\n\n\n\n\n\n\n\n\nsource\n\n\n\n\nEuclidean Graphs\n\n\nGeneration of random and static graphs embedded in Euclidean space.\n\n\n#\n\n\nLightGraphs.euclidean_graph\n \n \nFunction\n.\n\n\neuclidean_graph(points::Matrix, L=1., p=2., cutoff=-1., bc=:open)\n\n\n\n\nGiven the \nd\u00d7N\n matrix \npoints\n builds an Euclidean graph of \nN\n vertices according to the following procedure.\n\n\nDefining the \nd\n-dimensional vectors \nx[i] = points[:,i]\n, an edge between vertices \ni\n and \nj\n is inserted if \nnorm(x[i]-x[j], p) \n cutoff\n. In case of negative \ncutoff\n instead every edge is inserted. For \np=2\n we have the standard Euclidean distance. Set \nbc=:periodic\n to impose periodic boundary conditions in the box $[0,L]^d$.\n\n\nReturns a graph and Dict containing the distance on each edge.\n\n\neuclidean_graph(N, d; seed = -1, L=1., p=2., cutoff=-1., bc=:open)\n\n\n\n\nGenerates \nN\n uniformly distributed points in the box $[0,L]^d$ and builds and Euclidean graph.\n\n\nReturns a graph, a Dict containing the distance on each edge and a matrix with the points' positions.\n\n\nsource\n\n\n\n\nDatasets\n\n\nOther notorious graphs and integration with the \nMatrixDepot.jl\n package are available in the \nDatasets\n submodule of the companion package \nLightGraphsExtras.jl\n ```", 
            "title": "Graph Generators"
        }, 
        {
            "location": "/generators/#generators", 
            "text": "", 
            "title": "Generators"
        }, 
        {
            "location": "/generators/#random-graphs", 
            "text": "LightGraphs.jl  implements some common random graph generators:  #  LightGraphs.StochasticBlockModel     Type .  type StochasticBlockModel{T :Integer,P :Real}\n    n::T\n    nodemap::Array{T}\n    affinities::Matrix{P}\n    rng::MersenneTwister\nend  A type capturing the parameters of the SBM. Each vertex is assigned to a block and the probability of edge  (i,j)  depends only on the block labels of vertex  i  and vertex  j .  The assignement is stored in nodemap and the block affinities a  k  by  k  matrix is stored in affinities.  affinities[k,l]  is the probability of an edge between any vertex in block k and any vertex in block  l .  We are generating the graphs by taking random  i,j in vertices(g)  and flipping a coin with probability  affinities[nodemap[i],nodemap[j]] .  source  #  LightGraphs.StochasticBlockModel     Method .  A constructor for StochasticBlockModel that uses the sizes of the blocks and the affinity matrix. This construction implies that consecutive vertices will be in the same blocks, except for the block boundaries.  source  #  LightGraphs.barabasi_albert!     Method .  barabasi_albert!(g::SimpleGraph, n::Integer, k::Integer; seed::Int = -1)  Creates a  Barab\u00e1si\u2013Albert model  random graph with  n  vertices. It is grown by adding new vertices to an initial graph  g . Each new vertex is attached with  k  edges to  k  different vertices already present in the system by preferential attachment.  source  #  LightGraphs.barabasi_albert     Method .  barabasi_albert(n::Integer, n0::Integer, k::Integer; is_directed::Bool = false, complete::Bool = false, seed::Int = -1)  Creates a  Barab\u00e1si\u2013Albert model  random graph with  n  vertices. It is grown by adding new vertices to an initial graph with  n0  vertices. Each new vertex is attached with  k  edges to  k  different vertices already present in the system by preferential attachment. Initial graphs are undirected and consist of isolated vertices by default; use  is_directed=true  and  complete=true  for directed and complete initial graphs.  source  #  LightGraphs.barabasi_albert     Method .  barabasi_albert(n::Integer, k::Integer; is_directed::Bool = false, complete::Bool = false, seed::Int = -1)  Creates a  Barab\u00e1si\u2013Albert model  random graph with  n  vertices. It is grown by adding new vertices to an initial graph with  k  vertices. Each new vertex is attached with  k  edges to  k  different vertices already present in the system by preferential attachment. Initial graphs are undirected and consist of isolated vertices by default; use  is_directed=true  and  complete=true  for directed and complete initial graphs.  source  #  LightGraphs.blockcounts     Method .  counts the number of edges that go between each block  source  #  LightGraphs.erdos_renyi     Method .  erdos_renyi(n::Integer, p::Real; is_directed=false, seed=-1)\nerdos_renyi(n::Integer, ne::Integer; is_directed=false, seed=-1)  Creates an  Erd\u0151s\u2013R\u00e9nyi  random graph with  n  vertices. Edges are added between pairs of vertices with probability  p . Undirected graphs are created by default; use  is_directed=true  to override.  Note also that Erd\u0151s\u2013R\u00e9nyi graphs may be generated quickly using  erdos_renyi(n, ne)  or the   Graph(nv, ne)  constructor, which randomly select  ne  edges among all the potential edges.  source  #  LightGraphs.make_edgestream     Method .  make_edgestream(sbm::StochasticBlockModel)  Take an infinite sample from the sbm. Pass to  Graph(nvg, neg, edgestream)  to get a Graph object.  source  #  LightGraphs.random_configuration_model     Method .  random_configuration_model(n::Int, k::Array{Int}; seed=-1, check_graphical=false)  Creates a random undirected graph according to the  configuration model . It contains  n  vertices, the vertex  i  having degree  k[i] .  Defining  c = mean(k) , it allocates an array of  nc   Int s, and takes approximately $nc^2$ time.  If  check_graphical=true  makes sure that  k  is a graphical sequence (see  isgraphical ).  source  #  LightGraphs.random_regular_digraph     Method .  random_regular_digraph(n::Int, k::Int; dir::Symbol=:out, seed=-1)  Creates a random directed  regular graph  with  n  vertices, each with degree  k . The degree (in or out) can be specified using  dir=:in  or  dir=:out . The default is  dir=:out .  For directed graphs, allocates an $n \\times n$ sparse matrix of boolean as an adjacency matrix and uses that to generate the directed graph.  source  #  LightGraphs.random_regular_graph     Method .  random_regular_graph(n::Int, k::Int; seed=-1)  Creates a random undirected  regular graph  with  n  vertices, each with degree  k .  For undirected graphs, allocates an array of  nk   Int s, and takes approximately $nk^2$ time. For $k   n/2$, generates a graph of degree  n-k-1  and returns its complement.  source  #  LightGraphs.static_fitness_model     Method .  static_fitness_model{T :Real}(m::Int, fitness::Vector{T}; seed::Int=-1)  Generates a random graph with  length(fitness)  nodes and  m  edges, in which the probability of the existence of edge  (i, j)  is proportional to  fitness[i]*fitness[j] . Time complexity is O(|V| + |E| log |E|).  Reference:   Goh K-I, Kahng B, Kim D: Universal behaviour of load distribution   in scale-free networks. Phys Rev Lett 87(27):278701, 2001.  source  #  LightGraphs.static_scale_free     Method .  function static_scale_free(n::Int, m::Int, \u03b1::Float64; seed::Int=-1, finite_size_correction::Bool=true)  Generates a random graph with  n  vertices,  m  edges and expected power-law degree distribution with exponent  \u03b1 .  finite_size_correction  determines whether to use the finite size correction proposed by Cho et al. This generator calls internally the  static_fitness_model function . Time complexity is O(|V| + |E| log |E|).  References:   Goh K-I, Kahng B, Kim D: Universal behaviour of load distribution in scale-free networks. Phys Rev Lett 87(27):278701, 2001.  Chung F and Lu L: Connected components in a random graph with given degree sequences. Annals of Combinatorics 6, 125-145, 2002.  Cho YS, Kim JS, Park J, Kahng B, Kim D: Percolation transitions in scale-free networks under the Achlioptas process. Phys Rev Lett 103:135702, 2009.   source  #  LightGraphs.stochastic_block_model     Method .  stochastic_block_model(c::Matrix{Float64}, n::Vector{Int}; seed::Int = -1)\nstochastic_block_model(cin::Float64, coff::Float64, n::Vector{Int}; seed::Int = -1)  Returns a Graph generated according to the Stochastic Block Model (SBM).  c[a,b]  : Mean number of neighbors of a vertex in block  a  belonging to block  b .            Only the upper triangular part is considered, since the lower traingular is            determined by $c[b,a] = c[a,b] * n[a]/n[b]$.  n[a]  : Number of vertices in block  a  The second form samples from a SBM with  c[a,a]=cin , and  c[a,b]=coff .  For a dynamic version of the SBM see the  StochasticBlockModel  type and related functions.  source  #  LightGraphs.watts_strogatz     Method .  Creates a  Watts-Strogatz  small model random graph with  n  vertices, each with degree  k . Edges are randomized per the model based on probability  \u03b2 . Undirected graphs are created by default; use  is_directed=true  to override.  source", 
            "title": "Random Graphs"
        }, 
        {
            "location": "/generators/#static-graphs", 
            "text": "LightGraphs.jl  also implements a collection of classic graph generators:  #  LightGraphs.BinaryTree     Method .  create a binary tree with k-levels vertices are numbered 1:2^levels-1  source  #  LightGraphs.CliqueGraph     Method .  This function generates  n  connected k-cliques   source  #  LightGraphs.CompleteBipartiteGraph     Method .  Creates a complete bipartite graph with  n1+n2  vertices. It has edges connecting each pair of vertices in the two sets.  source  #  LightGraphs.CompleteDiGraph     Method .  Creates a complete digraph with  n  vertices. A complete digraph has edges connecting each pair of vertices (both an ingoing and outgoing edge).  source  #  LightGraphs.CompleteGraph     Method .  Creates a complete graph with  n  vertices. A complete graph has edges connecting each pair of vertices.  source  #  LightGraphs.CycleDiGraph     Method .  Creates a cycle digraph with  n  vertices. A cycle digraph is a closed path digraph.  source  #  LightGraphs.CycleGraph     Method .  Creates a cycle graph with  n  vertices. A cycle graph is a closed path graph.  source  #  LightGraphs.DoubleBinaryTree     Method .  create a double complete binary tree with k-levels used as an example for spectral clustering by Guattery and Miller 1998.  source  #  LightGraphs.Grid     Method .  Grid{T :Integer}(dims::AbstractVector{T}; periodic=false)  Creates a  d -dimensional cubic lattice, with  d=length(dims)  and length   dims[i]  in dimension  i . If  periodic=true  the resulting lattice will have periodic boundary condition in each dimension.  source  #  LightGraphs.PathDiGraph     Method .  Creates a path digraph with  n  vertices. A path graph connects each successive vertex by a single directed edge.  source  #  LightGraphs.PathGraph     Method .  Creates a path graph with  n  vertices. A path graph connects each successive vertex by a single edge.  source  #  LightGraphs.RoachGraph     Method .  The Roach Graph from Guattery and Miller 1998  source  #  LightGraphs.StarDiGraph     Method .  Creates a star digraph with  n  vertices. A star digraph has a central vertex with directed edges to every other vertex.  source  #  LightGraphs.StarGraph     Method .  Creates a star graph with  n  vertices. A star graph has a central vertex with edges to each other vertex.  source  #  LightGraphs.WheelDiGraph     Method .  Creates a wheel digraph with  n  vertices. A wheel graph is a star digraph with the outer vertices connected via a closed path graph.  source  #  LightGraphs.WheelGraph     Method .  Creates a wheel graph with  n  vertices. A wheel graph is a star graph with the outer vertices connected via a closed path graph.  source", 
            "title": "Static Graphs"
        }, 
        {
            "location": "/generators/#small-graphs", 
            "text": "Other classical graphs can be generated by the following function:  #  LightGraphs.smallgraph     Method .  smallgraph(s::Symbol)\nsmallgraph(s::AbstractString)  Creates a small graph of type  s . Admissible values for  s  are:     s  graph type      :bull  A  bull graph .    :chvatal  A  Chv\u00e1tal graph .    :cubical  A  Platonic cubical graph .    :desargues  A  Desarguesgraph .    :diamond  A  diamond graph .    :dodecahedral  A  Platonic dodecahedral  graph .    :frucht  A  Frucht graph .    :heawood  A  Heawood graph .    :house  A graph mimicing the classic outline of a house.    :housex  A house graph, with two edges crossing the bottom square.    :icosahedral  A  Platonic icosahedral   graph .    :krackhardtkite  A  Krackhardt-Kite social network  graph .    :moebiuskantor  A  M\u00f6bius-Kantor graph .    :octahedral  A  Platonic octahedral graph .    :pappus  A  Pappus graph .    :petersen  A  Petersen graph .    :sedgewickmaze  A simple maze graph used in Sedgewick's  Algorithms in C++: Graph  Algorithms (3rd ed.)    :tetrahedral  A  Platonic tetrahedral  graph .    :truncatedcube  A skeleton of the  truncated cube graph .    :truncatedtetrahedron  A skeleton of the  truncated tetrahedron  graph .    :truncatedtetrahedron_dir  A skeleton of the  truncated tetrahedron digraph .    :tutte  A  Tutte graph .     source", 
            "title": "Small Graphs"
        }, 
        {
            "location": "/generators/#euclidean-graphs", 
            "text": "Generation of random and static graphs embedded in Euclidean space.  #  LightGraphs.euclidean_graph     Function .  euclidean_graph(points::Matrix, L=1., p=2., cutoff=-1., bc=:open)  Given the  d\u00d7N  matrix  points  builds an Euclidean graph of  N  vertices according to the following procedure.  Defining the  d -dimensional vectors  x[i] = points[:,i] , an edge between vertices  i  and  j  is inserted if  norm(x[i]-x[j], p)   cutoff . In case of negative  cutoff  instead every edge is inserted. For  p=2  we have the standard Euclidean distance. Set  bc=:periodic  to impose periodic boundary conditions in the box $[0,L]^d$.  Returns a graph and Dict containing the distance on each edge.  euclidean_graph(N, d; seed = -1, L=1., p=2., cutoff=-1., bc=:open)  Generates  N  uniformly distributed points in the box $[0,L]^d$ and builds and Euclidean graph.  Returns a graph, a Dict containing the distance on each edge and a matrix with the points' positions.  source", 
            "title": "Euclidean Graphs"
        }, 
        {
            "location": "/generators/#datasets", 
            "text": "Other notorious graphs and integration with the  MatrixDepot.jl  package are available in the  Datasets  submodule of the companion package  LightGraphsExtras.jl  ```", 
            "title": "Datasets"
        }, 
        {
            "location": "/persistence/", 
            "text": "Reading and writing Graphs\n\n\nGraphs may be written to I/O streams and files using the \nsave\n function and read with the \nload\n function. Currently supported graph formats are the  \nLightGraphs.jl\n format \nlg\n and the common formats \ngml, graphml, gexf, dot, net\n.\n\n\n#\n\n\nLightGraphs.load\n \n \nFunction\n.\n\n\nload(file, t=:lg)\n\n\n\n\nLoads multiple graphs from  \nfile\n in the format \nt\n. Returns a dictionary mapping graph name to graph.\n\n\nFor unnamed graphs the default names \"graph\" and \"digraph\" will be used.\n\n\nsource\n\n\n#\n\n\nLightGraphs.load\n \n \nFunction\n.\n\n\nload(file, name, t=:lg)\n\n\n\n\nLoads a graph with name \nname\n from \nfile\n in format \nt\n.\n\n\nCurrently supported formats are \n:lg, :gml, :graphml, :gexf, :dot, :net\n.\n\n\nsource\n\n\n#\n\n\nLightGraphs.loadgraph\n \n \nMethod\n.\n\n\nloadgraph(file, t=:lg)\n\n\n\n\nReads a graph from  \nfile\n in the format \nt\n.\n\n\nSupported formats are \n:lg, :gml, :dot, :graphml, :gexf, :net, :jld, :graph6\n.\n\n\nsource\n\n\n#\n\n\nLightGraphs.save\n \n \nFunction\n.\n\n\nsave(file, g, t=:lg)\nsave(file, g, name, t=:lg)\nsave(file, dict, t=:lg)\n\n\n\n\nSaves a graph \ng\n with name \nname\n to \nfile\n in the format \nt\n. If \nname\n is not given the default names \"graph\" and \"digraph\" will be used.\n\n\nCurrently supported formats are \n:lg, :gml, :graphml, :gexf, :dot, :net, :graph6\n.\n\n\nFor some graph formats, multiple graphs in a  \ndict\n \n\"name\"=\ng\n can be saved in the same file.\n\n\nReturns the number of graphs written.\n\n\nsource\n\n\n#\n\n\nLightGraphs.savegraph\n \n \nMethod\n.\n\n\nSave a graph to file. See \nsave\n.\n\n\nsource\n\n\n\n\nExamples\n\n\nsave(STDOUT, g)\nsave(\nmygraph.jgz\n, g, \nmygraph\n, compress=true)\n\nsavegraph(\nmygraph.jgz\n, g, compress=true)\n\ndg = load(\nmultiplegraphs.jgz\n) # dictionary of graphs\ndg = load(\nmultiplegraphs.graphml\n, :graphml)\ndg = load(\nmygraph.gml\n, \nmygraph\n, :gml)\n\ng = laoadgraph(\nmygraph.gml\n,  :gml)", 
            "title": "Reading / Writing Graphs"
        }, 
        {
            "location": "/persistence/#reading-and-writing-graphs", 
            "text": "Graphs may be written to I/O streams and files using the  save  function and read with the  load  function. Currently supported graph formats are the   LightGraphs.jl  format  lg  and the common formats  gml, graphml, gexf, dot, net .  #  LightGraphs.load     Function .  load(file, t=:lg)  Loads multiple graphs from   file  in the format  t . Returns a dictionary mapping graph name to graph.  For unnamed graphs the default names \"graph\" and \"digraph\" will be used.  source  #  LightGraphs.load     Function .  load(file, name, t=:lg)  Loads a graph with name  name  from  file  in format  t .  Currently supported formats are  :lg, :gml, :graphml, :gexf, :dot, :net .  source  #  LightGraphs.loadgraph     Method .  loadgraph(file, t=:lg)  Reads a graph from   file  in the format  t .  Supported formats are  :lg, :gml, :dot, :graphml, :gexf, :net, :jld, :graph6 .  source  #  LightGraphs.save     Function .  save(file, g, t=:lg)\nsave(file, g, name, t=:lg)\nsave(file, dict, t=:lg)  Saves a graph  g  with name  name  to  file  in the format  t . If  name  is not given the default names \"graph\" and \"digraph\" will be used.  Currently supported formats are  :lg, :gml, :graphml, :gexf, :dot, :net, :graph6 .  For some graph formats, multiple graphs in a   dict   \"name\"= g  can be saved in the same file.  Returns the number of graphs written.  source  #  LightGraphs.savegraph     Method .  Save a graph to file. See  save .  source", 
            "title": "Reading and writing Graphs"
        }, 
        {
            "location": "/persistence/#examples", 
            "text": "save(STDOUT, g)\nsave( mygraph.jgz , g,  mygraph , compress=true)\n\nsavegraph( mygraph.jgz , g, compress=true)\n\ndg = load( multiplegraphs.jgz ) # dictionary of graphs\ndg = load( multiplegraphs.graphml , :graphml)\ndg = load( mygraph.gml ,  mygraph , :gml)\n\ng = laoadgraph( mygraph.gml ,  :gml)", 
            "title": "Examples"
        }, 
        {
            "location": "/integration/", 
            "text": "Integration with other packages\n\n\nLightGraphs.jl\n's integration with other Julia packages is designed to be straightforward. Here are a few examples.\n\n\n\n\nGraphs.jl\n\n\nCreating a Graphs.jl \nsimple_graph\n is easy:\n\n\njulia\n s = simple_graph(nv(g), is_directed=LightGraphs.is_directed(g))\njulia\n for e in LightGraphs.edges(g)\n           add_edge!(s,src(e), dst(e))\n       end\n\n\n\n\n\n\nGraphLayout.jl\n\n\nThis excellent graph visualization package can be used with \nLightGraphs.jl\n as follows:\n\n\njulia\n g = WheelGraph(10); am = full(adjacency_matrix(g))\njulia\n loc_x, loc_y = layout_spring_adj(am)\njulia\n draw_layout_adj(am, loc_x, loc_y, filename=\nwheel10.svg\n)\n\n\n\n\nproducing a graph like this:\n\n\n\n\n\n\nTikzGraphs.jl\n\n\nAnother nice graph visualization package. (\nTikzPictures.jl\n required to render/save):\n\n\njulia\n g = WheelGraph(10); t = plot(g)\n\njulia\n save(SVG(\nwheel10.svg\n), t)\n\n\n\n\nproducing a graph like this:\n\n\n\n\n\n\nGraphPlot.jl\n\n\nAnother graph visualization package that is very simple to use. \nCompose.jl\n is required for most rendering functionality:\n\n\njulia\n using GraphPlot, Compose\n\njulia\n g = WheelGraph(10)\n\njulia\n draw(PNG(\n/tmp/wheel10.png\n, 16cm, 16cm), gplot(g))\n\n\n\n\n\n\nMetis.jl\n\n\nThe Metis graph partitioning package can interface with \nLightGraphs.jl\n:\n\n\njulia\n using LightGraphs\n\njulia\n g = Graph(100,1000)\n{100, 1000} undirected graph\n\njulia\n partGraphKway(g, 6)  # 6 partitions\n\n\n\n\nNetworkViz.jl\n NetworkViz.jl is tightly coupled with \nLightGraphs.jl\n. Graphs can be visualized in 2D as well as 3D using \nThreeJS.jl\n and \nEscher.jl\n.\n\n\n#Run this code in Escher\n\nusing NetworkViz\nusing LightGraphs\n\nmain(window) = begin\n  push!(window.assets, \nwidgets\n)\n  push!(window.assets,(\nThreeJS\n,\nthreejs\n))\n  g = CompleteGraph(10)\n  drawGraph(g)\nend\n\n\n\n\nThe above code produces the following output:", 
            "title": "Integration with other packages"
        }, 
        {
            "location": "/integration/#integration-with-other-packages", 
            "text": "LightGraphs.jl 's integration with other Julia packages is designed to be straightforward. Here are a few examples.", 
            "title": "Integration with other packages"
        }, 
        {
            "location": "/integration/#graphsjl", 
            "text": "Creating a Graphs.jl  simple_graph  is easy:  julia  s = simple_graph(nv(g), is_directed=LightGraphs.is_directed(g))\njulia  for e in LightGraphs.edges(g)\n           add_edge!(s,src(e), dst(e))\n       end", 
            "title": "Graphs.jl"
        }, 
        {
            "location": "/integration/#graphlayoutjl", 
            "text": "This excellent graph visualization package can be used with  LightGraphs.jl  as follows:  julia  g = WheelGraph(10); am = full(adjacency_matrix(g))\njulia  loc_x, loc_y = layout_spring_adj(am)\njulia  draw_layout_adj(am, loc_x, loc_y, filename= wheel10.svg )  producing a graph like this:", 
            "title": "GraphLayout.jl"
        }, 
        {
            "location": "/integration/#tikzgraphsjl", 
            "text": "Another nice graph visualization package. ( TikzPictures.jl  required to render/save):  julia  g = WheelGraph(10); t = plot(g)\n\njulia  save(SVG( wheel10.svg ), t)  producing a graph like this:", 
            "title": "TikzGraphs.jl"
        }, 
        {
            "location": "/integration/#graphplotjl", 
            "text": "Another graph visualization package that is very simple to use.  Compose.jl  is required for most rendering functionality:  julia  using GraphPlot, Compose\n\njulia  g = WheelGraph(10)\n\njulia  draw(PNG( /tmp/wheel10.png , 16cm, 16cm), gplot(g))", 
            "title": "GraphPlot.jl"
        }, 
        {
            "location": "/integration/#metisjl", 
            "text": "The Metis graph partitioning package can interface with  LightGraphs.jl :  julia  using LightGraphs\n\njulia  g = Graph(100,1000)\n{100, 1000} undirected graph\n\njulia  partGraphKway(g, 6)  # 6 partitions", 
            "title": "Metis.jl"
        }, 
        {
            "location": "/integration/#networkvizjl-networkvizjl-is-tightly-coupled-with-lightgraphsjl-graphs-can-be-visualized-in-2d-as-well-as-3d-using-threejsjl-and-escherjl", 
            "text": "#Run this code in Escher\n\nusing NetworkViz\nusing LightGraphs\n\nmain(window) = begin\n  push!(window.assets,  widgets )\n  push!(window.assets,( ThreeJS , threejs ))\n  g = CompleteGraph(10)\n  drawGraph(g)\nend  The above code produces the following output:", 
            "title": "NetworkViz.jl NetworkViz.jl is tightly coupled with LightGraphs.jl. Graphs can be visualized in 2D as well as 3D using ThreeJS.jl and Escher.jl."
        }, 
        {
            "location": "/contributing/", 
            "text": "We welcome all possible contributors and ask that you read these guidelines before starting to work on this project. Following these guidelines will reduce friction and improve the speed at which your code gets merged.\n\n\n\n\nBug reports\n\n\nIf you notice code that is incorrect/crashes/too slow please file a bug report. The report should be raised as a github issue with a minimal working example that reproduces the error message. The example should include any data needed. If the problem is incorrectness, then please post the correct result along with an incorrect result.\n\n\nPlease include version numbers of all relevant libraries and Julia itself.\n\n\n\n\nDevelopment guidelines\n\n\n\n\nPRs should contain one logical enhancement to the codebase.\n\n\nSquash commits in a PR.\n\n\nOpen an issue to discuss a feature before you start coding (this maximizes the likelihood of patch acceptance).\n\n\n\n\nMinimize dependencies on external packages, and avoid introducing new dependencies. In general,\n\n\n\n\nPRs introducing dependencies on core Julia packages are ok.\n\n\nPRs introducing dependencies on non-core \"leaf\" packages (no subdependencies except for core Julia packages) are less ok.\n\n\nPRs introducing dependencies on non-core non-leaf packages require strict scrutiny and will likely not be accepted without some compelling reason (urgent bugfix or much-needed functionality).\n\n\nPut type assertions on all function arguments (use abstract types, Union, or Any if necessary).\n\n\nIf the algorithm was presented in a paper, include a reference to the paper (i.e. a proper academic citation along with an eprint link).\n\n\nTake steps to ensure that code works on graphs with multiple connected components efficiently.\n\n\nCorrectness is a necessary requirement; efficiency is desirable. Once you have a correct implementation, make a PR so we can help improve performance.\n\n\nWe can accept code that does not work for directed graphs as long as it comes with an explanation of what it would take to make it work for directed graphs.\n\n\nStyle point: prefer the short circuiting conditional over if/else when convenient, and where state is not explicitly being mutated (\ne.g.\n, \ncondition \n error(\"message\")\n is good; \ncondition \n i += 1\n is not).\n\n\nWhen possible write code to reuse memory. For example:\n\n\n\n\n\n\n\n\nfunction f(g, v)\n    storage = Vector{Int}(nv(g))\n    # some code operating on storage, g, and v.\n    for i in 1:nv(g)\n        storage[i] = v-i\n    end\n    return sum(storage)\nend\n\n\n\n\nshould be rewritten as two functions\n\n\nfunction f(g::SimpleGraph, v::Integer)\n    storage = Vector{Int}(nv(g))\n    return inner!(storage, g, v)\nend\n\nfunction inner!(storage::AbstractArray{Int,1}, g::SimpleGraph, v::Integer)\n    # some code operating on storage, g, and v.\n    for i in 1:nv(g)\n        storage[i] = v-i\n    end\n    return sum(storage)\nend\n\n\n\n\nThis allows us to reuse the memory and improve performance.", 
            "title": "Contributing"
        }, 
        {
            "location": "/contributing/#bug-reports", 
            "text": "If you notice code that is incorrect/crashes/too slow please file a bug report. The report should be raised as a github issue with a minimal working example that reproduces the error message. The example should include any data needed. If the problem is incorrectness, then please post the correct result along with an incorrect result.  Please include version numbers of all relevant libraries and Julia itself.", 
            "title": "Bug reports"
        }, 
        {
            "location": "/contributing/#development-guidelines", 
            "text": "PRs should contain one logical enhancement to the codebase.  Squash commits in a PR.  Open an issue to discuss a feature before you start coding (this maximizes the likelihood of patch acceptance).   Minimize dependencies on external packages, and avoid introducing new dependencies. In general,   PRs introducing dependencies on core Julia packages are ok.  PRs introducing dependencies on non-core \"leaf\" packages (no subdependencies except for core Julia packages) are less ok.  PRs introducing dependencies on non-core non-leaf packages require strict scrutiny and will likely not be accepted without some compelling reason (urgent bugfix or much-needed functionality).  Put type assertions on all function arguments (use abstract types, Union, or Any if necessary).  If the algorithm was presented in a paper, include a reference to the paper (i.e. a proper academic citation along with an eprint link).  Take steps to ensure that code works on graphs with multiple connected components efficiently.  Correctness is a necessary requirement; efficiency is desirable. Once you have a correct implementation, make a PR so we can help improve performance.  We can accept code that does not work for directed graphs as long as it comes with an explanation of what it would take to make it work for directed graphs.  Style point: prefer the short circuiting conditional over if/else when convenient, and where state is not explicitly being mutated ( e.g. ,  condition   error(\"message\")  is good;  condition   i += 1  is not).  When possible write code to reuse memory. For example:     function f(g, v)\n    storage = Vector{Int}(nv(g))\n    # some code operating on storage, g, and v.\n    for i in 1:nv(g)\n        storage[i] = v-i\n    end\n    return sum(storage)\nend  should be rewritten as two functions  function f(g::SimpleGraph, v::Integer)\n    storage = Vector{Int}(nv(g))\n    return inner!(storage, g, v)\nend\n\nfunction inner!(storage::AbstractArray{Int,1}, g::SimpleGraph, v::Integer)\n    # some code operating on storage, g, and v.\n    for i in 1:nv(g)\n        storage[i] = v-i\n    end\n    return sum(storage)\nend  This allows us to reuse the memory and improve performance.", 
            "title": "Development guidelines"
        }, 
        {
            "location": "/license/", 
            "text": "The LightGraphs.jl package is licensed under the Simplified \"2-clause\" BSD License:\n\n\n\n\nCopyright (c) 2015: Seth Bromberger and other contributors.\n\n\nRedistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n\n\n\n\nRedistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\n\n\nRedistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\n\n\n\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\n\n\n\nLightGraphs uses code derived from and/or inspired by the following packages:\n\n\nNetworkX:\n\n\n\n\nCopyright (C) 2004-2012, NetworkX Developers Aric Hagberg \n Dan Schult \n Pieter Swart \n All rights reserved.\n\n\nRedistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n\n\n\n\nRedistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\n\n\nRedistributions in binary form must reproduce the above with the distribution.\n\n\nNeither the name of the NetworkX Developers nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.\n\n\n\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\n\n\n\nGraphs.jl:\n\n\n\n\nCopyright (c) 2012: John Myles White and other contributors.\n\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n\n\nThe above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.", 
            "title": "License Information"
        }
    ]
}