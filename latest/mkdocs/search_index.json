{
    "docs": [
        {
            "location": "/", 
            "text": "LightGraphs\n\n\n \n \n \n\n\n \n \n \n\n\nAn optimized graphs package.\n\n\nSimple graphs (not multi- or hypergraphs) are represented in a memory- and time-efficient manner with adjacency lists and edge iterators. Both directed and undirected graphs are supported via separate types, and conversion is available from directed to undirected.\n\n\nThe project goal is to mirror the functionality of robust network and graph analysis libraries such as \nNetworkX\n while being simpler to use and more efficient than existing Julian graph libraries such as \nGraphs.jl\n. It is an explicit design decision that any data not required for graph manipulation (attributes and other information, for example) is expected to be stored outside of the graph structure itself. Such data lends itself to storage in more traditional and better-optimized mechanisms.\n\n\nAdditional functionality may be found in the companion package \nLightGraphsExtras.jl\n.\n\n\n\n\nDocumentation\n\n\nFull documentation is available at \nGitHub Pages\n. Documentation for methods is also available via the Julia REPL help system. Additional tutorials can be found at \nJuliaGraphsTutorials\n.\n\n\n\n\nCore Concepts\n\n\nA graph \nG\n is described by a set of vertices \nV\n and edges \nE\n: \nG = {V, E}\n. \nV\n is an integer range \n1:n\n; \nE\n is represented as forward (and, for directed graphs, backward) adjacency lists indexed by vertices. Edges may also be accessed via an iterator that yields \nEdge\n types containing \n(src\n:Integer, dst\n:Integer)\n values. Both vertices and edges may be integers of any type, and the smallest type that fits the data is recommended in order to save memory.\n\n\nLightGraphs.jl\n provides two graph types: \nGraph\n is an undirected graph, and \nDiGraph\n is its directed counterpart.\n\n\nGraphs are created using \nGraph()\n or \nDiGraph()\n; there are several options (see the tutorials for examples).\n\n\nMultiple edges between two given vertices are not allowed: an attempt to add an edge that already exists in a graph will result in a silent failure.\n\n\n\n\nInstallation\n\n\nInstallation is straightforward:\n\n\njulia\n Pkg.add(\nLightGraphs\n)\n\n\n\n\n\n\nCurrent functionality\n\n\n\n\ncore functions:\n vertices and edges addition and removal, degree (in/out/histogram), neighbors (in/out/all/common)\n\n\ndistance within graphs:\n eccentricity, diameter, periphery, radius, center\n\n\ndistance between graphs:\n spectral_distance, edit_distance\n\n\nconnectivity:\n strongly- and weakly-connected components, bipartite checks, condensation, attracting components, neighborhood\n\n\noperators:\n complement, reverse, reverse!, union, join, intersect, difference,\n\n\n\n\nsymmetric difference, blkdiag, induced subgraphs, products (cartesian/scalar)\n\n\n\n\nshortest paths:\n Dijkstra, Dijkstra with predecessors, Bellman-Ford, Floyd-Warshall, A*\n\n\nsmall graph generators:\n see \nsmallgraphs.jl\n for list\n\n\nrandom graph generators:\n Erd\u0151s\u2013R\u00e9nyi, Watts-Strogatz, random regular, arbitrary degree sequence, stochastic block model\n\n\ncentrality:\n betweenness, closeness, degree, pagerank, Katz\n\n\ntraversal operations:\n cycle detection, BFS and DFS DAGs, BFS and DFS traversals with visitors, DFS topological sort, maximum adjacency / minimum cut, multiple random walks\n\n\nflow operations:\n maximum flow\n\n\nmatching:\n Matching functions have been moved to \nLightGraphsExtras.jl\n.\n\n\nclique enumeration:\n maximal cliques\n\n\nlinear algebra / spectral graph theory:\n adjacency matrix (works as input to \nGraphLayout\n and \nMetis\n), Laplacian matrix, non-backtracking matrix\n\n\ncommunity:\n modularity, community detection, core-periphery, clustering coefficients\n\n\npersistence formats:\n LightGraphs natively supports a proprietary compressed format. For other formats, please see the \nGraphIO.jl\n package.\n\n\nvisualization:\n integration with\n\n\n\n\nGraphPlot\n, \nPlots\n via \nPlotRecipes\n, \nGraphLayout\n, \nTikzGraphs\n,  \nNetworkViz\n\n\n\n\nCore API\n\n\nThese functions are defined as the public contract of the \nLightGraphs.AbstractGraph\n interface.\n\n\n\n\nConstructing and modifying the graph\n\n\n\n\nGraph\n\n\nDiGraph\n\n\nadd_edge!\n\n\nrem_edge!\n\n\nadd_vertex!\n, \nadd_vertices!\n\n\nrem_vertex!\n\n\nzero\n\n\n\n\n\n\nEdge/Arc interface\n\n\n\n\nsrc\n\n\ndst\n\n\nreverse\n\n\n==\n\n\nPair / Tuple conversion\n\n\n\n\n\n\nAccessing state\n\n\n\n\nnv\n\n\nne\n\n\nvertices\n (Iterable)\n\n\nedges\n (Iterable)\n\n\nneighbors\n, \nin_neighbors\n, \nout_neighbors\n\n\nhas_vertex\n\n\nhas_edge\n\n\nhas_self_loops\n (though this might be a trait or an abstract graph type)\n\n\n\n\n\n\nNon-Core APIs\n\n\nThese functions can be constructed from the Core API functions but can be given specialized implementations in order to improve performance.\n\n\n\n\nadjacency_matrix\n\n\ndegree\n\n\n\n\nThis can be computed from neighbors by default \ndegree(g,v) = length(neighbors(g,v))\n so you don't need to implement this unless your type can compute degree faster than this method.\n\n\n\n\nSupported Versions\n\n\n\n\nLightGraphs master is designed to work with the latest stable version of Julia.\n\n\nJulia 0.3: LightGraphs v0.3.7 is the last version guaranteed to work with Julia 0.3.\n\n\nJulia 0.4: LightGraphs versions in the 0.6 series are designed to work with Julia 0.4.\n\n\nJulia 0.5: LightGraphs versions in the 0.7 series are designed to work with Julia 0.5.\n\n\nJulia 0.6: LightGraphs versions in the 0.8 and 0.9 series are designed to work with Julia 0.6.\n\n\nLater versions: Some functionality might not work with prerelease / unstable / nightly versions of Julia. If you run into a problem, please file an issue.\n\n\n\n\n\n\nContributing and Reporting Bugs\n\n\nWe welcome contributions and bug reports! Please see \nCONTRIBUTING.md\n for guidance on development and bug reporting.", 
            "title": "Getting Started"
        }, 
        {
            "location": "/#lightgraphs", 
            "text": "An optimized graphs package.  Simple graphs (not multi- or hypergraphs) are represented in a memory- and time-efficient manner with adjacency lists and edge iterators. Both directed and undirected graphs are supported via separate types, and conversion is available from directed to undirected.  The project goal is to mirror the functionality of robust network and graph analysis libraries such as  NetworkX  while being simpler to use and more efficient than existing Julian graph libraries such as  Graphs.jl . It is an explicit design decision that any data not required for graph manipulation (attributes and other information, for example) is expected to be stored outside of the graph structure itself. Such data lends itself to storage in more traditional and better-optimized mechanisms.  Additional functionality may be found in the companion package  LightGraphsExtras.jl .", 
            "title": "LightGraphs"
        }, 
        {
            "location": "/#documentation", 
            "text": "Full documentation is available at  GitHub Pages . Documentation for methods is also available via the Julia REPL help system. Additional tutorials can be found at  JuliaGraphsTutorials .", 
            "title": "Documentation"
        }, 
        {
            "location": "/#core-concepts", 
            "text": "A graph  G  is described by a set of vertices  V  and edges  E :  G = {V, E} .  V  is an integer range  1:n ;  E  is represented as forward (and, for directed graphs, backward) adjacency lists indexed by vertices. Edges may also be accessed via an iterator that yields  Edge  types containing  (src :Integer, dst :Integer)  values. Both vertices and edges may be integers of any type, and the smallest type that fits the data is recommended in order to save memory.  LightGraphs.jl  provides two graph types:  Graph  is an undirected graph, and  DiGraph  is its directed counterpart.  Graphs are created using  Graph()  or  DiGraph() ; there are several options (see the tutorials for examples).  Multiple edges between two given vertices are not allowed: an attempt to add an edge that already exists in a graph will result in a silent failure.", 
            "title": "Core Concepts"
        }, 
        {
            "location": "/#installation", 
            "text": "Installation is straightforward:  julia  Pkg.add( LightGraphs )", 
            "title": "Installation"
        }, 
        {
            "location": "/#current-functionality", 
            "text": "core functions:  vertices and edges addition and removal, degree (in/out/histogram), neighbors (in/out/all/common)  distance within graphs:  eccentricity, diameter, periphery, radius, center  distance between graphs:  spectral_distance, edit_distance  connectivity:  strongly- and weakly-connected components, bipartite checks, condensation, attracting components, neighborhood  operators:  complement, reverse, reverse!, union, join, intersect, difference,   symmetric difference, blkdiag, induced subgraphs, products (cartesian/scalar)   shortest paths:  Dijkstra, Dijkstra with predecessors, Bellman-Ford, Floyd-Warshall, A*  small graph generators:  see  smallgraphs.jl  for list  random graph generators:  Erd\u0151s\u2013R\u00e9nyi, Watts-Strogatz, random regular, arbitrary degree sequence, stochastic block model  centrality:  betweenness, closeness, degree, pagerank, Katz  traversal operations:  cycle detection, BFS and DFS DAGs, BFS and DFS traversals with visitors, DFS topological sort, maximum adjacency / minimum cut, multiple random walks  flow operations:  maximum flow  matching:  Matching functions have been moved to  LightGraphsExtras.jl .  clique enumeration:  maximal cliques  linear algebra / spectral graph theory:  adjacency matrix (works as input to  GraphLayout  and  Metis ), Laplacian matrix, non-backtracking matrix  community:  modularity, community detection, core-periphery, clustering coefficients  persistence formats:  LightGraphs natively supports a proprietary compressed format. For other formats, please see the  GraphIO.jl  package.  visualization:  integration with   GraphPlot ,  Plots  via  PlotRecipes ,  GraphLayout ,  TikzGraphs ,   NetworkViz", 
            "title": "Current functionality"
        }, 
        {
            "location": "/#core-api", 
            "text": "These functions are defined as the public contract of the  LightGraphs.AbstractGraph  interface.", 
            "title": "Core API"
        }, 
        {
            "location": "/#constructing-and-modifying-the-graph", 
            "text": "Graph  DiGraph  add_edge!  rem_edge!  add_vertex! ,  add_vertices!  rem_vertex!  zero", 
            "title": "Constructing and modifying the graph"
        }, 
        {
            "location": "/#edgearc-interface", 
            "text": "src  dst  reverse  ==  Pair / Tuple conversion", 
            "title": "Edge/Arc interface"
        }, 
        {
            "location": "/#accessing-state", 
            "text": "nv  ne  vertices  (Iterable)  edges  (Iterable)  neighbors ,  in_neighbors ,  out_neighbors  has_vertex  has_edge  has_self_loops  (though this might be a trait or an abstract graph type)", 
            "title": "Accessing state"
        }, 
        {
            "location": "/#non-core-apis", 
            "text": "These functions can be constructed from the Core API functions but can be given specialized implementations in order to improve performance.   adjacency_matrix  degree   This can be computed from neighbors by default  degree(g,v) = length(neighbors(g,v))  so you don't need to implement this unless your type can compute degree faster than this method.", 
            "title": "Non-Core APIs"
        }, 
        {
            "location": "/#supported-versions", 
            "text": "LightGraphs master is designed to work with the latest stable version of Julia.  Julia 0.3: LightGraphs v0.3.7 is the last version guaranteed to work with Julia 0.3.  Julia 0.4: LightGraphs versions in the 0.6 series are designed to work with Julia 0.4.  Julia 0.5: LightGraphs versions in the 0.7 series are designed to work with Julia 0.5.  Julia 0.6: LightGraphs versions in the 0.8 and 0.9 series are designed to work with Julia 0.6.  Later versions: Some functionality might not work with prerelease / unstable / nightly versions of Julia. If you run into a problem, please file an issue.", 
            "title": "Supported Versions"
        }, 
        {
            "location": "/#contributing-and-reporting-bugs", 
            "text": "We welcome contributions and bug reports! Please see  CONTRIBUTING.md  for guidance on development and bug reporting.", 
            "title": "Contributing and Reporting Bugs"
        }, 
        {
            "location": "/basicmeasures/", 
            "text": "Basic Functions\n\n\nLightGraphs.jl\n defines the following basic types and functionalities:\n\n\n\n\nLightGraphs.add_vertices!\n\n\nLightGraphs.all_neighbors\n\n\nLightGraphs.common_neighbors\n\n\nLightGraphs.degree\n\n\nLightGraphs.degree_histogram\n\n\nLightGraphs.density\n\n\nLightGraphs.has_self_loops\n\n\nLightGraphs.indegree\n\n\nLightGraphs.is_ordered\n\n\nLightGraphs.isgraphical\n\n\nLightGraphs.neighborhood\n\n\nLightGraphs.neighbors\n\n\nLightGraphs.num_self_loops\n\n\nLightGraphs.outdegree\n\n\nLightGraphs.squash\n\n\nLightGraphs.\u0394\n\n\nLightGraphs.\u0394in\n\n\nLightGraphs.\u0394out\n\n\nLightGraphs.\u03b4\n\n\nLightGraphs.\u03b4in\n\n\nLightGraphs.\u03b4out\n\n\n\n\n#\n\n\nLightGraphs.add_vertices!\n \n \nMethod\n.\n\n\nadd_vertices!(g, n)\n\n\n\n\nAdd \nn\n new vertices to the graph \ng\n. Return \ntrue\n if all vertices were added successfully, \nfalse\n otherwise.\n\n\nsource\n\n\n#\n\n\nLightGraphs.all_neighbors\n \n \nFunction\n.\n\n\nall_neighbors(g, v)\n\n\n\n\nReturn a list of all inbound and outbound neighbors of \nv\n in \ng\n. For undirected graphs, this is equivalent to both \nout_neighbors\n and \nin_neighbors\n.\n\n\nImplementation Notes\n\n\nReturns a reference, not a copy. Do not modify result.\n\n\nsource\n\n\n#\n\n\nLightGraphs.common_neighbors\n \n \nMethod\n.\n\n\ncommon_neighbors(g, u, v)\n\n\n\n\nReturn the neighbors common to vertices \nu\n and \nv\n in \ng\n.\n\n\nImplementation Notes\n\n\nReturns a reference, not a copy. Do not modify result.\n\n\nsource\n\n\n#\n\n\nLightGraphs.degree\n \n \nFunction\n.\n\n\ndegree(g[, v])\n\n\n\n\nReturn a vector corresponding to the number of edges which start or end at each vertex in graph \ng\n. If \nv\n is specified, only return degrees for vertices in \nv\n. For directed graphs, this value equals the incoming plus outgoing edges. For undirected graphs, it equals the connected edges.\n\n\nsource\n\n\n#\n\n\nLightGraphs.degree_histogram\n \n \nFunction\n.\n\n\ndegree_histogram(g, degfn=degree)\n\n\n\n\nReturn a Dict with values representing the number of vertices that have degree represented by the key.\n\n\nDegree function (for example, \nindegree\n or \noutdegree\n) may be specified by overriding \ndegfn\n.\n\n\nsource\n\n\n#\n\n\nLightGraphs.density\n \n \nFunction\n.\n\n\ndensity(g)\n\n\n\n\nReturn the density of \ng\n. Density is defined as the ratio of the number of actual edges to the number of possible edges ($|V|\u00d7(|V|-1)$ for directed graphs and $\\frac{|V|\u00d7(|V|-1)}{2}$ for undirected graphs).\n\n\nsource\n\n\n#\n\n\nLightGraphs.has_self_loops\n \n \nMethod\n.\n\n\nhas_self_loops(g)\n\n\n\n\nReturn true if \ng\n has any self loops.\n\n\nsource\n\n\n#\n\n\nLightGraphs.indegree\n \n \nMethod\n.\n\n\nindegree(g[, v])\n\n\n\n\nReturn a vector corresponding to the number of edges which end at each vertex in graph \ng\n. If \nv\n is specified, only return degrees for vertices in \nv\n.\n\n\nsource\n\n\n#\n\n\nLightGraphs.is_ordered\n \n \nMethod\n.\n\n\nis_ordered(e)\n\n\n\n\nReturn true if the source vertex of edge \ne\n is less than or equal to the destination vertex.\n\n\nsource\n\n\n#\n\n\nLightGraphs.neighbors\n \n \nMethod\n.\n\n\nneighbors(g, v)\n\n\n\n\nReturn a list of all neighbors reachable from vertex \nv\n in \ng\n. For directed graphs, the default is equivalent to \nout_neighbors\n; use \nall_neighbors\n to list inbound and outbound neighbors.\n\n\nImplementation Notes\n\n\nReturns a reference, not a copy. Do not modify result.\n\n\nsource\n\n\n#\n\n\nLightGraphs.num_self_loops\n \n \nMethod\n.\n\n\nnum_self_loops(g)\n\n\n\n\nReturn the number of self loops in \ng\n.\n\n\nsource\n\n\n#\n\n\nLightGraphs.outdegree\n \n \nMethod\n.\n\n\noutdegree(g[, v])\n\n\n\n\nReturn a vector corresponding to the number of edges which start at each vertex in graph \ng\n. If \nv\n is specified, only return degrees for vertices in \nv\n.\n\n\nsource\n\n\n#\n\n\nLightGraphs.squash\n \n \nMethod\n.\n\n\nsquash(g)\n\n\n\n\nReturn a copy of a graph with the smallest practical type that can accommodate all vertices.\n\n\nsource\n\n\n#\n\n\nLightGraphs.\u0394\n \n \nMethod\n.\n\n\n\u0394(g)\n\n\n\n\nReturn the maximum \ndegree\n of vertices in \ng\n.\n\n\nsource\n\n\n#\n\n\nLightGraphs.\u0394in\n \n \nMethod\n.\n\n\n\u0394in(g)\n\n\n\n\nReturn the maximum \nindegree\n of vertices in \ng\n.\n\n\nsource\n\n\n#\n\n\nLightGraphs.\u0394out\n \n \nMethod\n.\n\n\n\u0394out(g)\n\n\n\n\nReturn the maximum \noutdegree\n of vertices in \ng\n.\n\n\nsource\n\n\n#\n\n\nLightGraphs.\u03b4\n \n \nMethod\n.\n\n\n\u03b4(g)\n\n\n\n\nReturn the minimum \ndegree\n of vertices in \ng\n.\n\n\nsource\n\n\n#\n\n\nLightGraphs.\u03b4in\n \n \nMethod\n.\n\n\n\u03b4in(g)\n\n\n\n\nReturn the minimum \nindegree\n of vertices in \ng\n.\n\n\nsource\n\n\n#\n\n\nLightGraphs.\u03b4out\n \n \nMethod\n.\n\n\n\u03b4out(g)\n\n\n\n\nReturn the minimum \noutdegree\n of vertices in \ng\n.\n\n\nsource\n\n\n#\n\n\nLightGraphs.isgraphical\n \n \nMethod\n.\n\n\nisgraphical(degs)\n\n\n\n\nReturn true if the degree sequence \ndegs\n is graphical, according to \nErd\u00f6s-Gallai condition\n.\n\n\nPerformance\n\n\nTime complexity: ``\\mathcal{O}(|degs|^2)``\n\n\n\n\nsource\n\n\n#\n\n\nLightGraphs.neighborhood\n \n \nMethod\n.\n\n\nneighborhood(g, v, d)\n\n\n\n\nReturn a vector of the vertices in \ng\n at a geodesic distance less or equal to \nd\n from \nv\n.\n\n\nOptional Arguments\n\n\n\n\ndir=:out\n: If \ng\n is directed, this argument specifies the edge direction\n\n\n\n\nwith respect to \nv\n of the edges to be considered. Possible values: \n:in\n or \n:out\n.\n\n\nsource", 
            "title": "Basic Functions"
        }, 
        {
            "location": "/basicmeasures/#basic-functions", 
            "text": "LightGraphs.jl  defines the following basic types and functionalities:   LightGraphs.add_vertices!  LightGraphs.all_neighbors  LightGraphs.common_neighbors  LightGraphs.degree  LightGraphs.degree_histogram  LightGraphs.density  LightGraphs.has_self_loops  LightGraphs.indegree  LightGraphs.is_ordered  LightGraphs.isgraphical  LightGraphs.neighborhood  LightGraphs.neighbors  LightGraphs.num_self_loops  LightGraphs.outdegree  LightGraphs.squash  LightGraphs.\u0394  LightGraphs.\u0394in  LightGraphs.\u0394out  LightGraphs.\u03b4  LightGraphs.\u03b4in  LightGraphs.\u03b4out   #  LightGraphs.add_vertices!     Method .  add_vertices!(g, n)  Add  n  new vertices to the graph  g . Return  true  if all vertices were added successfully,  false  otherwise.  source  #  LightGraphs.all_neighbors     Function .  all_neighbors(g, v)  Return a list of all inbound and outbound neighbors of  v  in  g . For undirected graphs, this is equivalent to both  out_neighbors  and  in_neighbors .  Implementation Notes  Returns a reference, not a copy. Do not modify result.  source  #  LightGraphs.common_neighbors     Method .  common_neighbors(g, u, v)  Return the neighbors common to vertices  u  and  v  in  g .  Implementation Notes  Returns a reference, not a copy. Do not modify result.  source  #  LightGraphs.degree     Function .  degree(g[, v])  Return a vector corresponding to the number of edges which start or end at each vertex in graph  g . If  v  is specified, only return degrees for vertices in  v . For directed graphs, this value equals the incoming plus outgoing edges. For undirected graphs, it equals the connected edges.  source  #  LightGraphs.degree_histogram     Function .  degree_histogram(g, degfn=degree)  Return a Dict with values representing the number of vertices that have degree represented by the key.  Degree function (for example,  indegree  or  outdegree ) may be specified by overriding  degfn .  source  #  LightGraphs.density     Function .  density(g)  Return the density of  g . Density is defined as the ratio of the number of actual edges to the number of possible edges ($|V|\u00d7(|V|-1)$ for directed graphs and $\\frac{|V|\u00d7(|V|-1)}{2}$ for undirected graphs).  source  #  LightGraphs.has_self_loops     Method .  has_self_loops(g)  Return true if  g  has any self loops.  source  #  LightGraphs.indegree     Method .  indegree(g[, v])  Return a vector corresponding to the number of edges which end at each vertex in graph  g . If  v  is specified, only return degrees for vertices in  v .  source  #  LightGraphs.is_ordered     Method .  is_ordered(e)  Return true if the source vertex of edge  e  is less than or equal to the destination vertex.  source  #  LightGraphs.neighbors     Method .  neighbors(g, v)  Return a list of all neighbors reachable from vertex  v  in  g . For directed graphs, the default is equivalent to  out_neighbors ; use  all_neighbors  to list inbound and outbound neighbors.  Implementation Notes  Returns a reference, not a copy. Do not modify result.  source  #  LightGraphs.num_self_loops     Method .  num_self_loops(g)  Return the number of self loops in  g .  source  #  LightGraphs.outdegree     Method .  outdegree(g[, v])  Return a vector corresponding to the number of edges which start at each vertex in graph  g . If  v  is specified, only return degrees for vertices in  v .  source  #  LightGraphs.squash     Method .  squash(g)  Return a copy of a graph with the smallest practical type that can accommodate all vertices.  source  #  LightGraphs.\u0394     Method .  \u0394(g)  Return the maximum  degree  of vertices in  g .  source  #  LightGraphs.\u0394in     Method .  \u0394in(g)  Return the maximum  indegree  of vertices in  g .  source  #  LightGraphs.\u0394out     Method .  \u0394out(g)  Return the maximum  outdegree  of vertices in  g .  source  #  LightGraphs.\u03b4     Method .  \u03b4(g)  Return the minimum  degree  of vertices in  g .  source  #  LightGraphs.\u03b4in     Method .  \u03b4in(g)  Return the minimum  indegree  of vertices in  g .  source  #  LightGraphs.\u03b4out     Method .  \u03b4out(g)  Return the minimum  outdegree  of vertices in  g .  source  #  LightGraphs.isgraphical     Method .  isgraphical(degs)  Return true if the degree sequence  degs  is graphical, according to  Erd\u00f6s-Gallai condition .  Performance  Time complexity: ``\\mathcal{O}(|degs|^2)``  source  #  LightGraphs.neighborhood     Method .  neighborhood(g, v, d)  Return a vector of the vertices in  g  at a geodesic distance less or equal to  d  from  v .  Optional Arguments   dir=:out : If  g  is directed, this argument specifies the edge direction   with respect to  v  of the edges to be considered. Possible values:  :in  or  :out .  source", 
            "title": "Basic Functions"
        }, 
        {
            "location": "/operators/", 
            "text": "Operators\n\n\nLightGraphs.jl\n implements the following graph operators. In general, functions with two graph arguments will require them to be of the same type (either both \nGraph\n or both \nDiGraph\n).", 
            "title": "Operators"
        }, 
        {
            "location": "/operators/#operators", 
            "text": "LightGraphs.jl  implements the following graph operators. In general, functions with two graph arguments will require them to be of the same type (either both  Graph  or both  DiGraph ).", 
            "title": "Operators"
        }, 
        {
            "location": "/pathing/", 
            "text": "Path and Traversal\n\n\nLightGraphs.jl\n provides several traversal and shortest-path algorithms, along with various utility functions. Where appropriate, edge distances may be passed in as a matrix of real number values.\n\n\nEdge distances for most traversals may be passed in as a sparse or dense matrix of  values, indexed by \n[src,dst]\n vertices. That is, \ndistmx[2,4] = 2.5\n assigns the distance \n2.5\n to the (directed) edge connecting vertex 2 and vertex 4. Note that also for undirected graphs \ndistmx[4,2]\n has to be set.\n\n\nAny graph traversal  will traverse an edge only if it is present in the graph. When a distance matrix is passed in,\n\n\n\n\ndistance values for undefined edges will be ignored, and\n\n\nany unassigned values (in sparse distance matrices), for edges that are present in the graph, will be assumed to take the default value of 1.0.\n\n\nany zero values (in sparse/dense distance matrices), for edges that are present in the graph, will instead have an implicit edge cost of 1.0.\n\n\n\n\n\n\nGraph Traversal\n\n\nGraph traversal\n refers to a process that traverses vertices of a graph following certain order (starting from user-input sources). This package implements three traversal schemes:\n\n\n\n\nBreadthFirst\n,\n\n\nDepthFirst\n, and\n\n\nMaximumAdjacency\n.\n\n\n\n\n#\n\n\nLightGraphs.bfs_tree\n \n \nFunction\n.\n\n\nbfs_tree(g, s)\n\n\n\n\nProvide a breadth-first traversal of the graph \ng\n starting with source vertex \ns\n, and return a directed acyclic graph of vertices in the order they were discovered.\n\n\nImplementation Notes\n\n\nThis function is a high level wrapper around \nbfs_tree!\n; use that function for more performance.\n\n\nsource\n\n\nbfs_tree(LevelSynchronousBFS(), g, s, nv)\n\n\n\n\nProvide a parallel breadth-first traversal of the graph \ng\n starting with source vertex \ns\n, and return a directed acyclic graph of vertices in the order they were discovered using a frontier based parallel approach.\n\n\nImplementation Notes\n\n\nThis function uses \n@threads\n for parallelism which depends on the \nJULIA_NUM_THREADS\n environment variable to decide the number of threads to use. Refer \n@threads\n documentation for more details. This function is a high level wrapper around \nbfs_tree!\n; use that function for more performance.\n\n\nsource\n\n\n#\n\n\nLightGraphs.dfs_tree\n \n \nFunction\n.\n\n\ndfs_tree(g, s)\n\n\n\n\nReturn an ordered vector of vertices representing a directed acylic graph based on depth-first traversal of the graph \ng\n starting with source vertex \ns\n.\n\n\nsource\n\n\n#\n\n\nLightGraphs.maximum_adjacency_visit\n \n \nFunction\n.\n\n\nmaximum_adjacency_visit(g[, distmx][, log][, io])\n\n\n\n\nReturn the vertices in \ng\n traversed by maximum adjacency search. An optional \ndistmx\n matrix may be specified; if omitted, edge distances are assumed to be 1. If \nlog\n (default \nfalse\n) is \ntrue\n, visitor events will be printed to \nio\n, which defaults to \nSTDOUT\n; otherwise, no event information will be displayed.\n\n\nsource\n\n\n\n\nRandom walks\n\n\nLightGraphs\n includes uniform random walks and self avoiding walks:\n\n\n#\n\n\nLightGraphs.randomwalk\n \n \nFunction\n.\n\n\nrandomwalk(g, s, niter)\n\n\n\n\nPerform a random walk on graph \ng\n starting at vertex \ns\n and continuing for a maximum of \nniter\n steps. Return a vector of vertices visited in order.\n\n\nsource\n\n\n#\n\n\nLightGraphs.saw\n \n \nFunction\n.\n\n\nsaw(g, s, niter)\n\n\n\n\nPerform a \nself-avoiding walk\n on graph \ng\n starting at vertex \ns\n and continuing for a maximum of \nniter\n steps. Return a vector of vertices visited in order.\n\n\nsource\n\n\n\n\nConnectivity / Bipartiteness\n\n\nGraph connectivity\n functions are defined on both undirected and directed graphs:\n\n\nis_connected\nis_strongly_connected\nis_weakly_connected\nconnected_components\nstrongly_connected_components\nweakly_connected_components\nhas_self_loop\nattracting_components\nis_bipartite\ncondensation\nperiod\n\n\n\n\n\n\nCycle Detection\n\n\nIn graph theory, a cycle is defined to be a path that starts from some vertex \nv\n and ends up at \nv\n.\n\n\n#\n\n\nLightGraphs.is_cyclic\n \n \nFunction\n.\n\n\nis_cyclic(g)\n\n\n\n\nReturn \ntrue\n if graph \ng\n contains a cycle.\n\n\nImplementation Notes\n\n\nUses DFS.\n\n\nsource\n\n\n\n\nShortest-Path Algorithms\n\n\n\n\nGeneral properties of shortest path algorithms\n\n\n\n\nThe distance from a vertex to itself is always \n0\n.\n\n\nThe distance between two vertices with no connecting edge is always \nInf\n.\n\n\n\n\n#\n\n\nLightGraphs.a_star\n \n \nFunction\n.\n\n\na_star(g, s, t[, distmx][, heuristic])\n\n\n\n\nReturn a vector of edges comprising the shortest path between vertices \ns\n and \nt\n using the \nA* search algorithm\n. An optional heuristic function and edge distance matrix may be supplied. If missing, the distance matrix is set to \nDefaultDistance\n and the heuristic is set to \nn -\n 0\n.\n\n\nsource\n\n\n#\n\n\nLightGraphs.dijkstra_shortest_paths\n \n \nFunction\n.\n\n\ndijkstra_shortest_paths(g, srcs, distmx=DefaultDistance());\n\n\n\n\nPerform \nDijkstra's algorithm\n on a graph, computing shortest distances between \nsrcs\n and all other vertices. Return a \nDijkstraState\n that contains various traversal information.\n\n\nOptional Arguments\n\n\n\n\nallpaths=false\n: If true, returns a \nDijkstraState\n that keeps track of all\n\n\n\n\npredecessors of a given vertex.\n\n\nsource\n\n\n#\n\n\nLightGraphs.bellman_ford_shortest_paths\n \n \nFunction\n.\n\n\nbellman_ford_shortest_paths(g, s, distmx=DefaultDistance())\nbellman_ford_shortest_paths(g, ss, distmx=DefaultDistance())\n\n\n\n\nCompute shortest paths between a source \ns\n (or list of sources \nss\n) and all other nodes in graph \ng\n using the \nBellman-Ford algorithm\n. Return a \nBellmanFordState\n with relevant traversal information.\n\n\nsource\n\n\n#\n\n\nLightGraphs.floyd_warshall_shortest_paths\n \n \nFunction\n.\n\n\nfloyd_warshall_shortest_paths(g, distmx=DefaultDistance()) Use the \nFloyd-Warshall algorithm\n to compute the shortest paths between all pairs of vertices in graph \ng\n using an optional distance matrix \ndistmx\n. Return a \nFloydWarshallState\n with relevant traversal information.\n\n\nPerformance\n\n\nSpace complexity is on the order of $\\mathcal{O}(|V|^2)$.\n\n\nsource\n\n\n\n\nPath discovery / enumeration\n\n\n#\n\n\nLightGraphs.gdistances\n \n \nFunction\n.\n\n\ngdistances(g, source)\n\n\n\n\nReturn a vector filled with the geodesic distances of vertices in  \ng\n from \nsource\n. If \nsource\n is a collection of vertices each element should be unique. For vertices in disconnected components the default distance is -1.\n\n\nsource\n\n\n#\n\n\nLightGraphs.gdistances!\n \n \nFunction\n.\n\n\ngdistances!(g, source, dists)\n\n\n\n\nFill \ndists\n with the geodesic distances of vertices in \ng\n from \nsource\n. \ndists\n should be a vector of length \nnv(g)\n. Return \ndists\n. For vertices in disconnected components the default distance is -1.\n\n\nsource\n\n\n#\n\n\nLightGraphs.enumerate_paths\n \n \nFunction\n.\n\n\nenumerate_paths(state[, vs])\n\n\n\n\nGiven a path state \nstate\n of type \nAbstractPathState\n, return a vector (indexed by vertex) of the paths between the source vertex used to compute the path state and a single destination vertex, a list of destination vertices, or the entire graph. For multiple destination vertices, each path is represented by a vector of vertices on the path between the source and the destination. Nonexistent paths will be indicated by an empty vector. For single destinations, the path is represented by a single vector of vertices, and will be length 0 if the path does not exist.\n\n\nImplementation Notes\n\n\nFor Floyd-Warshall path states, please note that the output is a bit different, since this algorithm calculates all shortest paths for all pairs of vertices: \nenumerate_paths(state)\n will return a vector (indexed by source vertex) of vectors (indexed by destination vertex) of paths. \nenumerate_paths(state, v)\n will return a vector (indexed by destination vertex) of paths from source \nv\n to all other vertices. In addition, \nenumerate_paths(state, v, d)\n will return a vector representing the path from vertex \nv\n to vertex \nd\n.\n\n\nsource\n\n\nFor Floyd-Warshall path states, please note that the output is a bit different, since this algorithm calculates all shortest paths for all pairs of vertices: \nenumerate_paths(state)\n will return a vector (indexed by source vertex) of vectors (indexed by destination vertex) of paths. \nenumerate_paths(state, v)\n will return a vector (indexed by destination vertex) of paths from source \nv\n to all other vertices. In addition, \nenumerate_paths(state, v, d)\n will return a vector representing the path from vertex \nv\n to vertex \nd\n.\n\n\n\n\nPath States\n\n\nThe \nfloyd_warshall_shortest_paths\n, \nbellman_ford_shortest_paths\n, \ndijkstra_shortest_paths\n, and \ndijkstra_predecessor_and_distance\n functions return a state that contains various information about the graph learned during traversal. The three state types have the following common information, accessible via the type:\n\n\n.dists\n Holds a vector of distances computed, indexed by source vertex.\n\n\n.parents\n Holds a vector of parents of each source vertex. The parent of a source vertex is always \n0\n.\n\n\nIn addition, the \ndijkstra_predecessor_and_distance\n function stores the following information:\n\n\n.predecessors\n Holds a vector, indexed by vertex, of all the predecessors discovered during shortest-path calculations. This keeps track of all parents when there are multiple shortest paths available from the source.\n\n\n.pathcounts\n Holds a vector, indexed by vertex, of the path counts discovered during traversal. This equals the length of each subvector in the \n.predecessors\n output above.", 
            "title": "Path and Traversal"
        }, 
        {
            "location": "/pathing/#path-and-traversal", 
            "text": "LightGraphs.jl  provides several traversal and shortest-path algorithms, along with various utility functions. Where appropriate, edge distances may be passed in as a matrix of real number values.  Edge distances for most traversals may be passed in as a sparse or dense matrix of  values, indexed by  [src,dst]  vertices. That is,  distmx[2,4] = 2.5  assigns the distance  2.5  to the (directed) edge connecting vertex 2 and vertex 4. Note that also for undirected graphs  distmx[4,2]  has to be set.  Any graph traversal  will traverse an edge only if it is present in the graph. When a distance matrix is passed in,   distance values for undefined edges will be ignored, and  any unassigned values (in sparse distance matrices), for edges that are present in the graph, will be assumed to take the default value of 1.0.  any zero values (in sparse/dense distance matrices), for edges that are present in the graph, will instead have an implicit edge cost of 1.0.", 
            "title": "Path and Traversal"
        }, 
        {
            "location": "/pathing/#graph-traversal", 
            "text": "Graph traversal  refers to a process that traverses vertices of a graph following certain order (starting from user-input sources). This package implements three traversal schemes:   BreadthFirst ,  DepthFirst , and  MaximumAdjacency .   #  LightGraphs.bfs_tree     Function .  bfs_tree(g, s)  Provide a breadth-first traversal of the graph  g  starting with source vertex  s , and return a directed acyclic graph of vertices in the order they were discovered.  Implementation Notes  This function is a high level wrapper around  bfs_tree! ; use that function for more performance.  source  bfs_tree(LevelSynchronousBFS(), g, s, nv)  Provide a parallel breadth-first traversal of the graph  g  starting with source vertex  s , and return a directed acyclic graph of vertices in the order they were discovered using a frontier based parallel approach.  Implementation Notes  This function uses  @threads  for parallelism which depends on the  JULIA_NUM_THREADS  environment variable to decide the number of threads to use. Refer  @threads  documentation for more details. This function is a high level wrapper around  bfs_tree! ; use that function for more performance.  source  #  LightGraphs.dfs_tree     Function .  dfs_tree(g, s)  Return an ordered vector of vertices representing a directed acylic graph based on depth-first traversal of the graph  g  starting with source vertex  s .  source  #  LightGraphs.maximum_adjacency_visit     Function .  maximum_adjacency_visit(g[, distmx][, log][, io])  Return the vertices in  g  traversed by maximum adjacency search. An optional  distmx  matrix may be specified; if omitted, edge distances are assumed to be 1. If  log  (default  false ) is  true , visitor events will be printed to  io , which defaults to  STDOUT ; otherwise, no event information will be displayed.  source", 
            "title": "Graph Traversal"
        }, 
        {
            "location": "/pathing/#random-walks", 
            "text": "LightGraphs  includes uniform random walks and self avoiding walks:  #  LightGraphs.randomwalk     Function .  randomwalk(g, s, niter)  Perform a random walk on graph  g  starting at vertex  s  and continuing for a maximum of  niter  steps. Return a vector of vertices visited in order.  source  #  LightGraphs.saw     Function .  saw(g, s, niter)  Perform a  self-avoiding walk  on graph  g  starting at vertex  s  and continuing for a maximum of  niter  steps. Return a vector of vertices visited in order.  source", 
            "title": "Random walks"
        }, 
        {
            "location": "/pathing/#connectivity-bipartiteness", 
            "text": "Graph connectivity  functions are defined on both undirected and directed graphs:  is_connected\nis_strongly_connected\nis_weakly_connected\nconnected_components\nstrongly_connected_components\nweakly_connected_components\nhas_self_loop\nattracting_components\nis_bipartite\ncondensation\nperiod", 
            "title": "Connectivity / Bipartiteness"
        }, 
        {
            "location": "/pathing/#cycle-detection", 
            "text": "In graph theory, a cycle is defined to be a path that starts from some vertex  v  and ends up at  v .  #  LightGraphs.is_cyclic     Function .  is_cyclic(g)  Return  true  if graph  g  contains a cycle.  Implementation Notes  Uses DFS.  source", 
            "title": "Cycle Detection"
        }, 
        {
            "location": "/pathing/#shortest-path-algorithms", 
            "text": "", 
            "title": "Shortest-Path Algorithms"
        }, 
        {
            "location": "/pathing/#general-properties-of-shortest-path-algorithms", 
            "text": "The distance from a vertex to itself is always  0 .  The distance between two vertices with no connecting edge is always  Inf .   #  LightGraphs.a_star     Function .  a_star(g, s, t[, distmx][, heuristic])  Return a vector of edges comprising the shortest path between vertices  s  and  t  using the  A* search algorithm . An optional heuristic function and edge distance matrix may be supplied. If missing, the distance matrix is set to  DefaultDistance  and the heuristic is set to  n -  0 .  source  #  LightGraphs.dijkstra_shortest_paths     Function .  dijkstra_shortest_paths(g, srcs, distmx=DefaultDistance());  Perform  Dijkstra's algorithm  on a graph, computing shortest distances between  srcs  and all other vertices. Return a  DijkstraState  that contains various traversal information.  Optional Arguments   allpaths=false : If true, returns a  DijkstraState  that keeps track of all   predecessors of a given vertex.  source  #  LightGraphs.bellman_ford_shortest_paths     Function .  bellman_ford_shortest_paths(g, s, distmx=DefaultDistance())\nbellman_ford_shortest_paths(g, ss, distmx=DefaultDistance())  Compute shortest paths between a source  s  (or list of sources  ss ) and all other nodes in graph  g  using the  Bellman-Ford algorithm . Return a  BellmanFordState  with relevant traversal information.  source  #  LightGraphs.floyd_warshall_shortest_paths     Function .  floyd_warshall_shortest_paths(g, distmx=DefaultDistance()) Use the  Floyd-Warshall algorithm  to compute the shortest paths between all pairs of vertices in graph  g  using an optional distance matrix  distmx . Return a  FloydWarshallState  with relevant traversal information.  Performance  Space complexity is on the order of $\\mathcal{O}(|V|^2)$.  source", 
            "title": "General properties of shortest path algorithms"
        }, 
        {
            "location": "/pathing/#path-discovery-enumeration", 
            "text": "#  LightGraphs.gdistances     Function .  gdistances(g, source)  Return a vector filled with the geodesic distances of vertices in   g  from  source . If  source  is a collection of vertices each element should be unique. For vertices in disconnected components the default distance is -1.  source  #  LightGraphs.gdistances!     Function .  gdistances!(g, source, dists)  Fill  dists  with the geodesic distances of vertices in  g  from  source .  dists  should be a vector of length  nv(g) . Return  dists . For vertices in disconnected components the default distance is -1.  source  #  LightGraphs.enumerate_paths     Function .  enumerate_paths(state[, vs])  Given a path state  state  of type  AbstractPathState , return a vector (indexed by vertex) of the paths between the source vertex used to compute the path state and a single destination vertex, a list of destination vertices, or the entire graph. For multiple destination vertices, each path is represented by a vector of vertices on the path between the source and the destination. Nonexistent paths will be indicated by an empty vector. For single destinations, the path is represented by a single vector of vertices, and will be length 0 if the path does not exist.  Implementation Notes  For Floyd-Warshall path states, please note that the output is a bit different, since this algorithm calculates all shortest paths for all pairs of vertices:  enumerate_paths(state)  will return a vector (indexed by source vertex) of vectors (indexed by destination vertex) of paths.  enumerate_paths(state, v)  will return a vector (indexed by destination vertex) of paths from source  v  to all other vertices. In addition,  enumerate_paths(state, v, d)  will return a vector representing the path from vertex  v  to vertex  d .  source  For Floyd-Warshall path states, please note that the output is a bit different, since this algorithm calculates all shortest paths for all pairs of vertices:  enumerate_paths(state)  will return a vector (indexed by source vertex) of vectors (indexed by destination vertex) of paths.  enumerate_paths(state, v)  will return a vector (indexed by destination vertex) of paths from source  v  to all other vertices. In addition,  enumerate_paths(state, v, d)  will return a vector representing the path from vertex  v  to vertex  d .", 
            "title": "Path discovery / enumeration"
        }, 
        {
            "location": "/pathing/#path-states", 
            "text": "The  floyd_warshall_shortest_paths ,  bellman_ford_shortest_paths ,  dijkstra_shortest_paths , and  dijkstra_predecessor_and_distance  functions return a state that contains various information about the graph learned during traversal. The three state types have the following common information, accessible via the type:  .dists  Holds a vector of distances computed, indexed by source vertex.  .parents  Holds a vector of parents of each source vertex. The parent of a source vertex is always  0 .  In addition, the  dijkstra_predecessor_and_distance  function stores the following information:  .predecessors  Holds a vector, indexed by vertex, of all the predecessors discovered during shortest-path calculations. This keeps track of all parents when there are multiple shortest paths available from the source.  .pathcounts  Holds a vector, indexed by vertex, of the path counts discovered during traversal. This equals the length of each subvector in the  .predecessors  output above.", 
            "title": "Path States"
        }, 
        {
            "location": "/distance/", 
            "text": "Distance\n\n\nLightGraphs.jl\n includes the following distance measurements:\n\n\n#\n\n\nLightGraphs.BoundedMinkowskiCost\n \n \nMethod\n.\n\n\nBoundedMinkowskiCost(\u03bc\u2081, \u03bc\u2082)\n\n\n\n\nReturn value similar to \nMinkowskiCost\n, but ensure costs smaller than 2\u03c4.\n\n\nOptional Arguments\n\n\np=1\n: the p value for p-norm calculation. \n\u03c4=1\n: value specifying half of the upper limit of the Minkowski cost.\n\n\nsource\n\n\n#\n\n\nLightGraphs.MinkowskiCost\n \n \nMethod\n.\n\n\nMinkowskiCost(\u03bc\u2081, \u03bc\u2082; p::Real=1)\n\n\n\n\nFor labels \u03bc\u2081 on the vertices of graph G\u2081 and labels \u03bc\u2082 on the vertices of graph G\u2082, compute the p-norm cost of substituting vertex u \u2208 G\u2081 by vertex v \u2208 G\u2082.\n\n\nOptional Arguments\n\n\np=1\n: the p value for p-norm calculation.\n\n\nsource\n\n\n#\n\n\nLightGraphs.center\n \n \nMethod\n.\n\n\ncenter(g, distmx=DefaultDistance())\ncenter(eccentricities)\n\n\n\n\nGiven a graph and optional distance matrix, or a vector of precomputed eccentricities, return the set of all vertices whose eccentricity is equal to the graph's radius (that is, the set of vertices with the smallest eccentricity).\n\n\nsource\n\n\n#\n\n\nLightGraphs.diameter\n \n \nMethod\n.\n\n\ndiameter(g, distmx=DefaultDistance())\ndiameter(eccentricities)\n\n\n\n\nGiven a graph and optional distance matrix, or a vector of precomputed eccentricities, return the maximum eccentricity of the graph.\n\n\nsource\n\n\n#\n\n\nLightGraphs.eccentricity\n \n \nMethod\n.\n\n\neccentricity(g[, v][, distmx])\n\n\n\n\nReturn the eccentricity[ies] of a vertex / vertex list \nv\n or the entire graph. An optional matrix of edge distances may be supplied; if missing, edge distances default to \n1\n.\n\n\nThe eccentricity of a vertex is the maximum shortest-path distance between it and all other vertices in the graph.\n\n\nThe output is either a single float (when a single vertex is provided) or a vector of floats corresponding to the vertex vector. If no vertex vector is provided, the vector returned corresponds to each vertex in the graph.\n\n\nPerformance\n\n\nBecause this function must calculate shortest paths for all vertices supplied in the argument list, it may take a long time.\n\n\nImplementation Notes\n\n\nThe eccentricity vector returned by \neccentricity()\n may be used as input for the rest of the distance measures below. If an eccentricity vector is provided, it will be used. Otherwise, an eccentricity vector will be calculated for each call to the function. It may therefore be more efficient to calculate, store, and pass the eccentricities if multiple distance measures are desired.\n\n\nsource\n\n\n#\n\n\nLightGraphs.edit_distance\n \n \nMethod\n.\n\n\nedit_distance(G\u2081::AbstractGraph, G\u2082::AbstractGraph)\n\n\n\n\nCompute the edit distance between graphs \nG\u2081\n and \nG\u2082\n. Return the minimum edit cost and edit path to transform graph \nG\u2081\n into graph `G\u2082\n. An edit path consists of a sequence of pairs of vertices\n(u,v) \u2208 [0,|G\u2081|] \u00d7 [0,|G\u2082|]`` representing vertex operations:\n\n\n\n\n$(0,v)$: insertion of vertex $v \u2208 G\u2082$\n\n\n$(u,0)$: deletion of vertex $u \u2208 G\u2081$\n\n\n$(u\n0,v\n0)$: substitution of vertex $u \u2208 G\u2081$ by vertex $v \u2208 G\u2082$\n\n\n\n\nOptional Arguments\n\n\n\n\ninsert_cost::Function=v-\n1.0\n\n\ndelete_cost::Function=u-\n1.0\n\n\nsubst_cost::Function=(u,v)-\n0.5\n\n\n\n\nBy default, the algorithm uses constant operation costs. The user can provide classical Minkowski costs computed from vertex labels \u03bc\u2081 (for G\u2081) and \u03bc\u2082 (for G\u2082) in order to further guide the search, for example:\n\n\nedit_distance(G\u2081, G\u2082, subst_cost=MinkowskiCost(\u03bc\u2081, \u03bc\u2082))\n\n\n\n\n\n\nheuristic::Function=DefaultEditHeuristic\n: a custom heuristic provided to the A*\n\n\n\n\nsearch in case the default heuristic is not satisfactory.\n\n\nPerformance\n\n\n\n\nGiven two graphs $|G\u2081| \n |G\u2082|$, \nedit_distance(G\u2081, G\u2082)\n is faster to\n\n\n\n\ncompute than \nedit_distance(G\u2082, G\u2081)\n. Consider swapping the arguments if involved costs are equivalent.\n\n\n\n\nThe use of simple Minkowski costs can improve performance considerably.\n\n\nExploit vertex attributes when designing operation costs.\n\n\n\n\nReferences\n\n\n\n\nRIESEN, K., 2015. Structural Pattern Recognition with Graph Edit Distance: Approximation Algorithms and Applications. (Chapter 2)\n\n\n\n\nAuthor\n\n\n\n\nJ\u00falio Hoffimann Mendes (juliohm@stanford.edu)\n\n\n\n\nsource\n\n\n#\n\n\nLightGraphs.periphery\n \n \nMethod\n.\n\n\nperiphery(g, distmx=DefaultDistance())\nperiphery(eccentricities)\n\n\n\n\nGiven a graph and optional distance matrix, or a vector of precomputed eccentricities, return the set of all vertices whose eccentricity is equal to the graph's diameter (that is, the set of vertices with the largest eccentricity).\n\n\nsource\n\n\n#\n\n\nLightGraphs.radius\n \n \nMethod\n.\n\n\nradius(g, distmx=DefaultDistance())\nradius(eccentricities)\n\n\n\n\nGiven a graph and optional distance matrix, or a vector of precomputed eccentricities, return the minimum eccentricity of the graph.\n\n\nsource", 
            "title": "Distance"
        }, 
        {
            "location": "/distance/#distance", 
            "text": "LightGraphs.jl  includes the following distance measurements:  #  LightGraphs.BoundedMinkowskiCost     Method .  BoundedMinkowskiCost(\u03bc\u2081, \u03bc\u2082)  Return value similar to  MinkowskiCost , but ensure costs smaller than 2\u03c4.  Optional Arguments  p=1 : the p value for p-norm calculation.  \u03c4=1 : value specifying half of the upper limit of the Minkowski cost.  source  #  LightGraphs.MinkowskiCost     Method .  MinkowskiCost(\u03bc\u2081, \u03bc\u2082; p::Real=1)  For labels \u03bc\u2081 on the vertices of graph G\u2081 and labels \u03bc\u2082 on the vertices of graph G\u2082, compute the p-norm cost of substituting vertex u \u2208 G\u2081 by vertex v \u2208 G\u2082.  Optional Arguments  p=1 : the p value for p-norm calculation.  source  #  LightGraphs.center     Method .  center(g, distmx=DefaultDistance())\ncenter(eccentricities)  Given a graph and optional distance matrix, or a vector of precomputed eccentricities, return the set of all vertices whose eccentricity is equal to the graph's radius (that is, the set of vertices with the smallest eccentricity).  source  #  LightGraphs.diameter     Method .  diameter(g, distmx=DefaultDistance())\ndiameter(eccentricities)  Given a graph and optional distance matrix, or a vector of precomputed eccentricities, return the maximum eccentricity of the graph.  source  #  LightGraphs.eccentricity     Method .  eccentricity(g[, v][, distmx])  Return the eccentricity[ies] of a vertex / vertex list  v  or the entire graph. An optional matrix of edge distances may be supplied; if missing, edge distances default to  1 .  The eccentricity of a vertex is the maximum shortest-path distance between it and all other vertices in the graph.  The output is either a single float (when a single vertex is provided) or a vector of floats corresponding to the vertex vector. If no vertex vector is provided, the vector returned corresponds to each vertex in the graph.  Performance  Because this function must calculate shortest paths for all vertices supplied in the argument list, it may take a long time.  Implementation Notes  The eccentricity vector returned by  eccentricity()  may be used as input for the rest of the distance measures below. If an eccentricity vector is provided, it will be used. Otherwise, an eccentricity vector will be calculated for each call to the function. It may therefore be more efficient to calculate, store, and pass the eccentricities if multiple distance measures are desired.  source  #  LightGraphs.edit_distance     Method .  edit_distance(G\u2081::AbstractGraph, G\u2082::AbstractGraph)  Compute the edit distance between graphs  G\u2081  and  G\u2082 . Return the minimum edit cost and edit path to transform graph  G\u2081  into graph `G\u2082 . An edit path consists of a sequence of pairs of vertices (u,v) \u2208 [0,|G\u2081|] \u00d7 [0,|G\u2082|]`` representing vertex operations:   $(0,v)$: insertion of vertex $v \u2208 G\u2082$  $(u,0)$: deletion of vertex $u \u2208 G\u2081$  $(u 0,v 0)$: substitution of vertex $u \u2208 G\u2081$ by vertex $v \u2208 G\u2082$   Optional Arguments   insert_cost::Function=v- 1.0  delete_cost::Function=u- 1.0  subst_cost::Function=(u,v)- 0.5   By default, the algorithm uses constant operation costs. The user can provide classical Minkowski costs computed from vertex labels \u03bc\u2081 (for G\u2081) and \u03bc\u2082 (for G\u2082) in order to further guide the search, for example:  edit_distance(G\u2081, G\u2082, subst_cost=MinkowskiCost(\u03bc\u2081, \u03bc\u2082))   heuristic::Function=DefaultEditHeuristic : a custom heuristic provided to the A*   search in case the default heuristic is not satisfactory.  Performance   Given two graphs $|G\u2081|   |G\u2082|$,  edit_distance(G\u2081, G\u2082)  is faster to   compute than  edit_distance(G\u2082, G\u2081) . Consider swapping the arguments if involved costs are equivalent.   The use of simple Minkowski costs can improve performance considerably.  Exploit vertex attributes when designing operation costs.   References   RIESEN, K., 2015. Structural Pattern Recognition with Graph Edit Distance: Approximation Algorithms and Applications. (Chapter 2)   Author   J\u00falio Hoffimann Mendes (juliohm@stanford.edu)   source  #  LightGraphs.periphery     Method .  periphery(g, distmx=DefaultDistance())\nperiphery(eccentricities)  Given a graph and optional distance matrix, or a vector of precomputed eccentricities, return the set of all vertices whose eccentricity is equal to the graph's diameter (that is, the set of vertices with the largest eccentricity).  source  #  LightGraphs.radius     Method .  radius(g, distmx=DefaultDistance())\nradius(eccentricities)  Given a graph and optional distance matrix, or a vector of precomputed eccentricities, return the minimum eccentricity of the graph.  source", 
            "title": "Distance"
        }, 
        {
            "location": "/centrality/", 
            "text": "Centrality Measures\n\n\nCentrality measures\n describe the importance of a vertex to the rest of the graph using some set of criteria. Centrality measures implemented in \nLightGraphs.jl\n include the following:\n\n\n\n\nLightGraphs.betweenness_centrality\n\n\nLightGraphs.closeness_centrality\n\n\nLightGraphs.degree_centrality\n\n\nLightGraphs.eigenvector_centrality\n\n\nLightGraphs.katz_centrality\n\n\nLightGraphs.pagerank\n\n\n\n\n#\n\n\nLightGraphs.betweenness_centrality\n \n \nFunction\n.\n\n\nbetweenness_centrality(g[, vs])\nbetweenness_centrality(g, k)\n\n\n\n\nCalculate the \nbetweenness centrality\n of a graph \ng\n across all vertices, a specified subset of vertices \nvs\n, or a random subset of \nk\n vertices. Return a vector representing the centrality calculated for each node in \ng\n.\n\n\nOptional Arguments\n\n\n\n\nnormalize=true\n: If true, normalize the betweenness values by the\n\n\n\n\ntotal number of possible distinct paths between all pairsin the graphs. For an undirected graph, this number is $\\frac{(|V|-1)(|V|-2)}{2}$ and for a directed graph, ${(|V|-1)(|V|-2)}$.\n\n\n\n\nendpoints=false\n: If true, include endpoints in the shortest path count.\n\n\n\n\nBetweenness centrality is defined as: $bc(v) = \\frac{1}{\\mathcal{N}} sum_{s \\neq t \\neq v} \\frac{\\sigma_{st}(v)}{\\sigma_{st}}$.\n\n\nReferences\n\n\n\n\nBrandes 2001 \n Brandes 2008\n\n\n\n\nsource\n\n\n#\n\n\nLightGraphs.closeness_centrality\n \n \nMethod\n.\n\n\ncloseness_centrality(g)\n\n\n\n\nCalculate the \ncloseness centrality\n of the graph \ng\n. Return a vector representing the centrality calculated for each node in \ng\n.\n\n\nOptional Arguments\n\n\n\n\nnormalize=true\n: If true, normalize the centrality value of each\n\n\n\n\nnode \nn\n by $\\frac{|\u03b4_n|}{|V|-1}$, where $\u03b4_n$ is the set of vertices reachable from node \nn\n.\n\n\nsource\n\n\n#\n\n\nLightGraphs.degree_centrality\n \n \nMethod\n.\n\n\ndegree_centrality(g)\nindegree_centrality(g)\noutdegree_centrality(g)\n\n\n\n\nCalculate the \ndegree centrality\n of graph \ng\n. Return a vector representing the centrality calculated for each node in \ng\n.\n\n\nOptional Arguments\n\n\n\n\nnormalize=true\n: If true, normalize each centrality measure by $\\frac{1}{|V|-1}$.\n\n\n\n\nsource\n\n\n#\n\n\nLightGraphs.eigenvector_centrality\n \n \nMethod\n.\n\n\neigenvector_centrality(g)\n\n\n\n\nCompute the eigenvector centrality for the graph \ng\n.\n\n\nEigenvector centrality computes the centrality for a node based on the centrality of its neighbors. The eigenvector centrality for node \ni\n is\n\n\n``mathbf{Ax} = lambda mathbf{x}``\n\n\n\n\nwhere \nA\n is the adjacency matrix of the graph \ng\n with eigenvalue \nlambda\n. By virtue of the Perron\u2013Frobenius theorem, there is a unique and positive solution if \nlambda\n is the largest eigenvalue associated with the eigenvector of the adjacency matrix \nA\n.\n\n\nReferences\n\n\n\n\nPhillip Bonacich: Power and Centrality: A Family of Measures.   American Journal of Sociology 92(5):1170\u20131182, 1986   http://www.leonidzhukov.net/hse/2014/socialnetworks/papers/Bonacich-Centrality.pdf\n\n\nMark E. J. Newman: Networks: An Introduction.      Oxford University Press, USA, 2010, pp. 169.\n\n\n\n\nsource\n\n\n#\n\n\nLightGraphs.katz_centrality\n \n \nFunction\n.\n\n\nkatz_centrality(g, \u03b1=0.3)\n\n\n\n\nCalculate the \nKatz centrality\n of the graph \ng\n optionally parameterized by \n\u03b1\n. Return a vector representing the centrality calculated for each node in \ng\n.\n\n\nsource\n\n\n#\n\n\nLightGraphs.pagerank\n \n \nFunction\n.\n\n\npagerank(g, \u03b1=0.85, n=100, \u03f5=1.0e-6)\n\n\n\n\nCalculate the \nPageRank\n of the directed graph \ng\n parameterized by damping factor \n\u03b1\n, number of iterations \nn\n, and convergence threshold \n\u03f5\n. Return a vector representing the centrality calculated for each node in \ng\n, or an error if convergence is not reached within \nn\n iterations.\n\n\nsource", 
            "title": "Centrality Measures"
        }, 
        {
            "location": "/centrality/#centrality-measures", 
            "text": "Centrality measures  describe the importance of a vertex to the rest of the graph using some set of criteria. Centrality measures implemented in  LightGraphs.jl  include the following:   LightGraphs.betweenness_centrality  LightGraphs.closeness_centrality  LightGraphs.degree_centrality  LightGraphs.eigenvector_centrality  LightGraphs.katz_centrality  LightGraphs.pagerank   #  LightGraphs.betweenness_centrality     Function .  betweenness_centrality(g[, vs])\nbetweenness_centrality(g, k)  Calculate the  betweenness centrality  of a graph  g  across all vertices, a specified subset of vertices  vs , or a random subset of  k  vertices. Return a vector representing the centrality calculated for each node in  g .  Optional Arguments   normalize=true : If true, normalize the betweenness values by the   total number of possible distinct paths between all pairsin the graphs. For an undirected graph, this number is $\\frac{(|V|-1)(|V|-2)}{2}$ and for a directed graph, ${(|V|-1)(|V|-2)}$.   endpoints=false : If true, include endpoints in the shortest path count.   Betweenness centrality is defined as: $bc(v) = \\frac{1}{\\mathcal{N}} sum_{s \\neq t \\neq v} \\frac{\\sigma_{st}(v)}{\\sigma_{st}}$.  References   Brandes 2001   Brandes 2008   source  #  LightGraphs.closeness_centrality     Method .  closeness_centrality(g)  Calculate the  closeness centrality  of the graph  g . Return a vector representing the centrality calculated for each node in  g .  Optional Arguments   normalize=true : If true, normalize the centrality value of each   node  n  by $\\frac{|\u03b4_n|}{|V|-1}$, where $\u03b4_n$ is the set of vertices reachable from node  n .  source  #  LightGraphs.degree_centrality     Method .  degree_centrality(g)\nindegree_centrality(g)\noutdegree_centrality(g)  Calculate the  degree centrality  of graph  g . Return a vector representing the centrality calculated for each node in  g .  Optional Arguments   normalize=true : If true, normalize each centrality measure by $\\frac{1}{|V|-1}$.   source  #  LightGraphs.eigenvector_centrality     Method .  eigenvector_centrality(g)  Compute the eigenvector centrality for the graph  g .  Eigenvector centrality computes the centrality for a node based on the centrality of its neighbors. The eigenvector centrality for node  i  is  ``mathbf{Ax} = lambda mathbf{x}``  where  A  is the adjacency matrix of the graph  g  with eigenvalue  lambda . By virtue of the Perron\u2013Frobenius theorem, there is a unique and positive solution if  lambda  is the largest eigenvalue associated with the eigenvector of the adjacency matrix  A .  References   Phillip Bonacich: Power and Centrality: A Family of Measures.   American Journal of Sociology 92(5):1170\u20131182, 1986   http://www.leonidzhukov.net/hse/2014/socialnetworks/papers/Bonacich-Centrality.pdf  Mark E. J. Newman: Networks: An Introduction.      Oxford University Press, USA, 2010, pp. 169.   source  #  LightGraphs.katz_centrality     Function .  katz_centrality(g, \u03b1=0.3)  Calculate the  Katz centrality  of the graph  g  optionally parameterized by  \u03b1 . Return a vector representing the centrality calculated for each node in  g .  source  #  LightGraphs.pagerank     Function .  pagerank(g, \u03b1=0.85, n=100, \u03f5=1.0e-6)  Calculate the  PageRank  of the directed graph  g  parameterized by damping factor  \u03b1 , number of iterations  n , and convergence threshold  \u03f5 . Return a vector representing the centrality calculated for each node in  g , or an error if convergence is not reached within  n  iterations.  source", 
            "title": "Centrality Measures"
        }, 
        {
            "location": "/linalg/", 
            "text": "Linear Algebra\n\n\nLightGraphs.jl\n provides the following matrix operations on both directed and undirected graphs in the \nLinAlg\n submodule:\n\n\n#\n\n\nLightGraphs.adjacency_matrix\n \n \nFunction\n.\n\n\nadjacency_matrix(g, dir=:out, T=Int)\n\n\n\n\nReturn a sparse adjacency matrix for a graph, indexed by \n[u, v]\n vertices. Non-zero values indicate an edge between \nu\n and \nv\n. Users may specify a direction (\n:in\n, \n:out\n, or \n:both\n are currently supported; \n:out\n is default for both directed and undirected graphs) and a data type for the matrix (defaults to \nInt\n).\n\n\nImplementation Notes\n\n\nThis function is optimized for speed and directly manipulates CSC sparse matrix fields.\n\n\nsource\n\n\n#\n\n\nLightGraphs.adjacency_spectrum\n \n \nFunction\n.\n\n\nReturn the eigenvalues of the adjacency matrix for a graph \ng\n, indexed by vertex. Default values for \ndir\n and \nT\n are the same as those in \nadjacency_matrix\n.\n\n\nPerformance\n\n\nConverts the matrix to dense with $nv^2$ memory usage.\n\n\nImplementation Notes\n\n\nUse \neigs(adjacency_matrix(g);  kwargs...)\n to compute some of the eigenvalues/eigenvectors.\n\n\nsource\n\n\n#\n\n\nLightGraphs.incidence_matrix\n \n \nFunction\n.\n\n\nincidence_matrix(g, T=Int)\n\n\n\n\nReturn a sparse node-arc incidence matrix for a graph, indexed by \n[v, i]\n, where \ni\n is in \n1:ne(g)\n, indexing an edge \ne\n. For directed graphs, a value of \n-1\n indicates that \nsrc(e) == v\n, while a value of \n1\n indicates that \ndst(e) == v\n. Otherwise, the value is \n0\n. For undirected graphs, both entries are \n1\n by default (this behavior can be overridden by the \noriented\n optional argument).\n\n\nOptional Arguments\n\n\n\n\noriented=false\n: If true, for an undirected graph \ng\n, the matrix will\n\n\n\n\ncontain arbitrary non-zero values representing connectivity between \nv\n and \ni\n.\n\n\nsource\n\n\n#\n\n\nLightGraphs.laplacian_matrix\n \n \nFunction\n.\n\n\nlaplacian_matrix(g, dir=:unspec, T=Int)\n\n\n\n\nReturn a sparse \nLaplacian matrix\n for a graph \ng\n, indexed by \n[u, v]\n vertices. For undirected graphs, \ndir\n defaults to \n:out\n; for directed graphs, \ndir\n defaults to \n:both\n. \nT\n defaults to \nInt\n for both graph types.\n\n\nsource\n\n\n#\n\n\nLightGraphs.laplacian_spectrum\n \n \nFunction\n.\n\n\nlaplacian_spectrum(g, dir=:unspec, T=Int)\n\n\n\n\nReturn the eigenvalues of the Laplacian matrix for a graph \ng\n, indexed by vertex. Default values for \ndir\n and \nT\n are the same as those in \nlaplacian_matrix\n.\n\n\nPerformance\n\n\nConverts the matrix to dense with $nv^2$ memory usage.\n\n\nImplementation Notes\n\n\nUse \neigs(laplacian_matrix(g);  kwargs...)\n to compute some of the eigenvalues/eigenvectors.\n\n\nsource\n\n\n#\n\n\nLightGraphs.spectral_distance\n \n \nFunction\n.\n\n\nspectral_distance(G\u2081, G\u2082 [, k])\n\n\n\n\nCompute the spectral distance between undirected n-vertex graphs \nG\u2081\n and \nG\u2082\n using the top \nk\n greatest eigenvalues. If \nk\n is ommitted, uses full spectrum.\n\n\nReferences\n\n\n\n\nJOVANOVIC, I.; STANIC, Z., 2014. Spectral Distances of Graphs Based on their Different Matrix Representations\n\n\n\n\nsource", 
            "title": "Linear Algebra"
        }, 
        {
            "location": "/linalg/#linear-algebra", 
            "text": "LightGraphs.jl  provides the following matrix operations on both directed and undirected graphs in the  LinAlg  submodule:  #  LightGraphs.adjacency_matrix     Function .  adjacency_matrix(g, dir=:out, T=Int)  Return a sparse adjacency matrix for a graph, indexed by  [u, v]  vertices. Non-zero values indicate an edge between  u  and  v . Users may specify a direction ( :in ,  :out , or  :both  are currently supported;  :out  is default for both directed and undirected graphs) and a data type for the matrix (defaults to  Int ).  Implementation Notes  This function is optimized for speed and directly manipulates CSC sparse matrix fields.  source  #  LightGraphs.adjacency_spectrum     Function .  Return the eigenvalues of the adjacency matrix for a graph  g , indexed by vertex. Default values for  dir  and  T  are the same as those in  adjacency_matrix .  Performance  Converts the matrix to dense with $nv^2$ memory usage.  Implementation Notes  Use  eigs(adjacency_matrix(g);  kwargs...)  to compute some of the eigenvalues/eigenvectors.  source  #  LightGraphs.incidence_matrix     Function .  incidence_matrix(g, T=Int)  Return a sparse node-arc incidence matrix for a graph, indexed by  [v, i] , where  i  is in  1:ne(g) , indexing an edge  e . For directed graphs, a value of  -1  indicates that  src(e) == v , while a value of  1  indicates that  dst(e) == v . Otherwise, the value is  0 . For undirected graphs, both entries are  1  by default (this behavior can be overridden by the  oriented  optional argument).  Optional Arguments   oriented=false : If true, for an undirected graph  g , the matrix will   contain arbitrary non-zero values representing connectivity between  v  and  i .  source  #  LightGraphs.laplacian_matrix     Function .  laplacian_matrix(g, dir=:unspec, T=Int)  Return a sparse  Laplacian matrix  for a graph  g , indexed by  [u, v]  vertices. For undirected graphs,  dir  defaults to  :out ; for directed graphs,  dir  defaults to  :both .  T  defaults to  Int  for both graph types.  source  #  LightGraphs.laplacian_spectrum     Function .  laplacian_spectrum(g, dir=:unspec, T=Int)  Return the eigenvalues of the Laplacian matrix for a graph  g , indexed by vertex. Default values for  dir  and  T  are the same as those in  laplacian_matrix .  Performance  Converts the matrix to dense with $nv^2$ memory usage.  Implementation Notes  Use  eigs(laplacian_matrix(g);  kwargs...)  to compute some of the eigenvalues/eigenvectors.  source  #  LightGraphs.spectral_distance     Function .  spectral_distance(G\u2081, G\u2082 [, k])  Compute the spectral distance between undirected n-vertex graphs  G\u2081  and  G\u2082  using the top  k  greatest eigenvalues. If  k  is ommitted, uses full spectrum.  References   JOVANOVIC, I.; STANIC, Z., 2014. Spectral Distances of Graphs Based on their Different Matrix Representations   source", 
            "title": "Linear Algebra"
        }, 
        {
            "location": "/matching/", 
            "text": "Matching\n\n\nMaximum weight matching is supported in the companion package \nLightGraphsExtras.jl\n.", 
            "title": "Matching"
        }, 
        {
            "location": "/matching/#matching", 
            "text": "Maximum weight matching is supported in the companion package  LightGraphsExtras.jl .", 
            "title": "Matching"
        }, 
        {
            "location": "/community/", 
            "text": "Community Structures\n\n\nLightGraphs.jl\n contains many algorithm to detect and analyze community structures in graphs.", 
            "title": "Community Structures"
        }, 
        {
            "location": "/community/#community-structures", 
            "text": "LightGraphs.jl  contains many algorithm to detect and analyze community structures in graphs.", 
            "title": "Community Structures"
        }, 
        {
            "location": "/flowcut/", 
            "text": "Flow and Cut\n\n\nLightGraphs.jl\n provides different algorithms for \nmaximum flow\n and minimum cut computations.\n\n\n#\n\n\nLightGraphs\n \n \nModule\n.\n\n\nLightGraphs\n\n\n\n\nAn optimized graphs package.\n\n\nSimple graphs (not multi- or hypergraphs) are represented in a memory- and time-efficient manner with adjacency lists and edge sets. Both directed and undirected graphs are supported via separate types, and conversion is available from directed to undirected.\n\n\nThe project goal is to mirror the functionality of robust network and graph analysis libraries such as NetworkX while being simpler to use and more efficient than existing Julian graph libraries such as Graphs.jl. It is an explicit design decision that any data not required for graph manipulation (attributes and other information, for example) is expected to be stored outside of the graph structure itself. Such data lends itself to storage in more traditional and better-optimized mechanisms.\n\n\nFull documentation\n is available, and tutorials are available at the \nJuliaGraphsTutorials repository\n.\n\n\nsource\n\n\n#\n\n\nLightGraphs.Nonbacktracking\n \n \nType\n.\n\n\nNonbacktracking{G}\n\n\n\n\nA compact representation of the nonbacktracking operator.\n\n\nThe Nonbacktracking operator can be used for community detection. This representation is compact in that it uses only ne(g) additional storage and provides an implicit representation of the matrix B_g defined below.\n\n\nGiven two arcs $A_{i j}\nand\nA_{k l}\nin\ng`, the non-backtraking matrix$B`` is defined as\n\n\n$B_{A_{i j}, A_{k l}} = \u03b4_{j k} * (1 - \u03b4_{i l})$\n\n\nThis type is in the style of GraphMatrices.jl and supports the necessary operations for computed eigenvectors and conducting linear solves.\n\n\nAdditionally the \ncontract!(vertexspace, nbt, edgespace)\n method takes vectors represented in the domain of $B$ and represents them in the domain of the adjacency matrix of \ng\n.\n\n\nsource\n\n\n#\n\n\nLightGraphs.AbstractEdge\n \n \nType\n.\n\n\nAbstractEdge\n\n\n\n\nAn absract type representing a single edge between two vertices of a graph.\n\n\nsource\n\n\n#\n\n\nLightGraphs.AbstractGraph\n \n \nType\n.\n\n\nAbstractGraph\n\n\n\n\nAn abstract type representing a graph.\n\n\nsource\n\n\n#\n\n\nLightGraphs.BoykovKolmogorovAlgorithm\n \n \nType\n.\n\n\nBoykovKolmogorovAlgorithm \n: AbstractFlowAlgorithm\n\n\n\n\nForces the maximum_flow function to use the Boykov-Kolmogorov algorithm.\n\n\nsource\n\n\n#\n\n\nLightGraphs.BreadthFirst\n \n \nType\n.\n\n\nBreadthFirst\n\n\n\n\nConventions in Breadth First Search and Depth First Search\n\n\nVertexColorMap\n\n\n\n\ncolor == 0    =\n unseen\n\n\ncolor \n 0     =\n examined but not closed\n\n\ncolor \n 0     =\n examined and closed\n\n\n\n\nEdgeColorMap\n\n\n\n\ncolor == 0    =\n unseen\n\n\ncolor == 1    =\n examined\n\n\n\n\nsource\n\n\n#\n\n\nLightGraphs.DepthFirst\n \n \nType\n.\n\n\nDepthFirst\n\n\n\n\nConventions in Breadth First Search and Depth First Search\n\n\nVertexColorMap\n\n\n\n\ncolor == 0    =\n unseen\n\n\ncolor \n 0     =\n examined but not closed\n\n\ncolor \n 0     =\n examined and closed\n\n\n\n\nEdgeColorMap\n\n\n\n\ncolor == 0    =\n unseen\n\n\ncolor == 1     =\n examined\n\n\n\n\nsource\n\n\n#\n\n\nLightGraphs.DinicAlgorithm\n \n \nType\n.\n\n\nDinicAlgorithm \n: AbstractFlowAlgorithm\n\n\n\n\nForces the maximum_flow function to use Dinic's algorithm.\n\n\nsource\n\n\n#\n\n\nLightGraphs.EdmondsKarpAlgorithm\n \n \nType\n.\n\n\nEdmondsKarpAlgorithm \n: AbstractFlowAlgorithm\n\n\n\n\nForces the maximum_flow function to use the Edmonds\u2013Karp algorithm.\n\n\nsource\n\n\n#\n\n\nLightGraphs.ExtendedMultirouteFlowAlgorithm\n \n \nType\n.\n\n\nExtendedMultirouteFlowAlgorithm\n\n\n\n\nUsed to specify the Extended Multiroute Flow algorithm.\n\n\nsource\n\n\n#\n\n\nLightGraphs.KishimotoAlgorithm\n \n \nType\n.\n\n\nKishimotoAlgorithm\n\n\n\n\nUsed to specify the Kishimoto algorithm.\n\n\nsource\n\n\n#\n\n\nLightGraphs.PushRelabelAlgorithm\n \n \nType\n.\n\n\nForces the maximum_flow function to use the Push-Relabel algorithm.\n\n\nsource\n\n\n#\n\n\nBase.SparseArrays.blkdiag\n \n \nMethod\n.\n\n\nblkdiag(g, h)\n\n\n\n\nReturn a graph with $|V(g)| + |V(h)|$ vertices and $|E(g)| + |E(h)|$ edges where the vertices an edges from graph \nh\n are appended to graph \ng\n.\n\n\nImplementation Notes\n\n\nPreserves the eltype of the input graph. Will error if the number of vertices in the generated graph exceeds the eltype.\n\n\nsource\n\n\n#\n\n\nBase.intersect\n \n \nMethod\n.\n\n\nintersect(g, h)\n\n\n\n\nReturn a graph with edges that are only in both graph \ng\n and graph \nh\n.\n\n\nImplementation Notes\n\n\nThis function may produce a graph with 0-degree vertices. Preserves the eltype of the input graph.\n\n\nsource\n\n\n#\n\n\nBase.join\n \n \nMethod\n.\n\n\njoin(g, h)\n\n\n\n\nReturn a graph that combines graphs \ng\n and \nh\n using \nblkdiag\n and then adds all the edges between the vertices in \ng\n and those in \nh\n.\n\n\nImplementation Notes\n\n\nPreserves the eltype of the input graph. Will error if the number of vertices in the generated graph exceeds the eltype.\n\n\nsource\n\n\n#\n\n\nBase.reverse\n \n \nFunction\n.\n\n\nreverse(g)\n\n\n\n\nReturn a directed graph where all edges are reversed from the original directed graph.\n\n\nImplementation Notes\n\n\nPreserves the eltype of the input graph.\n\n\nsource\n\n\n#\n\n\nBase.reverse!\n \n \nFunction\n.\n\n\nreverse!(g)\n\n\n\n\nIn-place reverse of a directed graph (modifies the original graph).\n\n\nsource\n\n\n#\n\n\nBase.reverse\n \n \nMethod\n.\n\n\nreverse(e)\n\n\n\n\nCreate a new edge from \ne\n with source and destination vertices reversed.\n\n\nsource\n\n\n#\n\n\nBase.union\n \n \nMethod\n.\n\n\nunion(g, h)\n\n\n\n\nReturn a graph that combines graphs \ng\n and \nh\n by taking the set union of all vertices and edges.\n\n\nImplementation Notes\n\n\nPreserves the eltype of the input graph. Will error if the number of vertices in the generated graph exceeds the eltype.\n\n\nsource\n\n\n#\n\n\nLightGraphs.a_star\n \n \nMethod\n.\n\n\na_star(g, s, t[, distmx][, heuristic])\n\n\n\n\nReturn a vector of edges comprising the shortest path between vertices \ns\n and \nt\n using the \nA* search algorithm\n. An optional heuristic function and edge distance matrix may be supplied. If missing, the distance matrix is set to \nDefaultDistance\n and the heuristic is set to \nn -\n 0\n.\n\n\nsource\n\n\n#\n\n\nLightGraphs.add_edge!\n \n \nMethod\n.\n\n\nadd_edge!(g, e)\n\n\n\n\nAdd a new edge \ne\n to \ng\n. Return false if add fails (e.g., if vertices are not in the graph, or edge already exists), true otherwise.\n\n\nsource\n\n\n#\n\n\nLightGraphs.add_vertex!\n \n \nMethod\n.\n\n\nadd_vertex!(g)\n\n\n\n\nAdd a new vertex to the graph \ng\n. Return true if the vertex was added successfully, false otherwise.\n\n\nsource\n\n\n#\n\n\nLightGraphs.articulation\n \n \nMethod\n.\n\n\narticulation(g)\n\n\n\n\nCompute the \narticulation points\n of a connected graph \ng\n and return an array containing all cut vertices.\n\n\nsource\n\n\n#\n\n\nLightGraphs.bellman_ford_shortest_paths\n \n \nMethod\n.\n\n\nbellman_ford_shortest_paths(g, s, distmx=DefaultDistance())\nbellman_ford_shortest_paths(g, ss, distmx=DefaultDistance())\n\n\n\n\nCompute shortest paths between a source \ns\n (or list of sources \nss\n) and all other nodes in graph \ng\n using the \nBellman-Ford algorithm\n. Return a \nBellmanFordState\n with relevant traversal information.\n\n\nsource\n\n\n#\n\n\nLightGraphs.bfs_tree\n \n \nMethod\n.\n\n\nbfs_tree(g, s)\n\n\n\n\nProvide a breadth-first traversal of the graph \ng\n starting with source vertex \ns\n, and return a directed acyclic graph of vertices in the order they were discovered.\n\n\nImplementation Notes\n\n\nThis function is a high level wrapper around \nbfs_tree!\n; use that function for more performance.\n\n\nsource\n\n\n#\n\n\nLightGraphs.bfs_tree\n \n \nMethod\n.\n\n\nbfs_tree(LevelSynchronousBFS(), g, s, nv)\n\n\n\n\nProvide a parallel breadth-first traversal of the graph \ng\n starting with source vertex \ns\n, and return a directed acyclic graph of vertices in the order they were discovered using a frontier based parallel approach.\n\n\nImplementation Notes\n\n\nThis function uses \n@threads\n for parallelism which depends on the \nJULIA_NUM_THREADS\n environment variable to decide the number of threads to use. Refer \n@threads\n documentation for more details. This function is a high level wrapper around \nbfs_tree!\n; use that function for more performance.\n\n\nsource\n\n\n#\n\n\nLightGraphs.biconnected_components\n \n \nFunction\n.\n\n\nbiconnected_components(g)\n\n\n\n\nCompute the \nbiconnected components\n of an undirected graph \ng\nand return a vector of vectors containing each biconnected component.\n\n\nPerformance: Time complexity is $\\mathcal{O}(|V|)$.\n\n\nsource\n\n\n#\n\n\nLightGraphs.bipartite_map\n \n \nMethod\n.\n\n\nbipartite_map(g)\n\n\n\n\nFor a bipartite graph \ng\n, return a vector \nc\n of size $|V|$ containing the assignment of each vertex to one of the two sets ($c_i == 1$ or c_i == 2\n`). If\ng` is not bipartite, return an empty vector.\n\n\nsource\n\n\n#\n\n\nLightGraphs.cartesian_product\n \n \nMethod\n.\n\n\ncartesian_product(g, h)\n\n\n\n\nReturn the (cartesian product)[https://en.wikipedia.org/wiki/Tensor_product_of_graphs] of \ng\n and \nh\n.\n\n\nImplementation Notes\n\n\nPreserves the eltype of the input graph. Will error if the number of vertices in the generated graph exceeds the eltype.\n\n\nsource\n\n\n#\n\n\nLightGraphs.complement\n \n \nMethod\n.\n\n\ncomplement(g)\n\n\n\n\nReturn the \ngraph complement\n of a graph\n\n\nImplementation Notes\n\n\nPreserves the eltype of the input graph.\n\n\nsource\n\n\n#\n\n\nLightGraphs.contract!\n \n \nMethod\n.\n\n\ncontract!(vertexspace, nbt, edgespace)\n\n\n\n\nThe mutating version of \ncontract(nbt, edgespace)\n. Modifies \nvertexspace\n.\n\n\nsource\n\n\n#\n\n\nLightGraphs.contract\n \n \nMethod\n.\n\n\ncontract(nbt, edgespace)\n\n\n\n\nIntegrate out the edges by summing over the edges incident to each vertex.\n\n\nsource\n\n\n#\n\n\nLightGraphs.core_periphery_deg\n \n \nFunction\n.\n\n\ncore_periphery_deg(g)\n\n\n\n\nCompute the degree-based core-periphery for graph \ng\n. Return the vertex assignments (\n1\n for core and \n2\n for periphery) for each node in \ng\n.\n\n\nReferences:     \nLip\n)\n\n\nsource\n\n\n#\n\n\nLightGraphs.crosspath\n \n \nFunction\n.\n\n\ncrosspath(len::Integer, g::Graph)\n\n\n\n\nReturn a graph that duplicates \ng\n \nlen\n times and connects each vertex with its copies in a path.\n\n\nImplementation Notes\n\n\nPreserves the eltype of the input graph. Will error if the number of vertices in the generated graph exceeds the eltype.\n\n\nsource\n\n\n#\n\n\nLightGraphs.dfs_tree\n \n \nMethod\n.\n\n\ndfs_tree(g, s)\n\n\n\n\nReturn an ordered vector of vertices representing a directed acylic graph based on depth-first traversal of the graph \ng\n starting with source vertex \ns\n.\n\n\nsource\n\n\n#\n\n\nLightGraphs.difference\n \n \nMethod\n.\n\n\ndifference(g, h)\n\n\n\n\nReturn a graph with edges in graph \ng\n that are not in graph \nh\n.\n\n\nImplementation Notes\n\n\nNote that this function may produce a graph with 0-degree vertices. Preserves the eltype of the input graph.\n\n\nsource\n\n\n#\n\n\nLightGraphs.dijkstra_shortest_paths\n \n \nMethod\n.\n\n\ndijkstra_shortest_paths(g, srcs, distmx=DefaultDistance());\n\n\n\n\nPerform \nDijkstra's algorithm\n on a graph, computing shortest distances between \nsrcs\n and all other vertices. Return a \nDijkstraState\n that contains various traversal information.\n\n\nOptional Arguments\n\n\n\n\nallpaths=false\n: If true, returns a \nDijkstraState\n that keeps track of all\n\n\n\n\npredecessors of a given vertex.\n\n\nsource\n\n\n#\n\n\nLightGraphs.dst\n \n \nMethod\n.\n\n\ndst(e)\n\n\n\n\nReturn the destination vertex of edge \ne\n.\n\n\nsource\n\n\n#\n\n\nLightGraphs.edges\n \n \nMethod\n.\n\n\nedges(g)\n\n\n\n\nReturn (an iterator to or collection of) the edges of a graph.\n\n\nImplementation Notes\n\n\nA returned iterator is valid for one pass over the edges, and is invalidated by changes to \ng\n.\n\n\nsource\n\n\n#\n\n\nLightGraphs.edgetype\n \n \nMethod\n.\n\n\nedgetype(g)\n\n\n\n\nReturn the type of graph \ng\n's edge\n\n\nsource\n\n\n#\n\n\nLightGraphs.egonet\n \n \nMethod\n.\n\n\negonet(g, v:, d)\n\n\n\n\nReturn the subgraph of \ng\n induced by the neighbors of \nv\n up to distance \nd\n. This is equivalent to \ninduced_subgraph\n(g, neighborhood(g, v, d, dir=dir))[1].\n\n\nOptional Arguments\n\n\n\n\ndir=:out\n: if \ng\n is directed, this argument specifies the edge direction\n\n\n\n\nwith respect to \nv\n (i.e. \n:in\n or \n:out\n).\n\n\nsource\n\n\n#\n\n\nLightGraphs.floyd_warshall_shortest_paths\n \n \nMethod\n.\n\n\nfloyd_warshall_shortest_paths(g, distmx=DefaultDistance()) Use the \nFloyd-Warshall algorithm\n to compute the shortest paths between all pairs of vertices in graph \ng\n using an optional distance matrix \ndistmx\n. Return a \nFloydWarshallState\n with relevant traversal information.\n\n\nPerformance\n\n\nSpace complexity is on the order of $\\mathcal{O}(|V|^2)$.\n\n\nsource\n\n\n#\n\n\nLightGraphs.gdistances!\n \n \nMethod\n.\n\n\ngdistances!(g, source, dists)\n\n\n\n\nFill \ndists\n with the geodesic distances of vertices in \ng\n from \nsource\n. \ndists\n should be a vector of length \nnv(g)\n. Return \ndists\n. For vertices in disconnected components the default distance is -1.\n\n\nsource\n\n\n#\n\n\nLightGraphs.gdistances\n \n \nMethod\n.\n\n\ngdistances(g, source)\n\n\n\n\nReturn a vector filled with the geodesic distances of vertices in  \ng\n from \nsource\n. If \nsource\n is a collection of vertices each element should be unique. For vertices in disconnected components the default distance is -1.\n\n\nsource\n\n\n#\n\n\nLightGraphs.global_clustering_coefficient\n \n \nMethod\n.\n\n\nglobal_clustering_coefficient(g)\n\n\n\n\nReturn the \nglobal clustering coefficient\n of graph \ng\n.\n\n\nsource\n\n\n#\n\n\nLightGraphs.has_edge\n \n \nMethod\n.\n\n\nhas_edge(g, e)\n\n\n\n\nReturn true if the graph \ng\n has an edge \ne\n.\n\n\nsource\n\n\n#\n\n\nLightGraphs.has_vertex\n \n \nMethod\n.\n\n\nhas_vertex(g, v)\n\n\n\n\nReturn true if \nv\n is a vertex of \ng\n.\n\n\nsource\n\n\n#\n\n\nLightGraphs.in_neighbors\n \n \nMethod\n.\n\n\nin_neighbors(g, v)\n\n\n\n\nReturn a list of all neighbors connected to vertex \nv\n by an incoming edge.\n\n\nImplementation Notes\n\n\nReturns a reference, not a copy. Do not modify result.\n\n\nsource\n\n\n#\n\n\nLightGraphs.induced_subgraph\n \n \nMethod\n.\n\n\ninduced_subgraph(g, vlist)\ninduced_subgraph(g, elist)\n\n\n\n\nReturn the subgraph of \ng\n induced by the vertices in  \nvlist\n or edges in \nelist\n along with a vector mapping the new vertices to the old ones (the  vertex \ni\n in the subgraph corresponds to the vertex \nvmap[i]\n in \ng\n.)\n\n\nThe returned graph has \nlength(vlist)\n vertices, with the new vertex \ni\n corresponding to the vertex of the original graph in the \ni\n-th position of \nvlist\n.\n\n\nUsage Examples\n\n\njulia\n g = CompleteGraph(10)\n\njulia\n sg, vmap = induced_subgraph(g, 5:8)\n\njulia\n @assert g[5:8] == sg\n\njulia\n @assert nv(sg) == 4\n\njulia\n @assert ne(sg) == 6\n\njulia\n @assert vm[4] == 8\n\njulia\n sg, vmap = induced_subgraph(g, [2,8,3,4])\n\njulia\n @assert sg == g[[2,8,3,4]]\n\njulia\n elist = [Edge(1,2), Edge(3,4), Edge(4,8)]\n\njulia\n sg, vmap = induced_subgraph(g, elist)\n\njulia\n @assert sg == g[elist]\n\n\n\n\nsource\n\n\n#\n\n\nLightGraphs.is_bipartite\n \n \nMethod\n.\n\n\nis_bipartite(g[, v])\n\n\n\n\nReturn \ntrue\n if graph \ng\n is \nbipartite\n. If a node \nv\n is specified, only the connected component to which it belongs is considered.\n\n\nsource\n\n\n#\n\n\nLightGraphs.kruskal_mst\n \n \nFunction\n.\n\n\nkruskal_mst(g, distmx=DefaultDistance())\n\n\n\n\nReturn a vector of edges representing the minimum spanning tree of a connected, undirected graph \ng\n with optional distance matrix \ndistmx\n using \nKruskal's algorithm\n.\n\n\nsource\n\n\n#\n\n\nLightGraphs.label_propagation\n \n \nFunction\n.\n\n\nlabel_propagation(g, maxiter=1000)\n\n\n\n\nCommunity detection using the label propagation algorithm. Return two vectors: the first is the label number assigned to each node, and the second is the convergence history for each node. Will return after \nmaxiter\n iterations if convergence has not completed.\n\n\nReferences\n\n\n\n\nRaghavan et al.\n\n\n\n\nsource\n\n\n#\n\n\nLightGraphs.local_clustering\n \n \nMethod\n.\n\n\nlocal_clustering(g, v)\nlocal_clustering(g, vs)\n\n\n\n\nReturn a tuple \n(a, b)\n, where \na\n is the number of triangles in the neighborhood of \nv\n and \nb\n is the maximum number of possible triangles. If a list of vertices \nvs\n is specified, return two vectors representing the number of triangles and the maximum number of possible triangles, respectively, for each node in the list.\n\n\nThis function is related to the local clustering coefficient \nr\n by $r=\frac{a}{b}$.\n\n\nsource\n\n\n#\n\n\nLightGraphs.local_clustering_coefficient\n \n \nMethod\n.\n\n\nlocal_clustering_coefficient(g, v)\nlocal_clustering_coefficient(g, vs)\n\n\n\n\nReturn the \nlocal clustering coefficient\n for node \nv\n in graph \ng\n. If a list of vertices \nvs\n is specified, return a vector of coefficients for each node in the list.\n\n\nsource\n\n\n#\n\n\nLightGraphs.maximal_cliques\n \n \nFunction\n.\n\n\nmaximal_cliques(g)\n\n\n\n\nReturn a vector of vectors representing the node indices in each of the maximal cliques found in the undirected graph \ng\n.\n\n\njulia\n using LightGraphs\njulia\n g = Graph(3)\njulia\n add_edge!(g, 1, 2)\njulia\n add_edge!(g, 2, 3)\njulia\n maximal_cliques(g)\n2-element Array{Array{Int64,N},1}:\n [2,3]\n [2,1]\n\n\n\n\nsource\n\n\n#\n\n\nLightGraphs.maximum_adjacency_visit\n \n \nMethod\n.\n\n\nmaximum_adjacency_visit(g[, distmx][, log][, io])\n\n\n\n\nReturn the vertices in \ng\n traversed by maximum adjacency search. An optional \ndistmx\n matrix may be specified; if omitted, edge distances are assumed to be 1. If \nlog\n (default \nfalse\n) is \ntrue\n, visitor events will be printed to \nio\n, which defaults to \nSTDOUT\n; otherwise, no event information will be displayed.\n\n\nsource\n\n\n#\n\n\nLightGraphs.maximum_flow\n \n \nFunction\n.\n\n\nmaximum_flow(flow_graph, source, target[, capacity_matrix][, algorithm][, restriction])\n\n\n\n\nGeneric maximum_flow function for \nflow_graph\n from \nsource\n to \ntarget\n with capacities in \ncapacity_matrix\n. Uses flow algorithm \nalgorithm\n and cutoff restriction \nrestriction\n.\n\n\n\n\nIf \ncapacity_matrix\n is not specified, \nDefaultCapacity(flow_graph)\n will be used.\n\n\nIf \nalgorithm\n is not specified, it will default to \nPushRelabelAlgorithm\n.\n\n\nIf \nrestriction\n is not specified, it will default to \n0\n.\n\n\n\n\nReturn a tuple of (maximum flow, flow matrix). For the Boykov-Kolmogorov algorithm, the associated mincut is returned as a third output.\n\n\nUsage Example:\n\n\njulia\n flow_graph = DiGraph(8) # Create a flow-graph\njulia\n flow_edges = [\n(1,2,10),(1,3,5),(1,4,15),(2,3,4),(2,5,9),\n(2,6,15),(3,4,4),(3,6,8),(4,7,16),(5,6,15),\n(5,8,10),(6,7,15),(6,8,10),(7,3,6),(7,8,10)\n]\n\njulia\n capacity_matrix = zeros(Int, 8, 8)  # Create a capacity matrix\n\njulia\n for e in flow_edges\n    u, v, f = e\n    add_edge!(flow_graph, u, v)\n    capacity_matrix[u,v] = f\nend\n\njulia\n f, F = maximum_flow(flow_graph, 1, 8) # Run default maximum_flow without the capacity_matrix\n\njulia\n f, F = maximum_flow(flow_graph, 1, 8) # Run default maximum_flow with the capacity_matrix\n\njulia\n f, F = maximum_flow(flow_graph,1,8,capacity_matrix,algorithm=EdmondsKarpAlgorithm()) # Run Edmonds-Karp algorithm\n\njulia\n f, F = maximum_flow(flow_graph,1,8,capacity_matrix,algorithm=DinicAlgorithm()) # Run Dinic's algorithm\n\njulia\n f, F, labels = maximum_flow(flow_graph,1,8,capacity_matrix,algorithm=BoykovKolmogorovAlgorithm()) # Run Boykov-Kolmogorov algorithm\n\n\n\n\n\nsource\n\n\n#\n\n\nLightGraphs.maxsimplecycles\n \n \nFunction\n.\n\n\nmaxsimplecycles(dg::::IsDirected, byscc::Bool = true)\n\n\n\n\nCompute the theoretical maximum number of cycles in the directed graph \ndg\n.\n\n\nThe computation can be performed assuming the graph is complete or taking into account the decomposition in strongly connected components (\nbyscc\n parameter). The formula is coming from \nJohnson, 1973\n.\n\n\nPerformance\n\n\nA more efficient version is possible.\n\n\nReferences\n\n\n\n\nJohnson\n\n\n\n\nsource\n\n\n#\n\n\nLightGraphs.maxsimplecycles\n \n \nMethod\n.\n\n\nmaxsimplecycles(n::Integer)\n\n\n\n\nCompute the theoretical maximum number of cycles in a directed graph of \nn\n vertices, assuming there are no self-loops. The formula is coming from \nJohnson, 1973\n.\n\n\nReferences\n\n\n\n\nJohnson\n.\n\n\n\n\nsource\n\n\n#\n\n\nLightGraphs.mincut\n \n \nMethod\n.\n\n\nmincut(g, distmx=DefaultDistance())\n\n\n\n\nReturn a tuple \n(parity, bestcut)\n, where \nparity\n is a vector of integer values that determines the partition in \ng\n (1 or 2) and \nbestcut\n is the weight of the cut that makes this partition. An optional \ndistmx\n matrix may be specified; if omitted, edge distances are assumed to be 1.\n\n\nsource\n\n\n#\n\n\nLightGraphs.modularity\n \n \nFunction\n.\n\n\nmodularity(g, c)\n\n\n\n\nReturn a value representing Newman's modularity \nQ\n for the undirected graph \ng\n given the partitioning vector \nc\n.\n\n\nsource\n\n\n#\n\n\nLightGraphs.multiroute_flow\n \n \nMethod\n.\n\n\nmultiroute_flow(flow_graph, source, target[, DefaultCapacity][, flow_algorithm][, mrf_algorithm][, routes])\n\n\n\n\nThe generic multiroute_flow function.\n\n\nThe output will vary depending on the input:\n\n\n\n\nWhen the number of \nroute\ns is \n0\n, return the set of breaking points of\n\n\n\n\nthe multiroute flow.\n\n\n\n\nWhen the number of \nroute\ns is \n1\n, return a flow with a set of 1-disjoint paths\n\n\n\n\n(this is the classical max-flow implementation).\n\n\n\n\nWhen the input is limited to a set of breaking points and a route value \nk\n,\n\n\n\n\nreturn only the k-route flow.\n\n\n\n\nOtherwise, a tuple with 1) the maximum flow and 2) the flow matrix. When the\n\n\n\n\nmax-flow subroutine is the Boykov-Kolmogorov algorithm, the associated mincut is returned as a third output.\n\n\nWhen the input is a network, it requires the following arguments:\n\n\n\n\nflow_graph\n: the input graph\n\n\nsource\n: the source vertex\n\n\ntarget\n: the target vertex\n\n\ncapacity_matrix\n: matrix of edge flow capacities\n\n\nflow_algorithm\n: keyword argument for flow algorithm\n\n\nmrf_algorithm\n: keyword argument for multiroute flow algorithm\n\n\nroutes\n: keyword argument for the number of routes\n\n\n\n\nWhen the input is only the set of (breaking) points and the number of route, it requires the following arguments:\n\n\n\n\nbreakingpoints\n: vector of breaking points\n\n\nroutes\n: number of routes\n\n\n\n\nWhen the input is the set of (breaking) points, the number of routes, and the network descriptors, it requires the following arguments:\n\n\n\n\nbreakingpoints\n: vector of breaking points\n\n\nroutes\n: number of routes\n\n\nflow_graph\n: the input graph\n\n\nsource\n: the source vertex\n\n\ntarget\n: the target vertex\n\n\ncapacity_matrix\n: matrix of edge flow capacities\n\n\nflow_algorithm\n: keyword argument for flow algorithm\n\n\n\n\nThe function defaults to the Push-relabel (classical flow) and Kishimoto (multiroute) algorithms. Alternatively, the algorithms to be used can also be specified through  keyword arguments. A default capacity of \n1\n is assumed for each link if no capacity matrix is provided.\n\n\nThe \nmrf_algorithm\n keyword is inforced to Extended Multiroute Flow in the following cases:\n\n\n\n\nThe number of routes is non-integer\n\n\nThe number of routes is 0 or non-specified\n\n\n\n\nUsage Example :\n\n\n(please consult the  \nmax_flow\n section for options about flow_algorithm and capacity_matrix)\n\n\njulia\n flow_graph = DiGraph(8) # Create a flow graph\n\njulia\n flow_edges = [\n(1, 2, 10), (1, 3, 5),  (1, 4, 15), (2, 3, 4),  (2, 5, 9),\n(2, 6, 15), (3, 4, 4),  (3, 6, 8),  (4, 7, 16), (5, 6, 15),\n(5, 8, 10), (6, 7, 15), (6, 8, 10), (7, 3, 6),  (7, 8, 10)\n]\n\njulia\n capacity_matrix = zeros(Int, 8, 8) # Create a capacity matrix\n\njulia\n for e in flow_edges\n    u, v, f = e\n    add_edge!(flow_graph, u, v)\n    capacity_matrix[u, v] = f\nend\n\njulia\n f, F = multiroute_flow(flow_graph, 1, 8, capacity_matrix, routes = 2) # Run default multiroute_flow with an integer number of routes = 2\n\njulia\n f, F = multiroute_flow(flow_graph, 1, 8, capacity_matrix, routes = 1.5) # Run default multiroute_flow with a noninteger number of routes = 1.5\n\njulia\n points = multiroute_flow(flow_graph, 1, 8, capacity_matrix) # Run default multiroute_flow for all the breaking points values\n\njulia\n f, F = multiroute_flow(points, 1.5) # Then run multiroute flow algorithm for any positive number of routes\n\njulia\n f = multiroute_flow(points, 1.5, valueonly = true)\n\njulia\n f, F, labels = multiroute_flow(flow_graph, 1, 8, capacity_matrix, algorithm = BoykovKolmogorovAlgorithm(), routes = 2) # Run multiroute flow algorithm using Boykov-Kolmogorov algorithm as max_flow routine\n\n\n\n\n\nsource\n\n\n#\n\n\nLightGraphs.ne\n \n \nMethod\n.\n\n\nne(g)\n\n\n\n\nReturn the number of edges in \ng\n.\n\n\nsource\n\n\n#\n\n\nLightGraphs.non_backtracking_matrix\n \n \nMethod\n.\n\n\nnon_backtracking_matrix(g)\n\n\n\n\nReturn a non-backtracking matrix \nB\n and an edgemap storing the oriented edges' positions in \nB\n.\n\n\nGiven two arcs $A_{i j}\nand\nA_{k l}\nin\ng`, the non-backtraking matrix$B`` is defined as\n\n\n$B_{A_{i j}, A_{k l}} = \u03b4_{j k} * (1 - \u03b4_{i l})$\n\n\nsource\n\n\n#\n\n\nLightGraphs.non_backtracking_randomwalk\n \n \nFunction\n.\n\n\nnon_backtracking_randomwalk(g, s, niter)\n\n\n\n\nPerform a non-backtracking random walk on directed graph \ng\n starting at vertex \ns\n and continuing for a maximum of \nniter\n steps. Return a vector of vertices visited in order.\n\n\nsource\n\n\n#\n\n\nLightGraphs.nv\n \n \nMethod\n.\n\n\nnv(g)\n\n\n\n\nReturn the number of vertices in \ng\n.\n\n\nsource\n\n\n#\n\n\nLightGraphs.out_neighbors\n \n \nMethod\n.\n\n\nout_neighbors(g, v)\n\n\n\n\nReturn a list of all neighbors connected to vertex \nv\n by an outgoing edge.\n\n\nImplementation Notes\n\n\nReturns a reference, not a copy. Do not modify result.\n\n\nsource\n\n\n#\n\n\nLightGraphs.prim_mst\n \n \nFunction\n.\n\n\nprim_mst(g, distmx=DefaultDistance())\n\n\n\n\nReturn a vector of edges representing the minimum spanning tree of a connected, undirected graph \ng\n with optional distance matrix \ndistmx\n using \nPrim's algorithm\n. Return a vector of edges.\n\n\nsource\n\n\n#\n\n\nLightGraphs.randomwalk\n \n \nMethod\n.\n\n\nrandomwalk(g, s, niter)\n\n\n\n\nPerform a random walk on graph \ng\n starting at vertex \ns\n and continuing for a maximum of \nniter\n steps. Return a vector of vertices visited in order.\n\n\nsource\n\n\n#\n\n\nLightGraphs.rem_edge!\n \n \nMethod\n.\n\n\nrem_edge!(g, e)\n\n\n\n\nRemove the edge \ne\n from \ng\n. Return false if edge removal fails (e.g., if edge does not exist), true otherwise.\n\n\nsource\n\n\n#\n\n\nLightGraphs.rem_vertex!\n \n \nMethod\n.\n\n\nrem_vertex!(g)\n\n\n\n\nRemove the vertex \nv\n from graph \ng\n. Return false if removal fails (e.g., if vertex is not in the graph), true otherwise.\n\n\nsource\n\n\n#\n\n\nLightGraphs.saw\n \n \nMethod\n.\n\n\nsaw(g, s, niter)\n\n\n\n\nPerform a \nself-avoiding walk\n on graph \ng\n starting at vertex \ns\n and continuing for a maximum of \nniter\n steps. Return a vector of vertices visited in order.\n\n\nsource\n\n\n#\n\n\nLightGraphs.simplecycles\n \n \nFunction\n.\n\n\nsimplecycles(dg::::IsDirected)\n\n\n\n\nCompute all cycles of the given directed graph, using \nJohnson, 1973\n's algorithm and return them.\n\n\n/! The number of cycles grow more than exponentially with the number of vertices, you might want to use the algorithm with a ceiling \u2013 \ngetcycles\n \u2013 on large directed graphs (slightly slower). If you want to have an idea of the possible number of cycles, look at function \nmaxsimplecycles(dg::DiGraph, byscc::Bool = true)\n.\n\n\nReferences\n\n\n\n\nJohnson\n\n\n\n\nsource\n\n\n#\n\n\nLightGraphs.simplecycles_hadwick_james\n \n \nFunction\n.\n\n\nsimplecycles_hadwick_james(g)\n\n\n\n\nFind circuits (including self-loops) in \ng\n using the algorithm of Hadwick \n James.\n\n\nReferences\n\n\n\n\nHadwick \n James, \"Enumerating Circuits and Loops in Graphs with Self-Arcs and Multiple-Arcs\", 2008\n\n\n\n\nsource\n\n\n#\n\n\nLightGraphs.simplecycles_iter\n \n \nFunction\n.\n\n\nsimplecycles_iter(dg::DiGraph, ceiling = 10^6)\n\n\n\n\nSearch all cycles of the given directed graph, using \nJohnson, 1973\n's algorithm, up to the ceiling (avoid memory overload).\n\n\nIf the graph is small, the ceiling will not be reached and $simplecycles(dg::DiGraph)$ is more efficient. It avoids the overhead of the counting and testing if the ceiling is reached. It returns all the cycles of the directed graph if the \nceiling\n is not reached, a subset of them otherwise.\n\n\nTo get an idea of the possible number of cycles, using function \nmaxsimplecycles(dg::DiGraph, byscc::Bool = true)\n on the directed graph.\n\n\nReferences\n\n\n\n\nJohnson\n\n\n\n\nsource\n\n\n#\n\n\nLightGraphs.simplecyclescount\n \n \nFunction\n.\n\n\nsimplecyclescount(dg::DiGraph, ceiling = 10^6)\n\n\n\n\nCount the number of cycles in a directed graph, using \nJohnson, 1973\n's algorithm.\n\n\nThe \nceiling\n is here to avoid memory overload if there are a lot of cycles in the graph. Default value is 10^6, but it can be higher or lower. You can use the function \nmaxsimplecycles(dg::DiGraph, byscc::Bool = true)\n to get an idea of the theoretical maximum number or cycles.\n\n\nReturns the minimum of the ceiling and the number of cycles.\n\n\nReferences\n\n\n\n\nJohnson\n\n\n\n\nsource\n\n\n#\n\n\nLightGraphs.simplecycleslength\n \n \nFunction\n.\n\n\nsimplecycleslength(dg::DiGraph, ceiling = 10^6)\n\n\n\n\nSearch all cycles of the given directed graph, using \nJohnson, 1973\n's algorithm, and return their length.\n\n\nTo get an idea of the possible number of cycles, using function \nmaxsimplecycles(dg::DiGraph, byscc::Bool = true)\n on the directed graph.\n\n\nIt returns \ncyclelengths\n and \nncycles\n, the lengths of all cycles and the  number of cycles. The index in the array is the length of the cycle.  If the \nceiling\n is reached (\nncycles = ceiling\n), the output is only a subset of the cycles lengths.\n\n\nReferences\n\n\n\n\nJohnson\n\n\n\n\nsource\n\n\n#\n\n\nLightGraphs.src\n \n \nMethod\n.\n\n\nsrc(e)\n\n\n\n\nReturn the source vertex of edge \ne\n.\n\n\nsource\n\n\n#\n\n\nLightGraphs.symmetric_difference\n \n \nMethod\n.\n\n\nsymmetric_difference(g, h)\n\n\n\n\nReturn a graph with edges from graph \ng\n that do not exist in graph \nh\n, and vice versa.\n\n\nImplementation Notes\n\n\nNote that this function may produce a graph with 0-degree vertices. Preserves the eltype of the input graph. Will error if the number of vertices in the generated graph exceeds the eltype.\n\n\nsource\n\n\n#\n\n\nLightGraphs.tensor_product\n \n \nMethod\n.\n\n\ntensor_product(g, h)\n\n\n\n\nReturn the (tensor product)[https://en.wikipedia.org/wiki/Tensor_product_of_graphs] of \ng\n and \nh\n.\n\n\nImplementation Notes\n\n\nPreserves the eltype of the input graph. Will error if the number of vertices in the generated graph exceeds the eltype.\n\n\nsource\n\n\n#\n\n\nLightGraphs.transitiveclosure\n \n \nFunction\n.\n\n\ntransitiveclosure(g, selflooped=false)\n\n\n\n\nCompute the transitive closure of a directed graph, using the Floyd-Warshall algorithm. Return a graph representing the transitive closure. If \nselflooped\n is \ntrue\n, add self loops to the graph.\n\n\nPerformance\n\n\nTime complexity is \\mathcal{O}(|V|^3).\n\n\nsource\n\n\n#\n\n\nLightGraphs.transitiveclosure!\n \n \nFunction\n.\n\n\ntransitiveclosure!(g, selflooped=false)\n\n\n\n\nCompute the transitive closure of a directed graph, using the Floyd-Warshall algorithm. If \nselflooped\n is true, add self loops to the graph.\n\n\nPerformance\n\n\nTime complexity is \\mathcal{O}(|V|^3).\n\n\nImplementation Notes\n\n\nThis version of the function modifies the original graph.\n\n\nsource\n\n\n#\n\n\nLightGraphs.triangles\n \n \nMethod\n.\n\n\ntriangles(g[, v])\ntriangles(g, vs)\n\n\n\n\nReturn the number of triangles in the neighborhood of node \nv\n in graph \ng\n. If a list of vertices \nvs\n is specified, return a vector of number of triangles for each node in the list. If no vertices are specified, return the number of triangles for each node in the graph.\n\n\nsource\n\n\n#\n\n\nLightGraphs.vertices\n \n \nMethod\n.\n\n\nvertices(g)\n\n\n\n\nReturn (an iterator to or collection of) the vertices of a graph.\n\n\nImplementation Notes\n\n\nA returned iterator is valid for one pass over the edges, and is invalidated by changes to \ng\n.\n\n\nsource\n\n\n#\n\n\nLightGraphs.yen_k_shortest_paths\n \n \nMethod\n.\n\n\nyen_k_shortest_paths(g, source, target, distmx=DefaultDistance(), K=1; maxdist=Inf);\n\n\n\n\nPerform \nYen's algorithm\n on a graph, computing k-shortest distances between \nsource\n and \ntarget\n other vertices. Return a \nYenState\n that contains distances and paths.\n\n\nsource\n\n\n#\n\n\nLightGraphs.Articulations\n \n \nType\n.\n\n\nArticulations{T}\n\n\n\n\nA state type for the depth-first search that finds the articulation points in a graph.\n\n\nsource\n\n\n#\n\n\nLightGraphs.BellmanFordState\n \n \nType\n.\n\n\nBellmanFordState{T, U}\n\n\n\n\nAn \nAbstractPathState\n designed for Bellman-Ford shortest-paths calculations.\n\n\nsource\n\n\n#\n\n\nLightGraphs.ComponentVisitorVector\n \n \nType\n.\n\n\nComponentVisitorVector{T}\n\n\n\n\nA type of \nAbstractGraphVisitor\n that represents connected components with BFS starting from a given seed.\n\n\nsource\n\n\n#\n\n\nLightGraphs.DefaultCapacity\n \n \nType\n.\n\n\nDefaultCapacity{T}\n\n\n\n\nStructure that returns \n1\n if a forward edge exists in \nflow_graph\n, and \n0\n otherwise.\n\n\nsource\n\n\n#\n\n\nLightGraphs.DijkstraState\n \n \nType\n.\n\n\nstruct DijkstraState{T, U}\n\n\n\n\nAn \nAbstractPathState\n designed for Dijkstra shortest-paths calculations.\n\n\nsource\n\n\n#\n\n\nLightGraphs.FloydWarshallState\n \n \nType\n.\n\n\nstruct FloydWarshallState{T, U}\n\n\n\n\nAn \nAbstractPathState\n designed for Floyd-Warshall shortest-paths calculations.\n\n\nsource\n\n\n#\n\n\nLightGraphs.JohnsonVisitor\n \n \nType\n.\n\n\ntype JohnsonVisitor{T\n:Integer} \n: Visitor{T}\n    stack::Vector{T}\n    blocked::BitArray\n    blockedmap::Vector{Set{T}}\nend\n\n\n\n\nComposite type that regroups the information needed for Johnson's algorithm.\n\n\nstack\n is the stack of visited vertices. \nblocked\n is a boolean for each  vertex that tells whether it is blocked or not. \nblockedmap\n tells which  vertices to unblock if the key vertex is unblocked.\n\n\nsource\n\n\n#\n\n\nLightGraphs.JohnsonVisitor\n \n \nMethod\n.\n\n\nJohnsonVisitor(dg::::IsDirected)\n\n\n\n\nConstructor of the visitor, using the directed graph information.\n\n\nsource\n\n\n#\n\n\nLightGraphs.NeighComm\n \n \nType\n.\n\n\nNeighComm{T}\n\n\n\n\nType to record neighbor labels and their counts.\n\n\nsource\n\n\n#\n\n\nLightGraphs.ThreadQueue\n \n \nType\n.\n\n\nThreadQueue\n\n\n\n\nA thread safe queue implementation for using as the queue for BFS.\n\n\nsource\n\n\n#\n\n\nLightGraphs.TreeBFSVisitorVector\n \n \nType\n.\n\n\nTreeBFSVisitorVector{T}\n\n\n\n\nA type for representing a BFS traversal of the graph as a parents array.\n\n\nsource\n\n\n#\n\n\nLightGraphs.YenState\n \n \nType\n.\n\n\nstruct YenState{T, U}\n\n\n\n\nDesigned for yen k-shortest-paths calculations.\n\n\nsource\n\n\n#\n\n\nLightGraphs.AbstractEdgeIter\n \n \nType\n.\n\n\nAbstractEdgeIter\n\n\n\n\nAn abstract type representing an edge iterator.\n\n\nsource\n\n\n#\n\n\nLightGraphs.AbstractFlowAlgorithm\n \n \nType\n.\n\n\nAbstractFlowAlgorithm\n\n\n\n\nAbstract type that allows users to pass in their preferred algorithm\n\n\nsource\n\n\n#\n\n\nLightGraphs.AbstractMultirouteFlowAlgorithm\n \n \nType\n.\n\n\nAbstractMultirouteFlowAlgorithm\n\n\n\n\nAbstract type that allows users to pass in their preferred algorithm.\n\n\nsource\n\n\n#\n\n\nLightGraphs.Biconnections\n \n \nType\n.\n\n\nBiconnections\n\n\n\n\nA state type for depth-first search that finds the biconnected components.\n\n\nsource\n\n\n#\n\n\nBase.SparseArrays.sparse\n \n \nMethod\n.\n\n\nsparse(g)\n\n\n\n\nReturn the default adjacency matrix of \ng\n.\n\n\nsource\n\n\n#\n\n\nBase.eltype\n \n \nMethod\n.\n\n\neltype(g)\n\n\n\n\nReturn the type of the graph's vertices (must be \n: Integer)\n\n\nsource\n\n\n#\n\n\nBase.getindex\n \n \nMethod\n.\n\n\ng[iter]\n\n\n\n\nReturn the subgraph induced by \niter\n. Equivalent to \ninduced_subgraph\n(g, iter)[1]\n.\n\n\nsource\n\n\n#\n\n\nBase.size\n \n \nMethod\n.\n\n\nsize(g, i)\n\n\n\n\nReturn the number of vertices in \ng\n if \ni\n=1 or \ni\n=2, or \n1\n otherwise.\n\n\nsource\n\n\n#\n\n\nBase.sum\n \n \nMethod\n.\n\n\nsum(g, i)\n\n\n\n\nReturn a vector of indegree (\ni\n=1) or outdegree (\ni\n=2) values for graph \ng\n.\n\n\nsource\n\n\n#\n\n\nBase.sum\n \n \nMethod\n.\n\n\nsum(g)\n\n\n\n\nReturn the number of edges in \ng\n\n\nsource\n\n\n#\n\n\nBase.zero\n \n \nMethod\n.\n\n\nzero(g)\n\n\n\n\nReturn a zero-vertex, zero-edge version of the same type of graph as \ng\n.\n\n\nsource\n\n\n#\n\n\nLightGraphs.approximately_equal\n \n \nMethod\n.\n\n\napproximately_equal(a, b)\n\n\n\n\nReturn true if each element in the tuple is approximately equal to its counterpart.\n\n\nImplementation Notes:\n\n\nThis is a separate function because we don't want to hijack isapprox for tuples.\n\n\nsource\n\n\n#\n\n\nLightGraphs.augment_path!\n \n \nMethod\n.\n\n\naugment_path!(path, flow_matrix, capacity_matrix)\n\n\n\n\nCalculate the amount by which flow can be augmented in the given path. Augment the flow and returns the augment value.\n\n\nsource\n\n\n#\n\n\nLightGraphs.auxiliaryPoints\n \n \nFunction\n.\n\n\nauxiliaryPoints(flow_graph, source, target, capacity_matrix)\n\n\n\n\nOutput a set of (point, slope) that compose the restricted max-flow function of \nflow_graph\n from \nsource to\ntarget\nusing capacities in\ncapacity_matrix`.\n\n\nPerformance\n\n\nOne point by possible slope is enough (hence mathcal{O}(\u03bb\u00d7max_flow) complexity).\n\n\nsource\n\n\n#\n\n\nLightGraphs.bfs_tree!\n \n \nMethod\n.\n\n\nbfs_tree!(LevelSynchronousBFS(), g, src, parents)\n\n\n\n\nProvide a parallel breadth-first traversal of the graph \ng\n starting with source vertex \ns\n, and return a parents array. The returned array is an Array of \nAtomic\n integers.\n\n\nImplementation Notes\n\n\nThis function uses \n@threads\n for parallelism which depends on the \nJULIA_NUM_THREADS\n environment variable to decide the number of threads to use. Refer \n@threads\n documentation for more details.\n\n\nsource\n\n\n#\n\n\nLightGraphs.blocking_flow!\n \n \nFunction\n.\n\n\nblocking_flow!(residual_graph, source, target, capacity_matrix, flow-matrix, P)\n\n\n\n\nLike \nblocking_flow\n, but requires a preallocated parent vector \nP\n.\n\n\nsource\n\n\n#\n\n\nLightGraphs.blocking_flow\n \n \nMethod\n.\n\n\nblocking_flow(residual_graph, source, target, capacity_matrix, flow-matrix)\n\n\n\n\nUse BFS to identify a blocking flow in the \nresidual_graph\n with current flow matrix \nflow_matrix\nand then backtrack from \ntarget\n to \nsource\n, augmenting flow along all possible paths.\n\n\nsource\n\n\n#\n\n\nLightGraphs.boykov_kolmogorov_impl\n \n \nFunction\n.\n\n\nboykov_kolmogorov_impl(residual_graph, source, target, capacity_matrix)\n\n\n\n\nCompute the max-flow/min-cut between \nsource\n and \ntarget\n for \nresidual_graph\n using the Boykov-Kolmogorov algorithm.\n\n\nReturn the maximum flow in the network, the flow matrix and the partition \n{S,T}\n in the form of a vector of 0's, 1's and 2's.\n\n\nReferences\n\n\n\n\nBOYKOV, Y.; KOLMOGOROV, V., 2004. An Experimental Comparison of\n\n\n\n\nMin-Cut/Max-Flow Algorithms for Energy Minimization in Vision.\n\n\nAuthor\n\n\n\n\nJ\u00falio Hoffimann Mendes (juliohm@stanford.edu)\n\n\n\n\nsource\n\n\n#\n\n\nLightGraphs.breakingPoints\n \n \nFunction\n.\n\n\nbreakingPoints(flow_graph::::IsDirected, source, target, capacity_matrix)\n\n\n\n\nCalculates the breaking of the restricted max-flow from a set of auxiliary points for \nflow_graph\n from \nsource to\ntarget\nusing capacities in\ncapacity_matrix`.\n\n\nsource\n\n\n#\n\n\nLightGraphs.circuit\n \n \nFunction\n.\n\n\ncircuit{T\n:Integer}(v::T, dg::::IsDirected, vis::JohnsonVisitor{T}, \nallcycles::Vector{Vector{T}}, vmap::Vector{T}, startnode::T = v)\n\n\n\n\nOne step of the recursive version of simple cycle detection, using a DFS algorithm.\n\n\nThe CIRCUIT function from \nJohnson, 1973\n, recursive version. Modify the vector of cycles, when needed.\n\n\n\n\nv\n: the vertex considered in this iteration of the DFS\n\n\ndg\n: the digraph from which cycles are computed\n\n\n\n\nvisitor\n: Informations needed for the cycle computation, contains:\n\n\n\n\nstack\n: the stack of parent vertices\n\n\nblocked\n: tells whether a vertex has already been explored or not\n\n\nblockedmap\n: mapping of the blocking / unblocking consequences\n\n\nallcycles\n: output containing the cycles already detected\n\n\nvmap\n: vector map containing the link from the old to the new nodes of the directed graph\n\n\nstartnode = v\n: optional argument giving the starting node. In the first iteration,\n\n\n\n\n\n\n\n\nthe same as v, otherwise it should be passed.\n\n\nReferences\n\n\n\n\nJohnson\n\n\n\n\nsource\n\n\n#\n\n\nLightGraphs.circuit_iter\n \n \nFunction\n.\n\n\ncircuit_iter{T\n:Integer}(v::T, dg::::IsDirected, vis::JohnsonVisitor{T}, \nvmap::Vector{T}, cycle::Channel, startnode::T = v)\n\n\n\n\nOne step of the recursive version of simple cycle detection, using a DFS algorithm.\n\n\nThe CIRCUIT function from \nJohnson, 1973\n's algorithm,  recursive and iterative version. Produce a cycle when needed, can be used only inside a  Channel.\n\n\nArguments\n\n\n\n\nv: the vertex considered in this iteration of the DFS\n\n\ndg: the digraph from which cycles are computed\n\n\n\n\nvisitor: Informations needed for the cycle computation, contains:\n\n\n\n\nstack: the stack of parent vertices\n\n\nblocked: tells whether a vertex has already been explored or not\n\n\nblockedmap: mapping of the blocking / unblocking consequences\n\n\nvmap\n: vector map containing the link from the old to the new nodes of the directed graph\n\n\ncycle\n: storage of the channel\n\n\nstartnode = v: optional argument giving the starting node. In the first iteration,\n\n\n\n\n\n\n\n\nthe same as v, otherwise it should be passed.\n\n\nReturns\n\n\n\n\ndone: tells whether a circuit has been found in the current exploration.\n\n\n\n\nReferences\n\n\n\n\nJohnson\n\n\n\n\nsource\n\n\n#\n\n\nLightGraphs.circuit_recursive!\n \n \nFunction\n.\n\n\ncircuit_recursive!(g, v1, v2, blocked, B, stack, cycles)\n\n\n\n\nFind circuits in \ng\n recursively starting from v1.\n\n\nsource\n\n\n#\n\n\nLightGraphs.components\n \n \nMethod\n.\n\n\ncomponents(labels)\n\n\n\n\nGiven a vector of component labels, return a vector of vectors representing the vertices associated with a given component id.\n\n\nsource\n\n\n#\n\n\nLightGraphs.components_dict\n \n \nMethod\n.\n\n\ncomponents_dict(labels)\n\n\n\n\nConvert an array of labels to a map of component id to vertices, and return a map with each key corresponding to a given component id and each value containing the vertices associated with that component.\n\n\nsource\n\n\n#\n\n\nLightGraphs.connected_components!\n \n \nFunction\n.\n\n\nconnected_components!(label, g)\n\n\n\n\nFill \nlabel\n with the \nid\n of the connected component in the undirected graph \ng\n to which it belongs. Return a vector representing the component assigned to each vertex. The component value is the smallest vertex ID in the component.\n\n\nsource\n\n\n#\n\n\nLightGraphs.dinic_impl\n \n \nFunction\n.\n\n\nfunction dinic_impl(residual_graph, source, target, capacity_matrix)\n\n\n\n\nCompute the maximum flow between the \nsource\n and \ntarget\n for \nresidual_graph\n with edge flow capacities in \ncapacity_matrix\n using \nDinic's Algorithm\n. Return the value of the maximum flow as well as the final flow matrix.\n\n\nsource\n\n\n#\n\n\nLightGraphs.discharge!\n \n \nFunction\n.\n\n\ndischarge!(residual_graph, v, capacity_matrix, flow_matrix, excess, height, active, count, Q)\n\n\n\n\nDrain the excess flow out of node \nv\n. Run the gap heuristic or relabel the vertex if the excess remains non-zero.\n\n\nsource\n\n\n#\n\n\nLightGraphs.edmonds_karp_impl\n \n \nFunction\n.\n\n\nedmonds_karp_impl(residual_graph, source, target, capacity_matrix)\n\n\n\n\nCompute the maximum flow in flow graph \nresidual_graph\n between \nsource\n and \ntarget\n and capacities defined in \ncapacity_matrix\n using the \nEdmonds-Karp algorithm\n. Return the value of the maximum flow as well as the final flow matrix.\n\n\nsource\n\n\n#\n\n\nLightGraphs.emrf\n \n \nFunction\n.\n\n\nemrf(flow_graph, source, target, capacity_matrix, flow_algorithm, routes=0)\n\n\n\n\nCompute the maximum multiroute flow (for any number of \nroute\ns) between \nsource\n and \ntarget\n in \nflow_graph\n via flow algorithm \nflow_algorithm\n.\n\n\nIf a number of routes is given, return the value of the multiroute flow as well as the final flow matrix, along with a multiroute cut if the Boykov-Kolmogorov max-flow algorithm is used as a subroutine. Otherwise, return the vector of breaking points of the parametric multiroute flow function.\n\n\nReferences\n\n\n\n\nExtended Multiroute Flow algorithm\n\n\n\n\nsource\n\n\n#\n\n\nLightGraphs.enqueue_vertex!\n \n \nMethod\n.\n\n\nenqueue_vertex!(Q, v, active, excess)\n\n\n\n\nPush inactive node \nv\n into queue \nQ\n and activates it. Requires preallocated \nactive\n and \nexcess\n vectors.\n\n\nsource\n\n\n#\n\n\nLightGraphs.fetch_path\n \n \nFunction\n.\n\n\nfetch_path(residual_graph, source, target, flow_matrix, capacity_matrix)\n\n\n\n\nUse bidirectional BFS to look for augmentable paths from \nsource\n to \ntarget\n in \nresidual_graph\n. Return the vertex where the two BFS searches intersect, the parent table of the path, the successor table of the path found, and a flag indicating success (0 =\n success; 1 =\n no path to target, 2 =\n no path to source).\n\n\nsource\n\n\n#\n\n\nLightGraphs.fetch_path!\n \n \nFunction\n.\n\n\nfetch_path!(residual_graph, source, target, flow_matrix, capacity_matrix, P, S)\n\n\n\n\nLike \nfetch_path\n, but requires preallocated parent vector \nP\n and successor vector \nS\n.\n\n\nsource\n\n\n#\n\n\nLightGraphs.gap!\n \n \nFunction\n.\n\n\ngap!(residual_graph, h, excess, height, active, count, Q)\n\n\n\n\nImplement the push-relabel gap heuristic. Relabel all vertices above a cutoff height. Reduce the number of relabels required.\n\n\nRequires arguments:\n\n\n\n\nresidual_graph::DiGraph                # the input graph\n\n\nh::Int                                 # cutoff height\n\n\nexcess::AbstractVector\n\n\nheight::AbstractVector{Int}\n\n\nactive::AbstractVector{Bool}\n\n\ncount::AbstractVector{Int}\n\n\nQ::AbstractVector\n\n\n\n\nsource\n\n\n#\n\n\nLightGraphs.intersection\n \n \nMethod\n.\n\n\nintersection(points, k)\n\n\n\n\nReturn the intersection of a set of line segments and a line of slope \nk\n passing by the origin. Segments are defined as a triple (x, y, slope).\n\n\nsource\n\n\n#\n\n\nLightGraphs.intersection\n \n \nMethod\n.\n\n\n    intersection(x1, y1, a1, x2, y2, a2)\n\n\n\n\nReturn the intersection of two lines defined by \nx\n and \ny\n with slopes \na\n.\n\n\n\n\nA set of segments and a linear function of slope k passing by the origin.\n\n\n\n\nRequires argument:\n\n\n\n\n\n\n\n\nx1, y1, a1, x2, y2, a2::T\n:AbstractFloat # Coordinates/slopes\n\n\n\n\n\n\n\n\n\n\npoints::Vector{Tuple{T, T, Int}}         # vector of points with T\n:AbstractFloat\n\n\n\n\n\n\n\n\nk::R\n:Real                             # number of routes (slope of the line)\n\n\n\n\n\n\nsource\n\n\n#\n\n\nLightGraphs.itercycles\n \n \nFunction\n.\n\n\nitercycles(dg::::IsDirected, cycle::Channel)\n\n\n\n\nCompute all cycles of the given directed graph, using \nJohnson, 1973\n's algorithm.\n\n\nIterative version of the algorithm, using Channels to stop the exploration after a given number of cycles.\n\n\nReferences\n\n\n\n\nJohnson\n\n\n\n\nsource\n\n\n#\n\n\nLightGraphs.kishimoto\n \n \nFunction\n.\n\n\nkishimoto(flow_graph, source, target, capacity_matrix, flow_algorithm, routes)\n\n\n\n\nCompute the maximum multiroute flow (for an integer number of \nroute\ns) between \nsource\n and \ntarget\n in \nflow_graph\n with capacities in \ncapacity_matrix\n using the \nKishimoto algorithm\n. Return the value of the multiroute flow as well as the final flow matrix, along with a multiroute cut if Boykov-Kolmogorov is used as a subroutine.\n\n\nsource\n\n\n#\n\n\nLightGraphs.loadlg_mult\n \n \nMethod\n.\n\n\nloadlg_mult(io)\n\n\n\n\nReturn a dictionary of (name=\ngraph) loaded from IO stream \nio\n.\n\n\nsource\n\n\n#\n\n\nLightGraphs.minmaxCapacity\n \n \nMethod\n.\n\n\nminmaxCapacity(capacity_matrix)\n\n\n\n\nReturn the nonzero min and max function of \ncapacity_matrix\n.\n\n\nNote: this is more efficient than maximum() / minimum() / extrema() since we have to ignore zero values.\n\n\nsource\n\n\n#\n\n\nLightGraphs.ncycles_n_i\n \n \nMethod\n.\n\n\nncycles_n_i(n::Integer, i::Integer)\n\n\n\n\nCompute the theoretical maximum number of cycles of size \ni\n in a directed graph of \nn\n  vertices.\n\n\nsource\n\n\n#\n\n\nLightGraphs.nearbipartiteaffinity\n \n \nMethod\n.\n\n\nnearbipartiteaffinity(sizes, between, intra)\n\n\n\n\nConstruct the affinity matrix for a near bipartite SBM. \nbetween\n is the affinity between the two parts of each bipartite community. \nintra\n is the probability of an edge within the parts of the partitions.\n\n\nThis is a specific type of SBM with \n`\\frac{k}{2} blocks each with two halves. Each half is connected as a random bipartite graph with probability\nintra\nThe blocks are connected with probability\nbetween`.\n\n\nsource\n\n\n#\n\n\nLightGraphs.noallocextreme\n \n \nMethod\n.\n\n\nnoallocextreme(f, comparison, initial, g)\n\n\n\n\nCompute the extreme value of \n[f(g,i) for i=i:nv(g)]\n without gathering them all\n\n\nsource\n\n\n#\n\n\nLightGraphs.push_flow!\n \n \nFunction\n.\n\n\npush_flow!(residual_graph, u, v, capacity_matrix, flow_matrix, excess, height, active, Q)\n\n\n\n\nUsing \nresidual_graph\n with capacities in \ncapacity_matrix\n, push as much flow as possible through the given edge(\nu\n, \nv\n). Requires preallocated \nflow_matrix\n matrix, and \nexcess\n, \nheight,\nactive\n, and\nQ` vectors.\n\n\nsource\n\n\n#\n\n\nLightGraphs.push_relabel\n \n \nFunction\n.\n\n\npush_relabel(residual_graph, source, target, capacity_matrix)\n\n\n\n\nReturn the maximum flow of \nresidual_graph\n from \nsource\n to \ntarget\n using the FIFO push relabel algorithm with gap heuristic.\n\n\nPerformance\n\n\nTakes approximately $\\mathcal{O}(|V|^{3})$ time.\n\n\nsource\n\n\n#\n\n\nLightGraphs.quick_find!\n \n \nMethod\n.\n\n\nquick_find!(vs, p, q)\n\n\n\n\nPerform \nQuick-Find algorithm\n on a given pair of vertices \np\nand \nq\n, and make a connection between them in the vector \nvs\n.\n\n\nsource\n\n\n#\n\n\nLightGraphs.randbn\n \n \nFunction\n.\n\n\nrandbn(n, p, seed=-1)\n\n\n\n\nReturn a binomally-distribted random number with parameters \nn\n and \np\n and optional \nseed\n.\n\n\nReferences\n\n\n\n\n\"Non-Uniform Random Variate Generation,\" Luc Devroye, p. 522. Retrieved via http://www.eirene.de/Devroye.pdf.\n\n\nhttp://stackoverflow.com/questions/23561551/a-efficient-binomial-random-number-generator-code-in-java\n\n\n\n\nsource\n\n\n#\n\n\nLightGraphs.random_pair\n \n \nMethod\n.\n\n\nrandom_pair(rng, n)\n\n\n\n\nGenerate a stream of random pairs in \n1:n\n using random number generator \nRNG\n.\n\n\nsource\n\n\n#\n\n\nLightGraphs.range_shuffle!\n \n \nMethod\n.\n\n\nrange_shuffle!(r, a)\n\n\n\n\nFast shuffle Array \na\n in UnitRange \nr\n.\n\n\nsource\n\n\n#\n\n\nLightGraphs.relabel!\n \n \nFunction\n.\n\n\nrelabel!(residual_graph, v, capacity_matrix, flow_matrix, excess, height, active, count, Q)\n\n\n\n\nRelabel a node \nv\n with respect to its neighbors to produce an admissable edge.\n\n\nsource\n\n\n#\n\n\nLightGraphs.resetB!\n \n \nMethod\n.\n\n\nresetB!(B)\n\n\n\n\nReset B work structure.\n\n\nsource\n\n\n#\n\n\nLightGraphs.resetblocked!\n \n \nMethod\n.\n\n\nresetblocked!(blocked)\n\n\n\n\nReset vector of \nblocked\n vertices.\n\n\nsource\n\n\n#\n\n\nLightGraphs.residual\n \n \nFunction\n.\n\n\nresidual(flow_graph)\n\n\n\n\nReturn a directed residual graph for a directed \nflow_graph\n.\n\n\nThe residual graph comprises the same node list as the orginal flow graph, but ensures that for each edge (u,v), (v,u) also exists in the graph. This allows flow in the reverse direction.\n\n\nIf only the forward edge exists, a reverse edge is created with capacity 0. If both forward and reverse edges exist, their capacities are left unchanged. Since the capacities in \nDefaultDistance\n cannot be changed, an array of ones is created.\n\n\nsource\n\n\n#\n\n\nLightGraphs.sample!\n \n \nMethod\n.\n\n\nsample!([rng, ]a, k)\n\n\nSample \nk\n element from array \na\n without repetition and eventually excluding elements in \nexclude\n.\n\n\nOptional Arguments\n\n\n\n\nexclude=()\n: elements in \na\n to exclude from sampling.\n\n\n\n\nImplementation Notes\n\n\nChanges the order of the elements in \na\n. For a non-mutating version, see \nsample\n.\n\n\nsource\n\n\n#\n\n\nLightGraphs.sample\n \n \nMethod\n.\n\n\nsample([rng,] r, k)\n\n\n\n\nSample \nk\n element from unit range \nr\n without repetition and eventually excluding elements in \nexclude\n.\n\n\nOptional Arguments\n\n\n\n\nexclude=()\n: elements in \na\n to exclude from sampling.\n\n\n\n\nImplementation Notes\n\n\nUnlike \nsample!\n, does not produce side effects.\n\n\nsource\n\n\n#\n\n\nLightGraphs.savelg\n \n \nMethod\n.\n\n\nsavelg(io, g, gname)\n\n\n\n\nWrite a graph \ng\n with name \ngname\n in a proprietary format to the IO stream designated by \nio\n. Return 1 (number of graphs written).\n\n\nsource\n\n\n#\n\n\nLightGraphs.savelg_mult\n \n \nMethod\n.\n\n\nsavelg_mult(io, graphs)\n\n\n\n\nWrite a dictionary of (name=\ngraph) to an IO stream \nio\n, with default \nGZip\n compression. Return number of graphs written.\n\n\nsource\n\n\n#\n\n\nLightGraphs.sbmaffinity\n \n \nMethod\n.\n\n\nsbmaffinity(internalp, externalp, sizes)\n\n\n\n\nProduce the sbm affinity matrix with internal probabilities \ninternalp\n and external probabilities \nexternalp\n.\n\n\nsource\n\n\n#\n\n\nLightGraphs.slope\n \n \nFunction\n.\n\n\nslope(flow_graph, capacity_matrix, cut, restriction)\n\n\n\n\nReturn the slope of \nflow_graph\n using capacities in \ncapacity_matrix\n and a cut vector \ncut\n. The slope is initialized at 0 and is incremented for each edge whose capacity does not exceed \nrestriction\n.\n\n\nsource\n\n\n#\n\n\nLightGraphs.tree\n \n \nMethod\n.\n\n\ntree(parents)\n\n\n\n\nConvert a parents array into a directed graph.\n\n\nsource\n\n\n#\n\n\nLightGraphs.unblock!\n \n \nMethod\n.\n\n\nunblock!(v, blocked, B)\n\n\n\n\nUnblock the value \nv\n from the \nblocked\n list and remove from \nB\n.\n\n\nsource\n\n\n#\n\n\nLightGraphs.unblock!\n \n \nMethod\n.\n\n\nunblock!{T\n:Integer}(v::T, blocked::BitArray, B::Vector{Set{T}})\n\n\n\n\nUnblock the vertices recursively. \n\n\nv\n is the vertex to unblock, \nblocked\n tells whether a vertex is blocked or  not and \nB\n is the map that tells if the unblocking of one vertex should  unblock other vertices.\n\n\nsource\n\n\n#\n\n\nLightGraphs.visit!\n \n \nMethod\n.\n\n\nvisit!(g, v, marked, pq, distmx)\n\n\n\n\nMark the vertex \nv\n of graph \ng\n true in the array \nmarked\n and enter all its edges into priority queue \npq\n with its \ndistmx\n values as a PrimHeapEntry.\n\n\nsource\n\n\n#\n\n\nLightGraphs.visit!\n \n \nMethod\n.\n\n\nvisit!(g, state, u, v)\n\n\n\n\nPerform a DFS visit storing the depth and low-points of each vertex.\n\n\nsource\n\n\n#\n\n\nLightGraphs.visit!\n \n \nMethod\n.\n\n\nvisit!(state, g, u, v)\n\n\n\n\nPerform a depth first search storing the depth (in \ndepth\n) and low-points (in \nlow\n) of each vertex. Call this function repeatedly to complete the DFS (see \narticulation\n for usage).\n\n\nsource\n\n\n#\n\n\nLightGraphs.vote!\n \n \nMethod\n.\n\n\nvote!(g, m, c, u)\n\n\n\n\nReturn the label with greatest frequency.\n\n\nsource", 
            "title": "Flow and Cut"
        }, 
        {
            "location": "/flowcut/#flow-and-cut", 
            "text": "LightGraphs.jl  provides different algorithms for  maximum flow  and minimum cut computations.  #  LightGraphs     Module .  LightGraphs  An optimized graphs package.  Simple graphs (not multi- or hypergraphs) are represented in a memory- and time-efficient manner with adjacency lists and edge sets. Both directed and undirected graphs are supported via separate types, and conversion is available from directed to undirected.  The project goal is to mirror the functionality of robust network and graph analysis libraries such as NetworkX while being simpler to use and more efficient than existing Julian graph libraries such as Graphs.jl. It is an explicit design decision that any data not required for graph manipulation (attributes and other information, for example) is expected to be stored outside of the graph structure itself. Such data lends itself to storage in more traditional and better-optimized mechanisms.  Full documentation  is available, and tutorials are available at the  JuliaGraphsTutorials repository .  source  #  LightGraphs.Nonbacktracking     Type .  Nonbacktracking{G}  A compact representation of the nonbacktracking operator.  The Nonbacktracking operator can be used for community detection. This representation is compact in that it uses only ne(g) additional storage and provides an implicit representation of the matrix B_g defined below.  Given two arcs $A_{i j} and A_{k l} in g`, the non-backtraking matrix$B`` is defined as  $B_{A_{i j}, A_{k l}} = \u03b4_{j k} * (1 - \u03b4_{i l})$  This type is in the style of GraphMatrices.jl and supports the necessary operations for computed eigenvectors and conducting linear solves.  Additionally the  contract!(vertexspace, nbt, edgespace)  method takes vectors represented in the domain of $B$ and represents them in the domain of the adjacency matrix of  g .  source  #  LightGraphs.AbstractEdge     Type .  AbstractEdge  An absract type representing a single edge between two vertices of a graph.  source  #  LightGraphs.AbstractGraph     Type .  AbstractGraph  An abstract type representing a graph.  source  #  LightGraphs.BoykovKolmogorovAlgorithm     Type .  BoykovKolmogorovAlgorithm  : AbstractFlowAlgorithm  Forces the maximum_flow function to use the Boykov-Kolmogorov algorithm.  source  #  LightGraphs.BreadthFirst     Type .  BreadthFirst  Conventions in Breadth First Search and Depth First Search  VertexColorMap   color == 0    =  unseen  color   0     =  examined but not closed  color   0     =  examined and closed   EdgeColorMap   color == 0    =  unseen  color == 1    =  examined   source  #  LightGraphs.DepthFirst     Type .  DepthFirst  Conventions in Breadth First Search and Depth First Search  VertexColorMap   color == 0    =  unseen  color   0     =  examined but not closed  color   0     =  examined and closed   EdgeColorMap   color == 0    =  unseen  color == 1     =  examined   source  #  LightGraphs.DinicAlgorithm     Type .  DinicAlgorithm  : AbstractFlowAlgorithm  Forces the maximum_flow function to use Dinic's algorithm.  source  #  LightGraphs.EdmondsKarpAlgorithm     Type .  EdmondsKarpAlgorithm  : AbstractFlowAlgorithm  Forces the maximum_flow function to use the Edmonds\u2013Karp algorithm.  source  #  LightGraphs.ExtendedMultirouteFlowAlgorithm     Type .  ExtendedMultirouteFlowAlgorithm  Used to specify the Extended Multiroute Flow algorithm.  source  #  LightGraphs.KishimotoAlgorithm     Type .  KishimotoAlgorithm  Used to specify the Kishimoto algorithm.  source  #  LightGraphs.PushRelabelAlgorithm     Type .  Forces the maximum_flow function to use the Push-Relabel algorithm.  source  #  Base.SparseArrays.blkdiag     Method .  blkdiag(g, h)  Return a graph with $|V(g)| + |V(h)|$ vertices and $|E(g)| + |E(h)|$ edges where the vertices an edges from graph  h  are appended to graph  g .  Implementation Notes  Preserves the eltype of the input graph. Will error if the number of vertices in the generated graph exceeds the eltype.  source  #  Base.intersect     Method .  intersect(g, h)  Return a graph with edges that are only in both graph  g  and graph  h .  Implementation Notes  This function may produce a graph with 0-degree vertices. Preserves the eltype of the input graph.  source  #  Base.join     Method .  join(g, h)  Return a graph that combines graphs  g  and  h  using  blkdiag  and then adds all the edges between the vertices in  g  and those in  h .  Implementation Notes  Preserves the eltype of the input graph. Will error if the number of vertices in the generated graph exceeds the eltype.  source  #  Base.reverse     Function .  reverse(g)  Return a directed graph where all edges are reversed from the original directed graph.  Implementation Notes  Preserves the eltype of the input graph.  source  #  Base.reverse!     Function .  reverse!(g)  In-place reverse of a directed graph (modifies the original graph).  source  #  Base.reverse     Method .  reverse(e)  Create a new edge from  e  with source and destination vertices reversed.  source  #  Base.union     Method .  union(g, h)  Return a graph that combines graphs  g  and  h  by taking the set union of all vertices and edges.  Implementation Notes  Preserves the eltype of the input graph. Will error if the number of vertices in the generated graph exceeds the eltype.  source  #  LightGraphs.a_star     Method .  a_star(g, s, t[, distmx][, heuristic])  Return a vector of edges comprising the shortest path between vertices  s  and  t  using the  A* search algorithm . An optional heuristic function and edge distance matrix may be supplied. If missing, the distance matrix is set to  DefaultDistance  and the heuristic is set to  n -  0 .  source  #  LightGraphs.add_edge!     Method .  add_edge!(g, e)  Add a new edge  e  to  g . Return false if add fails (e.g., if vertices are not in the graph, or edge already exists), true otherwise.  source  #  LightGraphs.add_vertex!     Method .  add_vertex!(g)  Add a new vertex to the graph  g . Return true if the vertex was added successfully, false otherwise.  source  #  LightGraphs.articulation     Method .  articulation(g)  Compute the  articulation points  of a connected graph  g  and return an array containing all cut vertices.  source  #  LightGraphs.bellman_ford_shortest_paths     Method .  bellman_ford_shortest_paths(g, s, distmx=DefaultDistance())\nbellman_ford_shortest_paths(g, ss, distmx=DefaultDistance())  Compute shortest paths between a source  s  (or list of sources  ss ) and all other nodes in graph  g  using the  Bellman-Ford algorithm . Return a  BellmanFordState  with relevant traversal information.  source  #  LightGraphs.bfs_tree     Method .  bfs_tree(g, s)  Provide a breadth-first traversal of the graph  g  starting with source vertex  s , and return a directed acyclic graph of vertices in the order they were discovered.  Implementation Notes  This function is a high level wrapper around  bfs_tree! ; use that function for more performance.  source  #  LightGraphs.bfs_tree     Method .  bfs_tree(LevelSynchronousBFS(), g, s, nv)  Provide a parallel breadth-first traversal of the graph  g  starting with source vertex  s , and return a directed acyclic graph of vertices in the order they were discovered using a frontier based parallel approach.  Implementation Notes  This function uses  @threads  for parallelism which depends on the  JULIA_NUM_THREADS  environment variable to decide the number of threads to use. Refer  @threads  documentation for more details. This function is a high level wrapper around  bfs_tree! ; use that function for more performance.  source  #  LightGraphs.biconnected_components     Function .  biconnected_components(g)  Compute the  biconnected components  of an undirected graph  g and return a vector of vectors containing each biconnected component.  Performance: Time complexity is $\\mathcal{O}(|V|)$.  source  #  LightGraphs.bipartite_map     Method .  bipartite_map(g)  For a bipartite graph  g , return a vector  c  of size $|V|$ containing the assignment of each vertex to one of the two sets ($c_i == 1$ or c_i == 2 `). If g` is not bipartite, return an empty vector.  source  #  LightGraphs.cartesian_product     Method .  cartesian_product(g, h)  Return the (cartesian product)[https://en.wikipedia.org/wiki/Tensor_product_of_graphs] of  g  and  h .  Implementation Notes  Preserves the eltype of the input graph. Will error if the number of vertices in the generated graph exceeds the eltype.  source  #  LightGraphs.complement     Method .  complement(g)  Return the  graph complement  of a graph  Implementation Notes  Preserves the eltype of the input graph.  source  #  LightGraphs.contract!     Method .  contract!(vertexspace, nbt, edgespace)  The mutating version of  contract(nbt, edgespace) . Modifies  vertexspace .  source  #  LightGraphs.contract     Method .  contract(nbt, edgespace)  Integrate out the edges by summing over the edges incident to each vertex.  source  #  LightGraphs.core_periphery_deg     Function .  core_periphery_deg(g)  Compute the degree-based core-periphery for graph  g . Return the vertex assignments ( 1  for core and  2  for periphery) for each node in  g .  References:      Lip )  source  #  LightGraphs.crosspath     Function .  crosspath(len::Integer, g::Graph)  Return a graph that duplicates  g   len  times and connects each vertex with its copies in a path.  Implementation Notes  Preserves the eltype of the input graph. Will error if the number of vertices in the generated graph exceeds the eltype.  source  #  LightGraphs.dfs_tree     Method .  dfs_tree(g, s)  Return an ordered vector of vertices representing a directed acylic graph based on depth-first traversal of the graph  g  starting with source vertex  s .  source  #  LightGraphs.difference     Method .  difference(g, h)  Return a graph with edges in graph  g  that are not in graph  h .  Implementation Notes  Note that this function may produce a graph with 0-degree vertices. Preserves the eltype of the input graph.  source  #  LightGraphs.dijkstra_shortest_paths     Method .  dijkstra_shortest_paths(g, srcs, distmx=DefaultDistance());  Perform  Dijkstra's algorithm  on a graph, computing shortest distances between  srcs  and all other vertices. Return a  DijkstraState  that contains various traversal information.  Optional Arguments   allpaths=false : If true, returns a  DijkstraState  that keeps track of all   predecessors of a given vertex.  source  #  LightGraphs.dst     Method .  dst(e)  Return the destination vertex of edge  e .  source  #  LightGraphs.edges     Method .  edges(g)  Return (an iterator to or collection of) the edges of a graph.  Implementation Notes  A returned iterator is valid for one pass over the edges, and is invalidated by changes to  g .  source  #  LightGraphs.edgetype     Method .  edgetype(g)  Return the type of graph  g 's edge  source  #  LightGraphs.egonet     Method .  egonet(g, v:, d)  Return the subgraph of  g  induced by the neighbors of  v  up to distance  d . This is equivalent to  induced_subgraph (g, neighborhood(g, v, d, dir=dir))[1].  Optional Arguments   dir=:out : if  g  is directed, this argument specifies the edge direction   with respect to  v  (i.e.  :in  or  :out ).  source  #  LightGraphs.floyd_warshall_shortest_paths     Method .  floyd_warshall_shortest_paths(g, distmx=DefaultDistance()) Use the  Floyd-Warshall algorithm  to compute the shortest paths between all pairs of vertices in graph  g  using an optional distance matrix  distmx . Return a  FloydWarshallState  with relevant traversal information.  Performance  Space complexity is on the order of $\\mathcal{O}(|V|^2)$.  source  #  LightGraphs.gdistances!     Method .  gdistances!(g, source, dists)  Fill  dists  with the geodesic distances of vertices in  g  from  source .  dists  should be a vector of length  nv(g) . Return  dists . For vertices in disconnected components the default distance is -1.  source  #  LightGraphs.gdistances     Method .  gdistances(g, source)  Return a vector filled with the geodesic distances of vertices in   g  from  source . If  source  is a collection of vertices each element should be unique. For vertices in disconnected components the default distance is -1.  source  #  LightGraphs.global_clustering_coefficient     Method .  global_clustering_coefficient(g)  Return the  global clustering coefficient  of graph  g .  source  #  LightGraphs.has_edge     Method .  has_edge(g, e)  Return true if the graph  g  has an edge  e .  source  #  LightGraphs.has_vertex     Method .  has_vertex(g, v)  Return true if  v  is a vertex of  g .  source  #  LightGraphs.in_neighbors     Method .  in_neighbors(g, v)  Return a list of all neighbors connected to vertex  v  by an incoming edge.  Implementation Notes  Returns a reference, not a copy. Do not modify result.  source  #  LightGraphs.induced_subgraph     Method .  induced_subgraph(g, vlist)\ninduced_subgraph(g, elist)  Return the subgraph of  g  induced by the vertices in   vlist  or edges in  elist  along with a vector mapping the new vertices to the old ones (the  vertex  i  in the subgraph corresponds to the vertex  vmap[i]  in  g .)  The returned graph has  length(vlist)  vertices, with the new vertex  i  corresponding to the vertex of the original graph in the  i -th position of  vlist .  Usage Examples  julia  g = CompleteGraph(10)\n\njulia  sg, vmap = induced_subgraph(g, 5:8)\n\njulia  @assert g[5:8] == sg\n\njulia  @assert nv(sg) == 4\n\njulia  @assert ne(sg) == 6\n\njulia  @assert vm[4] == 8\n\njulia  sg, vmap = induced_subgraph(g, [2,8,3,4])\n\njulia  @assert sg == g[[2,8,3,4]]\n\njulia  elist = [Edge(1,2), Edge(3,4), Edge(4,8)]\n\njulia  sg, vmap = induced_subgraph(g, elist)\n\njulia  @assert sg == g[elist]  source  #  LightGraphs.is_bipartite     Method .  is_bipartite(g[, v])  Return  true  if graph  g  is  bipartite . If a node  v  is specified, only the connected component to which it belongs is considered.  source  #  LightGraphs.kruskal_mst     Function .  kruskal_mst(g, distmx=DefaultDistance())  Return a vector of edges representing the minimum spanning tree of a connected, undirected graph  g  with optional distance matrix  distmx  using  Kruskal's algorithm .  source  #  LightGraphs.label_propagation     Function .  label_propagation(g, maxiter=1000)  Community detection using the label propagation algorithm. Return two vectors: the first is the label number assigned to each node, and the second is the convergence history for each node. Will return after  maxiter  iterations if convergence has not completed.  References   Raghavan et al.   source  #  LightGraphs.local_clustering     Method .  local_clustering(g, v)\nlocal_clustering(g, vs)  Return a tuple  (a, b) , where  a  is the number of triangles in the neighborhood of  v  and  b  is the maximum number of possible triangles. If a list of vertices  vs  is specified, return two vectors representing the number of triangles and the maximum number of possible triangles, respectively, for each node in the list.  This function is related to the local clustering coefficient  r  by $r=\frac{a}{b}$.  source  #  LightGraphs.local_clustering_coefficient     Method .  local_clustering_coefficient(g, v)\nlocal_clustering_coefficient(g, vs)  Return the  local clustering coefficient  for node  v  in graph  g . If a list of vertices  vs  is specified, return a vector of coefficients for each node in the list.  source  #  LightGraphs.maximal_cliques     Function .  maximal_cliques(g)  Return a vector of vectors representing the node indices in each of the maximal cliques found in the undirected graph  g .  julia  using LightGraphs\njulia  g = Graph(3)\njulia  add_edge!(g, 1, 2)\njulia  add_edge!(g, 2, 3)\njulia  maximal_cliques(g)\n2-element Array{Array{Int64,N},1}:\n [2,3]\n [2,1]  source  #  LightGraphs.maximum_adjacency_visit     Method .  maximum_adjacency_visit(g[, distmx][, log][, io])  Return the vertices in  g  traversed by maximum adjacency search. An optional  distmx  matrix may be specified; if omitted, edge distances are assumed to be 1. If  log  (default  false ) is  true , visitor events will be printed to  io , which defaults to  STDOUT ; otherwise, no event information will be displayed.  source  #  LightGraphs.maximum_flow     Function .  maximum_flow(flow_graph, source, target[, capacity_matrix][, algorithm][, restriction])  Generic maximum_flow function for  flow_graph  from  source  to  target  with capacities in  capacity_matrix . Uses flow algorithm  algorithm  and cutoff restriction  restriction .   If  capacity_matrix  is not specified,  DefaultCapacity(flow_graph)  will be used.  If  algorithm  is not specified, it will default to  PushRelabelAlgorithm .  If  restriction  is not specified, it will default to  0 .   Return a tuple of (maximum flow, flow matrix). For the Boykov-Kolmogorov algorithm, the associated mincut is returned as a third output.  Usage Example:  julia  flow_graph = DiGraph(8) # Create a flow-graph\njulia  flow_edges = [\n(1,2,10),(1,3,5),(1,4,15),(2,3,4),(2,5,9),\n(2,6,15),(3,4,4),(3,6,8),(4,7,16),(5,6,15),\n(5,8,10),(6,7,15),(6,8,10),(7,3,6),(7,8,10)\n]\n\njulia  capacity_matrix = zeros(Int, 8, 8)  # Create a capacity matrix\n\njulia  for e in flow_edges\n    u, v, f = e\n    add_edge!(flow_graph, u, v)\n    capacity_matrix[u,v] = f\nend\n\njulia  f, F = maximum_flow(flow_graph, 1, 8) # Run default maximum_flow without the capacity_matrix\n\njulia  f, F = maximum_flow(flow_graph, 1, 8) # Run default maximum_flow with the capacity_matrix\n\njulia  f, F = maximum_flow(flow_graph,1,8,capacity_matrix,algorithm=EdmondsKarpAlgorithm()) # Run Edmonds-Karp algorithm\n\njulia  f, F = maximum_flow(flow_graph,1,8,capacity_matrix,algorithm=DinicAlgorithm()) # Run Dinic's algorithm\n\njulia  f, F, labels = maximum_flow(flow_graph,1,8,capacity_matrix,algorithm=BoykovKolmogorovAlgorithm()) # Run Boykov-Kolmogorov algorithm  source  #  LightGraphs.maxsimplecycles     Function .  maxsimplecycles(dg::::IsDirected, byscc::Bool = true)  Compute the theoretical maximum number of cycles in the directed graph  dg .  The computation can be performed assuming the graph is complete or taking into account the decomposition in strongly connected components ( byscc  parameter). The formula is coming from  Johnson, 1973 .  Performance  A more efficient version is possible.  References   Johnson   source  #  LightGraphs.maxsimplecycles     Method .  maxsimplecycles(n::Integer)  Compute the theoretical maximum number of cycles in a directed graph of  n  vertices, assuming there are no self-loops. The formula is coming from  Johnson, 1973 .  References   Johnson .   source  #  LightGraphs.mincut     Method .  mincut(g, distmx=DefaultDistance())  Return a tuple  (parity, bestcut) , where  parity  is a vector of integer values that determines the partition in  g  (1 or 2) and  bestcut  is the weight of the cut that makes this partition. An optional  distmx  matrix may be specified; if omitted, edge distances are assumed to be 1.  source  #  LightGraphs.modularity     Function .  modularity(g, c)  Return a value representing Newman's modularity  Q  for the undirected graph  g  given the partitioning vector  c .  source  #  LightGraphs.multiroute_flow     Method .  multiroute_flow(flow_graph, source, target[, DefaultCapacity][, flow_algorithm][, mrf_algorithm][, routes])  The generic multiroute_flow function.  The output will vary depending on the input:   When the number of  route s is  0 , return the set of breaking points of   the multiroute flow.   When the number of  route s is  1 , return a flow with a set of 1-disjoint paths   (this is the classical max-flow implementation).   When the input is limited to a set of breaking points and a route value  k ,   return only the k-route flow.   Otherwise, a tuple with 1) the maximum flow and 2) the flow matrix. When the   max-flow subroutine is the Boykov-Kolmogorov algorithm, the associated mincut is returned as a third output.  When the input is a network, it requires the following arguments:   flow_graph : the input graph  source : the source vertex  target : the target vertex  capacity_matrix : matrix of edge flow capacities  flow_algorithm : keyword argument for flow algorithm  mrf_algorithm : keyword argument for multiroute flow algorithm  routes : keyword argument for the number of routes   When the input is only the set of (breaking) points and the number of route, it requires the following arguments:   breakingpoints : vector of breaking points  routes : number of routes   When the input is the set of (breaking) points, the number of routes, and the network descriptors, it requires the following arguments:   breakingpoints : vector of breaking points  routes : number of routes  flow_graph : the input graph  source : the source vertex  target : the target vertex  capacity_matrix : matrix of edge flow capacities  flow_algorithm : keyword argument for flow algorithm   The function defaults to the Push-relabel (classical flow) and Kishimoto (multiroute) algorithms. Alternatively, the algorithms to be used can also be specified through  keyword arguments. A default capacity of  1  is assumed for each link if no capacity matrix is provided.  The  mrf_algorithm  keyword is inforced to Extended Multiroute Flow in the following cases:   The number of routes is non-integer  The number of routes is 0 or non-specified   Usage Example :  (please consult the   max_flow  section for options about flow_algorithm and capacity_matrix)  julia  flow_graph = DiGraph(8) # Create a flow graph\n\njulia  flow_edges = [\n(1, 2, 10), (1, 3, 5),  (1, 4, 15), (2, 3, 4),  (2, 5, 9),\n(2, 6, 15), (3, 4, 4),  (3, 6, 8),  (4, 7, 16), (5, 6, 15),\n(5, 8, 10), (6, 7, 15), (6, 8, 10), (7, 3, 6),  (7, 8, 10)\n]\n\njulia  capacity_matrix = zeros(Int, 8, 8) # Create a capacity matrix\n\njulia  for e in flow_edges\n    u, v, f = e\n    add_edge!(flow_graph, u, v)\n    capacity_matrix[u, v] = f\nend\n\njulia  f, F = multiroute_flow(flow_graph, 1, 8, capacity_matrix, routes = 2) # Run default multiroute_flow with an integer number of routes = 2\n\njulia  f, F = multiroute_flow(flow_graph, 1, 8, capacity_matrix, routes = 1.5) # Run default multiroute_flow with a noninteger number of routes = 1.5\n\njulia  points = multiroute_flow(flow_graph, 1, 8, capacity_matrix) # Run default multiroute_flow for all the breaking points values\n\njulia  f, F = multiroute_flow(points, 1.5) # Then run multiroute flow algorithm for any positive number of routes\n\njulia  f = multiroute_flow(points, 1.5, valueonly = true)\n\njulia  f, F, labels = multiroute_flow(flow_graph, 1, 8, capacity_matrix, algorithm = BoykovKolmogorovAlgorithm(), routes = 2) # Run multiroute flow algorithm using Boykov-Kolmogorov algorithm as max_flow routine  source  #  LightGraphs.ne     Method .  ne(g)  Return the number of edges in  g .  source  #  LightGraphs.non_backtracking_matrix     Method .  non_backtracking_matrix(g)  Return a non-backtracking matrix  B  and an edgemap storing the oriented edges' positions in  B .  Given two arcs $A_{i j} and A_{k l} in g`, the non-backtraking matrix$B`` is defined as  $B_{A_{i j}, A_{k l}} = \u03b4_{j k} * (1 - \u03b4_{i l})$  source  #  LightGraphs.non_backtracking_randomwalk     Function .  non_backtracking_randomwalk(g, s, niter)  Perform a non-backtracking random walk on directed graph  g  starting at vertex  s  and continuing for a maximum of  niter  steps. Return a vector of vertices visited in order.  source  #  LightGraphs.nv     Method .  nv(g)  Return the number of vertices in  g .  source  #  LightGraphs.out_neighbors     Method .  out_neighbors(g, v)  Return a list of all neighbors connected to vertex  v  by an outgoing edge.  Implementation Notes  Returns a reference, not a copy. Do not modify result.  source  #  LightGraphs.prim_mst     Function .  prim_mst(g, distmx=DefaultDistance())  Return a vector of edges representing the minimum spanning tree of a connected, undirected graph  g  with optional distance matrix  distmx  using  Prim's algorithm . Return a vector of edges.  source  #  LightGraphs.randomwalk     Method .  randomwalk(g, s, niter)  Perform a random walk on graph  g  starting at vertex  s  and continuing for a maximum of  niter  steps. Return a vector of vertices visited in order.  source  #  LightGraphs.rem_edge!     Method .  rem_edge!(g, e)  Remove the edge  e  from  g . Return false if edge removal fails (e.g., if edge does not exist), true otherwise.  source  #  LightGraphs.rem_vertex!     Method .  rem_vertex!(g)  Remove the vertex  v  from graph  g . Return false if removal fails (e.g., if vertex is not in the graph), true otherwise.  source  #  LightGraphs.saw     Method .  saw(g, s, niter)  Perform a  self-avoiding walk  on graph  g  starting at vertex  s  and continuing for a maximum of  niter  steps. Return a vector of vertices visited in order.  source  #  LightGraphs.simplecycles     Function .  simplecycles(dg::::IsDirected)  Compute all cycles of the given directed graph, using  Johnson, 1973 's algorithm and return them.  /! The number of cycles grow more than exponentially with the number of vertices, you might want to use the algorithm with a ceiling \u2013  getcycles  \u2013 on large directed graphs (slightly slower). If you want to have an idea of the possible number of cycles, look at function  maxsimplecycles(dg::DiGraph, byscc::Bool = true) .  References   Johnson   source  #  LightGraphs.simplecycles_hadwick_james     Function .  simplecycles_hadwick_james(g)  Find circuits (including self-loops) in  g  using the algorithm of Hadwick   James.  References   Hadwick   James, \"Enumerating Circuits and Loops in Graphs with Self-Arcs and Multiple-Arcs\", 2008   source  #  LightGraphs.simplecycles_iter     Function .  simplecycles_iter(dg::DiGraph, ceiling = 10^6)  Search all cycles of the given directed graph, using  Johnson, 1973 's algorithm, up to the ceiling (avoid memory overload).  If the graph is small, the ceiling will not be reached and $simplecycles(dg::DiGraph)$ is more efficient. It avoids the overhead of the counting and testing if the ceiling is reached. It returns all the cycles of the directed graph if the  ceiling  is not reached, a subset of them otherwise.  To get an idea of the possible number of cycles, using function  maxsimplecycles(dg::DiGraph, byscc::Bool = true)  on the directed graph.  References   Johnson   source  #  LightGraphs.simplecyclescount     Function .  simplecyclescount(dg::DiGraph, ceiling = 10^6)  Count the number of cycles in a directed graph, using  Johnson, 1973 's algorithm.  The  ceiling  is here to avoid memory overload if there are a lot of cycles in the graph. Default value is 10^6, but it can be higher or lower. You can use the function  maxsimplecycles(dg::DiGraph, byscc::Bool = true)  to get an idea of the theoretical maximum number or cycles.  Returns the minimum of the ceiling and the number of cycles.  References   Johnson   source  #  LightGraphs.simplecycleslength     Function .  simplecycleslength(dg::DiGraph, ceiling = 10^6)  Search all cycles of the given directed graph, using  Johnson, 1973 's algorithm, and return their length.  To get an idea of the possible number of cycles, using function  maxsimplecycles(dg::DiGraph, byscc::Bool = true)  on the directed graph.  It returns  cyclelengths  and  ncycles , the lengths of all cycles and the  number of cycles. The index in the array is the length of the cycle.  If the  ceiling  is reached ( ncycles = ceiling ), the output is only a subset of the cycles lengths.  References   Johnson   source  #  LightGraphs.src     Method .  src(e)  Return the source vertex of edge  e .  source  #  LightGraphs.symmetric_difference     Method .  symmetric_difference(g, h)  Return a graph with edges from graph  g  that do not exist in graph  h , and vice versa.  Implementation Notes  Note that this function may produce a graph with 0-degree vertices. Preserves the eltype of the input graph. Will error if the number of vertices in the generated graph exceeds the eltype.  source  #  LightGraphs.tensor_product     Method .  tensor_product(g, h)  Return the (tensor product)[https://en.wikipedia.org/wiki/Tensor_product_of_graphs] of  g  and  h .  Implementation Notes  Preserves the eltype of the input graph. Will error if the number of vertices in the generated graph exceeds the eltype.  source  #  LightGraphs.transitiveclosure     Function .  transitiveclosure(g, selflooped=false)  Compute the transitive closure of a directed graph, using the Floyd-Warshall algorithm. Return a graph representing the transitive closure. If  selflooped  is  true , add self loops to the graph.  Performance  Time complexity is \\mathcal{O}(|V|^3).  source  #  LightGraphs.transitiveclosure!     Function .  transitiveclosure!(g, selflooped=false)  Compute the transitive closure of a directed graph, using the Floyd-Warshall algorithm. If  selflooped  is true, add self loops to the graph.  Performance  Time complexity is \\mathcal{O}(|V|^3).  Implementation Notes  This version of the function modifies the original graph.  source  #  LightGraphs.triangles     Method .  triangles(g[, v])\ntriangles(g, vs)  Return the number of triangles in the neighborhood of node  v  in graph  g . If a list of vertices  vs  is specified, return a vector of number of triangles for each node in the list. If no vertices are specified, return the number of triangles for each node in the graph.  source  #  LightGraphs.vertices     Method .  vertices(g)  Return (an iterator to or collection of) the vertices of a graph.  Implementation Notes  A returned iterator is valid for one pass over the edges, and is invalidated by changes to  g .  source  #  LightGraphs.yen_k_shortest_paths     Method .  yen_k_shortest_paths(g, source, target, distmx=DefaultDistance(), K=1; maxdist=Inf);  Perform  Yen's algorithm  on a graph, computing k-shortest distances between  source  and  target  other vertices. Return a  YenState  that contains distances and paths.  source  #  LightGraphs.Articulations     Type .  Articulations{T}  A state type for the depth-first search that finds the articulation points in a graph.  source  #  LightGraphs.BellmanFordState     Type .  BellmanFordState{T, U}  An  AbstractPathState  designed for Bellman-Ford shortest-paths calculations.  source  #  LightGraphs.ComponentVisitorVector     Type .  ComponentVisitorVector{T}  A type of  AbstractGraphVisitor  that represents connected components with BFS starting from a given seed.  source  #  LightGraphs.DefaultCapacity     Type .  DefaultCapacity{T}  Structure that returns  1  if a forward edge exists in  flow_graph , and  0  otherwise.  source  #  LightGraphs.DijkstraState     Type .  struct DijkstraState{T, U}  An  AbstractPathState  designed for Dijkstra shortest-paths calculations.  source  #  LightGraphs.FloydWarshallState     Type .  struct FloydWarshallState{T, U}  An  AbstractPathState  designed for Floyd-Warshall shortest-paths calculations.  source  #  LightGraphs.JohnsonVisitor     Type .  type JohnsonVisitor{T :Integer}  : Visitor{T}\n    stack::Vector{T}\n    blocked::BitArray\n    blockedmap::Vector{Set{T}}\nend  Composite type that regroups the information needed for Johnson's algorithm.  stack  is the stack of visited vertices.  blocked  is a boolean for each  vertex that tells whether it is blocked or not.  blockedmap  tells which  vertices to unblock if the key vertex is unblocked.  source  #  LightGraphs.JohnsonVisitor     Method .  JohnsonVisitor(dg::::IsDirected)  Constructor of the visitor, using the directed graph information.  source  #  LightGraphs.NeighComm     Type .  NeighComm{T}  Type to record neighbor labels and their counts.  source  #  LightGraphs.ThreadQueue     Type .  ThreadQueue  A thread safe queue implementation for using as the queue for BFS.  source  #  LightGraphs.TreeBFSVisitorVector     Type .  TreeBFSVisitorVector{T}  A type for representing a BFS traversal of the graph as a parents array.  source  #  LightGraphs.YenState     Type .  struct YenState{T, U}  Designed for yen k-shortest-paths calculations.  source  #  LightGraphs.AbstractEdgeIter     Type .  AbstractEdgeIter  An abstract type representing an edge iterator.  source  #  LightGraphs.AbstractFlowAlgorithm     Type .  AbstractFlowAlgorithm  Abstract type that allows users to pass in their preferred algorithm  source  #  LightGraphs.AbstractMultirouteFlowAlgorithm     Type .  AbstractMultirouteFlowAlgorithm  Abstract type that allows users to pass in their preferred algorithm.  source  #  LightGraphs.Biconnections     Type .  Biconnections  A state type for depth-first search that finds the biconnected components.  source  #  Base.SparseArrays.sparse     Method .  sparse(g)  Return the default adjacency matrix of  g .  source  #  Base.eltype     Method .  eltype(g)  Return the type of the graph's vertices (must be  : Integer)  source  #  Base.getindex     Method .  g[iter]  Return the subgraph induced by  iter . Equivalent to  induced_subgraph (g, iter)[1] .  source  #  Base.size     Method .  size(g, i)  Return the number of vertices in  g  if  i =1 or  i =2, or  1  otherwise.  source  #  Base.sum     Method .  sum(g, i)  Return a vector of indegree ( i =1) or outdegree ( i =2) values for graph  g .  source  #  Base.sum     Method .  sum(g)  Return the number of edges in  g  source  #  Base.zero     Method .  zero(g)  Return a zero-vertex, zero-edge version of the same type of graph as  g .  source  #  LightGraphs.approximately_equal     Method .  approximately_equal(a, b)  Return true if each element in the tuple is approximately equal to its counterpart.  Implementation Notes:  This is a separate function because we don't want to hijack isapprox for tuples.  source  #  LightGraphs.augment_path!     Method .  augment_path!(path, flow_matrix, capacity_matrix)  Calculate the amount by which flow can be augmented in the given path. Augment the flow and returns the augment value.  source  #  LightGraphs.auxiliaryPoints     Function .  auxiliaryPoints(flow_graph, source, target, capacity_matrix)  Output a set of (point, slope) that compose the restricted max-flow function of  flow_graph  from  source to target using capacities in capacity_matrix`.  Performance  One point by possible slope is enough (hence mathcal{O}(\u03bb\u00d7max_flow) complexity).  source  #  LightGraphs.bfs_tree!     Method .  bfs_tree!(LevelSynchronousBFS(), g, src, parents)  Provide a parallel breadth-first traversal of the graph  g  starting with source vertex  s , and return a parents array. The returned array is an Array of  Atomic  integers.  Implementation Notes  This function uses  @threads  for parallelism which depends on the  JULIA_NUM_THREADS  environment variable to decide the number of threads to use. Refer  @threads  documentation for more details.  source  #  LightGraphs.blocking_flow!     Function .  blocking_flow!(residual_graph, source, target, capacity_matrix, flow-matrix, P)  Like  blocking_flow , but requires a preallocated parent vector  P .  source  #  LightGraphs.blocking_flow     Method .  blocking_flow(residual_graph, source, target, capacity_matrix, flow-matrix)  Use BFS to identify a blocking flow in the  residual_graph  with current flow matrix  flow_matrix and then backtrack from  target  to  source , augmenting flow along all possible paths.  source  #  LightGraphs.boykov_kolmogorov_impl     Function .  boykov_kolmogorov_impl(residual_graph, source, target, capacity_matrix)  Compute the max-flow/min-cut between  source  and  target  for  residual_graph  using the Boykov-Kolmogorov algorithm.  Return the maximum flow in the network, the flow matrix and the partition  {S,T}  in the form of a vector of 0's, 1's and 2's.  References   BOYKOV, Y.; KOLMOGOROV, V., 2004. An Experimental Comparison of   Min-Cut/Max-Flow Algorithms for Energy Minimization in Vision.  Author   J\u00falio Hoffimann Mendes (juliohm@stanford.edu)   source  #  LightGraphs.breakingPoints     Function .  breakingPoints(flow_graph::::IsDirected, source, target, capacity_matrix)  Calculates the breaking of the restricted max-flow from a set of auxiliary points for  flow_graph  from  source to target using capacities in capacity_matrix`.  source  #  LightGraphs.circuit     Function .  circuit{T :Integer}(v::T, dg::::IsDirected, vis::JohnsonVisitor{T}, \nallcycles::Vector{Vector{T}}, vmap::Vector{T}, startnode::T = v)  One step of the recursive version of simple cycle detection, using a DFS algorithm.  The CIRCUIT function from  Johnson, 1973 , recursive version. Modify the vector of cycles, when needed.   v : the vertex considered in this iteration of the DFS  dg : the digraph from which cycles are computed   visitor : Informations needed for the cycle computation, contains:   stack : the stack of parent vertices  blocked : tells whether a vertex has already been explored or not  blockedmap : mapping of the blocking / unblocking consequences  allcycles : output containing the cycles already detected  vmap : vector map containing the link from the old to the new nodes of the directed graph  startnode = v : optional argument giving the starting node. In the first iteration,     the same as v, otherwise it should be passed.  References   Johnson   source  #  LightGraphs.circuit_iter     Function .  circuit_iter{T :Integer}(v::T, dg::::IsDirected, vis::JohnsonVisitor{T}, \nvmap::Vector{T}, cycle::Channel, startnode::T = v)  One step of the recursive version of simple cycle detection, using a DFS algorithm.  The CIRCUIT function from  Johnson, 1973 's algorithm,  recursive and iterative version. Produce a cycle when needed, can be used only inside a  Channel.  Arguments   v: the vertex considered in this iteration of the DFS  dg: the digraph from which cycles are computed   visitor: Informations needed for the cycle computation, contains:   stack: the stack of parent vertices  blocked: tells whether a vertex has already been explored or not  blockedmap: mapping of the blocking / unblocking consequences  vmap : vector map containing the link from the old to the new nodes of the directed graph  cycle : storage of the channel  startnode = v: optional argument giving the starting node. In the first iteration,     the same as v, otherwise it should be passed.  Returns   done: tells whether a circuit has been found in the current exploration.   References   Johnson   source  #  LightGraphs.circuit_recursive!     Function .  circuit_recursive!(g, v1, v2, blocked, B, stack, cycles)  Find circuits in  g  recursively starting from v1.  source  #  LightGraphs.components     Method .  components(labels)  Given a vector of component labels, return a vector of vectors representing the vertices associated with a given component id.  source  #  LightGraphs.components_dict     Method .  components_dict(labels)  Convert an array of labels to a map of component id to vertices, and return a map with each key corresponding to a given component id and each value containing the vertices associated with that component.  source  #  LightGraphs.connected_components!     Function .  connected_components!(label, g)  Fill  label  with the  id  of the connected component in the undirected graph  g  to which it belongs. Return a vector representing the component assigned to each vertex. The component value is the smallest vertex ID in the component.  source  #  LightGraphs.dinic_impl     Function .  function dinic_impl(residual_graph, source, target, capacity_matrix)  Compute the maximum flow between the  source  and  target  for  residual_graph  with edge flow capacities in  capacity_matrix  using  Dinic's Algorithm . Return the value of the maximum flow as well as the final flow matrix.  source  #  LightGraphs.discharge!     Function .  discharge!(residual_graph, v, capacity_matrix, flow_matrix, excess, height, active, count, Q)  Drain the excess flow out of node  v . Run the gap heuristic or relabel the vertex if the excess remains non-zero.  source  #  LightGraphs.edmonds_karp_impl     Function .  edmonds_karp_impl(residual_graph, source, target, capacity_matrix)  Compute the maximum flow in flow graph  residual_graph  between  source  and  target  and capacities defined in  capacity_matrix  using the  Edmonds-Karp algorithm . Return the value of the maximum flow as well as the final flow matrix.  source  #  LightGraphs.emrf     Function .  emrf(flow_graph, source, target, capacity_matrix, flow_algorithm, routes=0)  Compute the maximum multiroute flow (for any number of  route s) between  source  and  target  in  flow_graph  via flow algorithm  flow_algorithm .  If a number of routes is given, return the value of the multiroute flow as well as the final flow matrix, along with a multiroute cut if the Boykov-Kolmogorov max-flow algorithm is used as a subroutine. Otherwise, return the vector of breaking points of the parametric multiroute flow function.  References   Extended Multiroute Flow algorithm   source  #  LightGraphs.enqueue_vertex!     Method .  enqueue_vertex!(Q, v, active, excess)  Push inactive node  v  into queue  Q  and activates it. Requires preallocated  active  and  excess  vectors.  source  #  LightGraphs.fetch_path     Function .  fetch_path(residual_graph, source, target, flow_matrix, capacity_matrix)  Use bidirectional BFS to look for augmentable paths from  source  to  target  in  residual_graph . Return the vertex where the two BFS searches intersect, the parent table of the path, the successor table of the path found, and a flag indicating success (0 =  success; 1 =  no path to target, 2 =  no path to source).  source  #  LightGraphs.fetch_path!     Function .  fetch_path!(residual_graph, source, target, flow_matrix, capacity_matrix, P, S)  Like  fetch_path , but requires preallocated parent vector  P  and successor vector  S .  source  #  LightGraphs.gap!     Function .  gap!(residual_graph, h, excess, height, active, count, Q)  Implement the push-relabel gap heuristic. Relabel all vertices above a cutoff height. Reduce the number of relabels required.  Requires arguments:   residual_graph::DiGraph                # the input graph  h::Int                                 # cutoff height  excess::AbstractVector  height::AbstractVector{Int}  active::AbstractVector{Bool}  count::AbstractVector{Int}  Q::AbstractVector   source  #  LightGraphs.intersection     Method .  intersection(points, k)  Return the intersection of a set of line segments and a line of slope  k  passing by the origin. Segments are defined as a triple (x, y, slope).  source  #  LightGraphs.intersection     Method .      intersection(x1, y1, a1, x2, y2, a2)  Return the intersection of two lines defined by  x  and  y  with slopes  a .   A set of segments and a linear function of slope k passing by the origin.   Requires argument:     x1, y1, a1, x2, y2, a2::T :AbstractFloat # Coordinates/slopes      points::Vector{Tuple{T, T, Int}}         # vector of points with T :AbstractFloat     k::R :Real                             # number of routes (slope of the line)    source  #  LightGraphs.itercycles     Function .  itercycles(dg::::IsDirected, cycle::Channel)  Compute all cycles of the given directed graph, using  Johnson, 1973 's algorithm.  Iterative version of the algorithm, using Channels to stop the exploration after a given number of cycles.  References   Johnson   source  #  LightGraphs.kishimoto     Function .  kishimoto(flow_graph, source, target, capacity_matrix, flow_algorithm, routes)  Compute the maximum multiroute flow (for an integer number of  route s) between  source  and  target  in  flow_graph  with capacities in  capacity_matrix  using the  Kishimoto algorithm . Return the value of the multiroute flow as well as the final flow matrix, along with a multiroute cut if Boykov-Kolmogorov is used as a subroutine.  source  #  LightGraphs.loadlg_mult     Method .  loadlg_mult(io)  Return a dictionary of (name= graph) loaded from IO stream  io .  source  #  LightGraphs.minmaxCapacity     Method .  minmaxCapacity(capacity_matrix)  Return the nonzero min and max function of  capacity_matrix .  Note: this is more efficient than maximum() / minimum() / extrema() since we have to ignore zero values.  source  #  LightGraphs.ncycles_n_i     Method .  ncycles_n_i(n::Integer, i::Integer)  Compute the theoretical maximum number of cycles of size  i  in a directed graph of  n   vertices.  source  #  LightGraphs.nearbipartiteaffinity     Method .  nearbipartiteaffinity(sizes, between, intra)  Construct the affinity matrix for a near bipartite SBM.  between  is the affinity between the two parts of each bipartite community.  intra  is the probability of an edge within the parts of the partitions.  This is a specific type of SBM with  `\\frac{k}{2} blocks each with two halves. Each half is connected as a random bipartite graph with probability intra The blocks are connected with probability between`.  source  #  LightGraphs.noallocextreme     Method .  noallocextreme(f, comparison, initial, g)  Compute the extreme value of  [f(g,i) for i=i:nv(g)]  without gathering them all  source  #  LightGraphs.push_flow!     Function .  push_flow!(residual_graph, u, v, capacity_matrix, flow_matrix, excess, height, active, Q)  Using  residual_graph  with capacities in  capacity_matrix , push as much flow as possible through the given edge( u ,  v ). Requires preallocated  flow_matrix  matrix, and  excess ,  height, active , and Q` vectors.  source  #  LightGraphs.push_relabel     Function .  push_relabel(residual_graph, source, target, capacity_matrix)  Return the maximum flow of  residual_graph  from  source  to  target  using the FIFO push relabel algorithm with gap heuristic.  Performance  Takes approximately $\\mathcal{O}(|V|^{3})$ time.  source  #  LightGraphs.quick_find!     Method .  quick_find!(vs, p, q)  Perform  Quick-Find algorithm  on a given pair of vertices  p and  q , and make a connection between them in the vector  vs .  source  #  LightGraphs.randbn     Function .  randbn(n, p, seed=-1)  Return a binomally-distribted random number with parameters  n  and  p  and optional  seed .  References   \"Non-Uniform Random Variate Generation,\" Luc Devroye, p. 522. Retrieved via http://www.eirene.de/Devroye.pdf.  http://stackoverflow.com/questions/23561551/a-efficient-binomial-random-number-generator-code-in-java   source  #  LightGraphs.random_pair     Method .  random_pair(rng, n)  Generate a stream of random pairs in  1:n  using random number generator  RNG .  source  #  LightGraphs.range_shuffle!     Method .  range_shuffle!(r, a)  Fast shuffle Array  a  in UnitRange  r .  source  #  LightGraphs.relabel!     Function .  relabel!(residual_graph, v, capacity_matrix, flow_matrix, excess, height, active, count, Q)  Relabel a node  v  with respect to its neighbors to produce an admissable edge.  source  #  LightGraphs.resetB!     Method .  resetB!(B)  Reset B work structure.  source  #  LightGraphs.resetblocked!     Method .  resetblocked!(blocked)  Reset vector of  blocked  vertices.  source  #  LightGraphs.residual     Function .  residual(flow_graph)  Return a directed residual graph for a directed  flow_graph .  The residual graph comprises the same node list as the orginal flow graph, but ensures that for each edge (u,v), (v,u) also exists in the graph. This allows flow in the reverse direction.  If only the forward edge exists, a reverse edge is created with capacity 0. If both forward and reverse edges exist, their capacities are left unchanged. Since the capacities in  DefaultDistance  cannot be changed, an array of ones is created.  source  #  LightGraphs.sample!     Method .  sample!([rng, ]a, k)  Sample  k  element from array  a  without repetition and eventually excluding elements in  exclude .  Optional Arguments   exclude=() : elements in  a  to exclude from sampling.   Implementation Notes  Changes the order of the elements in  a . For a non-mutating version, see  sample .  source  #  LightGraphs.sample     Method .  sample([rng,] r, k)  Sample  k  element from unit range  r  without repetition and eventually excluding elements in  exclude .  Optional Arguments   exclude=() : elements in  a  to exclude from sampling.   Implementation Notes  Unlike  sample! , does not produce side effects.  source  #  LightGraphs.savelg     Method .  savelg(io, g, gname)  Write a graph  g  with name  gname  in a proprietary format to the IO stream designated by  io . Return 1 (number of graphs written).  source  #  LightGraphs.savelg_mult     Method .  savelg_mult(io, graphs)  Write a dictionary of (name= graph) to an IO stream  io , with default  GZip  compression. Return number of graphs written.  source  #  LightGraphs.sbmaffinity     Method .  sbmaffinity(internalp, externalp, sizes)  Produce the sbm affinity matrix with internal probabilities  internalp  and external probabilities  externalp .  source  #  LightGraphs.slope     Function .  slope(flow_graph, capacity_matrix, cut, restriction)  Return the slope of  flow_graph  using capacities in  capacity_matrix  and a cut vector  cut . The slope is initialized at 0 and is incremented for each edge whose capacity does not exceed  restriction .  source  #  LightGraphs.tree     Method .  tree(parents)  Convert a parents array into a directed graph.  source  #  LightGraphs.unblock!     Method .  unblock!(v, blocked, B)  Unblock the value  v  from the  blocked  list and remove from  B .  source  #  LightGraphs.unblock!     Method .  unblock!{T :Integer}(v::T, blocked::BitArray, B::Vector{Set{T}})  Unblock the vertices recursively.   v  is the vertex to unblock,  blocked  tells whether a vertex is blocked or  not and  B  is the map that tells if the unblocking of one vertex should  unblock other vertices.  source  #  LightGraphs.visit!     Method .  visit!(g, v, marked, pq, distmx)  Mark the vertex  v  of graph  g  true in the array  marked  and enter all its edges into priority queue  pq  with its  distmx  values as a PrimHeapEntry.  source  #  LightGraphs.visit!     Method .  visit!(g, state, u, v)  Perform a DFS visit storing the depth and low-points of each vertex.  source  #  LightGraphs.visit!     Method .  visit!(state, g, u, v)  Perform a depth first search storing the depth (in  depth ) and low-points (in  low ) of each vertex. Call this function repeatedly to complete the DFS (see  articulation  for usage).  source  #  LightGraphs.vote!     Method .  vote!(g, m, c, u)  Return the label with greatest frequency.  source", 
            "title": "Flow and Cut"
        }, 
        {
            "location": "/generators/", 
            "text": "Generators\n\n\n\n\nRandom Graphs\n\n\nLightGraphs.jl\n implements some common random graph generators:\n\n\n#\n\n\nLightGraphs.StochasticBlockModel\n \n \nType\n.\n\n\nStochasticBlockModel{T,P}\n\n\n\n\nA type capturing the parameters of the SBM. Each vertex is assigned to a block and the probability of edge \n(i,j)\n depends only on the block labels of vertex \ni\n and vertex \nj\n.\n\n\nThe assignement is stored in nodemap and the block affinities a \nk\n by \nk\n matrix is stored in affinities.\n\n\naffinities[k,l]\n is the probability of an edge between any vertex in block \nk\n and any vertex in block \nl\n.\n\n\nImplementation Notes\n\n\nGraphs are generated by taking random $i,j \u2208 V$ and flipping a coin with probability \naffinities[nodemap[i],nodemap[j]]\n.\n\n\nsource\n\n\n#\n\n\nLightGraphs.barabasi_albert!\n \n \nMethod\n.\n\n\nbarabasi_albert!(g::AbstractGraph, n::Integer, k::Integer)\n\n\n\n\nCreate a \nBarab\u00e1si\u2013Albert model\n random graph with \nn\n vertices. It is grown by adding new vertices to an initial graph \ng\n. Each new vertex is attached with \nk\n edges to \nk\n different vertices already present in the system by preferential attachment.\n\n\nOptional Arguments\n\n\n\n\nseed=-1\n: set the RNG seed.\n\n\n\n\nsource\n\n\n#\n\n\nLightGraphs.barabasi_albert\n \n \nMethod\n.\n\n\nbarabasi_albert(n::Integer, n0::Integer, k::Integer)\n\n\n\n\nCreate a \nBarab\u00e1si\u2013Albert model\n random graph with \nn\n vertices. It is grown by adding new vertices to an initial graph with \nn0\n vertices. Each new vertex is attached with \nk\n edges to \nk\n different vertices already present in the system by preferential attachment. Initial graphs are undirected and consist of isolated vertices by default.\n\n\nOptional Arguments\n\n\n\n\nis_directed=false\n: if true, return a directed graph.\n\n\ncomplete=false\n: if true, use a complete graph for the initial graph.\n\n\nseed=-1\n: set the RNG seed.\n\n\n\n\nsource\n\n\n#\n\n\nLightGraphs.barabasi_albert\n \n \nMethod\n.\n\n\nbarabasi_albert(n, k)\n\n\n\n\nCreate a \nBarab\u00e1si\u2013Albert model\n random graph with \nn\n vertices. It is grown by adding new vertices to an initial graph with \nk\n vertices. Each new vertex is attached with \nk\n edges to \nk\n different vertices already present in the system by preferential attachment. Initial graphs are undirected and consist of isolated vertices by default.\n\n\nOptional Arguments\n\n\n\n\nis_directed=false\n: if true, return a directed graph.\n\n\ncomplete=false\n: if true, use a complete graph for the initial graph.\n\n\nseed=-1\n: set the RNG seed.\n\n\n\n\nsource\n\n\n#\n\n\nLightGraphs.blockcounts\n \n \nMethod\n.\n\n\nblockcounts(sbm, A)\n\n\n\n\nCount the number of edges that go between each block.\n\n\nsource\n\n\n#\n\n\nLightGraphs.erdos_renyi\n \n \nMethod\n.\n\n\nerdos_renyi(n, ne)\n\n\n\n\nCreate an \nErd\u0151s\u2013R\u00e9nyi\n random graph with \nn\n vertices and \nne\n edges.\n\n\nOptional Arguments\n\n\n\n\nis_directed=false\n: if true, return a directed graph.\n\n\nseed=-1\n: set the RNG seed.\n\n\n\n\nsource\n\n\n#\n\n\nLightGraphs.erdos_renyi\n \n \nMethod\n.\n\n\nerdos_renyi(n, p)\n\n\n\n\nCreate an \nErd\u0151s\u2013R\u00e9nyi\n random graph with \nn\n vertices. Edges are added between pairs of vertices with probability \np\n.\n\n\nOptional Arguments\n\n\n\n\nis_directed=false\n: if true, return a directed graph.\n\n\nseed=-1\n: set the RNG seed.\n\n\n\n\nsource\n\n\n#\n\n\nLightGraphs.make_edgestream\n \n \nMethod\n.\n\n\nmake_edgestream(sbm)\n\n\n\n\nTake an infinite sample from the Stochastic Block Model \nsbm\n. Pass to \nGraph(nvg, neg, edgestream)\n to get a Graph object based on \nsbm\n.\n\n\nsource\n\n\n#\n\n\nLightGraphs.random_configuration_model\n \n \nMethod\n.\n\n\nrandom_configuration_model(n, ks)\n\n\n\n\nCreate a random undirected graph according to the \nconfiguration model\n containing \nn\n vertices, with each node \ni\n having degree \nk[i]\n.\n\n\nOptional Arguments\n\n\n\n\nseed=-1\n: set the RNG seed.\n\n\ncheck_graphical=false\n: if true, ensure that \nk\n is a graphical sequence\n\n\n\n\n(see \nisgraphical\n).\n\n\nPerformance\n\n\nTime complexity is approximately $\\mathcal{O}(n \\bar{k}^2)$.\n\n\nImplementation Notes\n\n\nAllocates an array of $n \\bar{k}$ \nInt\ns.\n\n\nsource\n\n\n#\n\n\nLightGraphs.random_regular_digraph\n \n \nMethod\n.\n\n\nrandom_regular_digraph(n, k)\n\n\n\n\nCreate a random directed \nregular graph\n with \nn\n vertices, each with degree \nk\n.\n\n\nOptional Arguments\n\n\n\n\ndir=:out\n: the direction of the edges for degree parameter.\n\n\nseed=-1\n: set the RNG seed.\n\n\n\n\nImplementation Notes\n\n\nAllocates an $n \u00d7 n$ sparse matrix of boolean as an adjacency matrix and uses that to generate the directed graph.\n\n\nsource\n\n\n#\n\n\nLightGraphs.random_regular_graph\n \n \nMethod\n.\n\n\nrandom_regular_graph(n, k)\n\n\n\n\nCreate a random undirected \nregular graph\n with \nn\n vertices, each with degree \nk\n.\n\n\nOptional Arguments\n\n\n\n\nseed=-1\n: set the RNG seed.\n\n\n\n\nPerformance\n\n\nTime complexity is approximately $\\mathcal{O}(nk^2)$.\n\n\nImplementation Notes\n\n\nAllocates an array of \nnk\n \nInt\ns, and . For $k \n \\frac{n}{2}$, generates a graph of degree $n-k-1$ and returns its complement.\n\n\nsource\n\n\n#\n\n\nLightGraphs.static_fitness_model\n \n \nMethod\n.\n\n\nstatic_fitness_model(m, fitness_out, fitness_in)\n\n\n\n\nGenerate a random graph with $|fitness_out + fitness_in|$ vertices and \nm\n edges, in which the probability of the existence of $Edge_{ij}$ is proportional with respect to $i \u221d fitness_out$ and $j \u221d fitness_in$.\n\n\nOptional Arguments\n\n\n\n\nseed=-1\n: set the RNG seed.\n\n\n\n\nPerformance\n\n\nTime complexity is $\\mathcal{O}(|V| + |E| log |E|)$.\n\n\nReferences\n\n\n\n\nGoh K-I, Kahng B, Kim D: Universal behaviour of load distribution in scale-free networks. Phys Rev Lett 87(27):278701, 2001.\n\n\n\n\nsource\n\n\n#\n\n\nLightGraphs.static_fitness_model\n \n \nMethod\n.\n\n\nstatic_fitness_model(m, fitness)\n\n\n\n\nGenerate a random graph with $|fitness|$ vertices and \nm\n edges, in which the probability of the existence of $Edge_{ij}$ is proportional to $fitness_i  \u00d7 fitness_j$.\n\n\nOptional Arguments\n\n\n\n\nseed=-1\n: set the RNG seed.\n\n\n\n\nPerformance\n\n\nTime complexity is $\\mathcal{O}(|V| + |E| log |E|)$.\n\n\nReferences\n\n\n\n\nGoh K-I, Kahng B, Kim D: Universal behaviour of load distribution in scale-free networks. Phys Rev Lett 87(27):278701, 2001.\n\n\n\n\nsource\n\n\n#\n\n\nLightGraphs.static_scale_free\n \n \nMethod\n.\n\n\nstatic_scale_free(n, m, \u03b1_out, \u03b1_in)\n\n\n\n\nGenerate a random graph with \nn\n vertices, \nm\n edges and expected power-law degree distribution with exponent \n\u03b1_out\n for outbound edges and \n\u03b1_in\n for inbound edges.\n\n\nOptional Arguments\n\n\n\n\nseed=-1\n: set the RNG seed.\n\n\nfinite_size_correction=true\n: determines whether to use the finite size correction\n\n\n\n\nproposed by Cho et al.\n\n\nPerformance\n\n\nTime complexity is $\\mathcal{O}(|V| + |E| log |E|)$.\n\n\nReferences\n\n\n\n\nGoh K-I, Kahng B, Kim D: Universal behaviour of load distribution in scale-free networks. Phys Rev Lett 87(27):278701, 2001.\n\n\nChung F and Lu L: Connected components in a random graph with given degree sequences. Annals of Combinatorics 6, 125-145, 2002.\n\n\nCho YS, Kim JS, Park J, Kahng B, Kim D: Percolation transitions in scale-free networks under the Achlioptas process. Phys Rev Lett 103:135702, 2009.\n\n\n\n\nsource\n\n\n#\n\n\nLightGraphs.static_scale_free\n \n \nMethod\n.\n\n\nstatic_scale_free(n, m, \u03b1)\n\n\n\n\nGenerate a random graph with \nn\n vertices, \nm\n edges and expected power-law degree distribution with exponent \n\u03b1\n.\n\n\nOptional Arguments\n\n\n\n\nseed=-1\n: set the RNG seed.\n\n\nfinite_size_correction=true\n: determines whether to use the finite size correction\n\n\n\n\nproposed by Cho et al.\n\n\nPerformance\n\n\nTime complexity is $\\mathcal{O}(|V| + |E| log |E|)$.\n\n\nReferences\n\n\n\n\nGoh K-I, Kahng B, Kim D: Universal behaviour of load distribution in scale-free networks. Phys Rev Lett 87(27):278701, 2001.\n\n\nChung F and Lu L: Connected components in a random graph with given degree sequences. Annals of Combinatorics 6, 125-145, 2002.\n\n\nCho YS, Kim JS, Park J, Kahng B, Kim D: Percolation transitions in scale-free networks under the Achlioptas process. Phys Rev Lett 103:135702, 2009.\n\n\n\n\nsource\n\n\n#\n\n\nLightGraphs.stochastic_block_model\n \n \nMethod\n.\n\n\nstochastic_block_model(c, n)\n\n\n\n\nReturn a Graph generated according to the Stochastic Block Model (SBM).\n\n\nc[a,b]\n : Mean number of neighbors of a vertex in block \na\n belonging to block \nb\n.            Only the upper triangular part is considered, since the lower traingular is            determined by $c[b,a] = c[a,b] * \\frac{n[a]}{n[b]}$. \nn[a]\n : Number of vertices in block \na\n\n\nOptional Arguments\n\n\n\n\nseed=-1\n: set the RNG seed.\n\n\n\n\nFor a dynamic version of the SBM see the \nStochasticBlockModel\n type and related functions.\n\n\nsource\n\n\n#\n\n\nLightGraphs.stochastic_block_model\n \n \nMethod\n.\n\n\nstochastic_block_model(cint, cext, n)\n\n\n\n\nReturn a Graph generated according to the Stochastic Block Model (SBM), sampling from an SBM with $c_{a,a}=cint$, and $c_{a,b}=cext$.\n\n\nsource\n\n\n#\n\n\nLightGraphs.watts_strogatz\n \n \nMethod\n.\n\n\nwatts_strogatz(n, k, \u03b2)\n\n\n\n\nReturn a \nWatts-Strogatz\n small model random graph with \nn\n vertices, each with degree \nk\n. Edges are randomized per the model based on probability \n\u03b2\n.\n\n\nOptional Arguments\n\n\n\n\nis_directed=false\n: if true, return a directed graph.\n\n\nseed=-1\n: set the RNG seed.\n\n\n\n\nsource\n\n\n\n\nStatic Graphs\n\n\nLightGraphs.jl\n also implements a collection of classic graph generators:\n\n\n#\n\n\nLightGraphs.BinaryTree\n \n \nMethod\n.\n\n\nBinaryTree(k::Integer)\n\n\n\n\nCreate a \nbinary tree\n of depth \nk\n.\n\n\nsource\n\n\n#\n\n\nLightGraphs.CliqueGraph\n \n \nMethod\n.\n\n\nCliqueGraph(k, n)\n\n\n\n\nCreate a graph consisting of \nn\n connected \nk\n-cliques.\n\n\nsource\n\n\n#\n\n\nLightGraphs.CompleteBipartiteGraph\n \n \nMethod\n.\n\n\nCompleteBipartiteGraph(n1, n2)\n\n\n\n\nCreate an undirected \ncomplete bipartite graph\n with \nn1 + n2\n vertices.\n\n\nsource\n\n\n#\n\n\nLightGraphs.CompleteDiGraph\n \n \nMethod\n.\n\n\nCompleteDiGraph(n)\n\n\n\n\nCreate a directed \ncomplete graph\n with \nn\n vertices.\n\n\nsource\n\n\n#\n\n\nLightGraphs.CompleteGraph\n \n \nMethod\n.\n\n\nCompleteGraph(n)\n\n\n\n\nCreate an undirected \ncomplete graph\n with \nn\n vertices.\n\n\nsource\n\n\n#\n\n\nLightGraphs.CycleDiGraph\n \n \nMethod\n.\n\n\nCycleDiGraph(n)\n\n\n\n\nCreate a directed \ncycle graph\n with \nn\n vertices.\n\n\nsource\n\n\n#\n\n\nLightGraphs.CycleGraph\n \n \nMethod\n.\n\n\nCycleGraph(n)\n\n\n\n\nCreate an undirected \ncycle graph\n with \nn\n vertices.\n\n\nsource\n\n\n#\n\n\nLightGraphs.DoubleBinaryTree\n \n \nMethod\n.\n\n\nBinaryTree(k::Integer)\n\n\n\n\nCreate a double complete binary tree with \nk\n levels.\n\n\nReferences\n\n\n\n\nUsed as an example for spectral clustering by Guattery and Miller 1998.\n\n\n\n\nsource\n\n\n#\n\n\nLightGraphs.Grid\n \n \nMethod\n.\n\n\nGrid(dims; periodic=false)\n\n\n\n\nCreate a $|dims|$-dimensional cubic lattice, with length \ndims[i]\n in dimension \ni\n.\n\n\nOptional Arguments\n\n\n\n\nperiodic=false\n: If true, the resulting lattice will have periodic boundary\n\n\n\n\ncondition in each dimension.\n\n\nsource\n\n\n#\n\n\nLightGraphs.PathDiGraph\n \n \nMethod\n.\n\n\nPathDiGraph(n)\n\n\n\n\nCreates a directed \npath graph\n with \nn\n vertices.\n\n\nsource\n\n\n#\n\n\nLightGraphs.PathGraph\n \n \nMethod\n.\n\n\nPathGraph(n)\n\n\n\n\nCreate an undirected \npath graph\n with \nn\n vertices.\n\n\nsource\n\n\n#\n\n\nLightGraphs.RoachGraph\n \n \nMethod\n.\n\n\nRoachGraph(k)\n\n\n\n\nCreate a Roach Graph of size \nk\n.\n\n\nReferences\n\n\n\n\nGuattery and Miller 1998\n\n\n\n\nsource\n\n\n#\n\n\nLightGraphs.StarDiGraph\n \n \nMethod\n.\n\n\nStarDiGraph(n)\n\n\n\n\nCreate a directed \nstar graph\n with \nn\n vertices.\n\n\nsource\n\n\n#\n\n\nLightGraphs.StarGraph\n \n \nMethod\n.\n\n\nStarGraph(n)\n\n\n\n\nCreate an undirected \nstar graph\n with \nn\n vertices.\n\n\nsource\n\n\n#\n\n\nLightGraphs.WheelDiGraph\n \n \nMethod\n.\n\n\nWheelDiGraph(n)\n\n\n\n\nCreate a directed \nwheel graph\n with \nn\n vertices.\n\n\nsource\n\n\n#\n\n\nLightGraphs.WheelGraph\n \n \nMethod\n.\n\n\nWheelGraph(n)\n\n\n\n\nCreate an undirected \nwheel graph\n with \nn\n vertices.\n\n\nsource\n\n\n\n\nSmall Graphs\n\n\nOther classical graphs can be generated by the following function:\n\n\n#\n\n\nLightGraphs.smallgraph\n \n \nMethod\n.\n\n\nsmallgraph(s)\nsmallgraph(s)\n\n\n\n\nCreate a small graph of type \ns\n. Admissible values for \ns\n are:\n\n\n\n\n\n\n\n\ns\n\n\ngraph type\n\n\n\n\n\n\n\n\n\n\n:bull\n\n\nA \nbull graph\n.\n\n\n\n\n\n\n:chvatal\n\n\nA \nChv\u00e1tal graph\n.\n\n\n\n\n\n\n:cubical\n\n\nA \nPlatonic cubical graph\n.\n\n\n\n\n\n\n:desargues\n\n\nA \nDesarguesgraph\n.\n\n\n\n\n\n\n:diamond\n\n\nA \ndiamond graph\n.\n\n\n\n\n\n\n:dodecahedral\n\n\nA \nPlatonic dodecahedral  graph\n.\n\n\n\n\n\n\n:frucht\n\n\nA \nFrucht graph\n.\n\n\n\n\n\n\n:heawood\n\n\nA \nHeawood graph\n.\n\n\n\n\n\n\n:house\n\n\nA graph mimicing the classic outline of a house.\n\n\n\n\n\n\n:housex\n\n\nA house graph, with two edges crossing the bottom square.\n\n\n\n\n\n\n:icosahedral\n\n\nA \nPlatonic icosahedral   graph\n.\n\n\n\n\n\n\n:krackhardtkite\n\n\nA \nKrackhardt-Kite social network  graph\n.\n\n\n\n\n\n\n:moebiuskantor\n\n\nA \nM\u00f6bius-Kantor graph\n.\n\n\n\n\n\n\n:octahedral\n\n\nA \nPlatonic octahedral graph\n.\n\n\n\n\n\n\n:pappus\n\n\nA \nPappus graph\n.\n\n\n\n\n\n\n:petersen\n\n\nA \nPetersen graph\n.\n\n\n\n\n\n\n:sedgewickmaze\n\n\nA simple maze graph used in Sedgewick's \nAlgorithms in C++: Graph  Algorithms (3rd ed.)\n\n\n\n\n\n\n:tetrahedral\n\n\nA \nPlatonic tetrahedral  graph\n.\n\n\n\n\n\n\n:truncatedcube\n\n\nA skeleton of the \ntruncated cube graph\n.\n\n\n\n\n\n\n:truncatedtetrahedron\n\n\nA skeleton of the \ntruncated tetrahedron  graph\n.\n\n\n\n\n\n\n:truncatedtetrahedron_dir\n\n\nA skeleton of the \ntruncated tetrahedron digraph\n.\n\n\n\n\n\n\n:tutte\n\n\nA \nTutte graph\n.\n\n\n\n\n\n\n\n\nsource\n\n\n\n\nEuclidean Graphs\n\n\nGeneration of random and static graphs embedded in Euclidean space.\n\n\n#\n\n\nLightGraphs.euclidean_graph\n \n \nMethod\n.\n\n\neuclidean_graph(points)\n\n\n\n\nGiven the \nd\u00d7N\n matrix \npoints\n build an Euclidean graph of \nN\n vertices and return a graph and Dict containing the distance on each edge.\n\n\nOptional Arguments\n\n\n\n\nL=1\n: used to bound the \nd\n dimensional box from which points are selected.\n\n\np=2\n\n\nbc=:open\n\n\n\n\nImplementation Notes\n\n\nDefining the \nd\n-dimensional vectors \nx[i] = points[:,i]\n, an edge between vertices \ni\n and \nj\n is inserted if \nnorm(x[i]-x[j], p) \n cutoff\n. In case of negative \ncutoff\n instead every edge is inserted. For \np=2\n we have the standard Euclidean distance. Set \nbc=:periodic\n to impose periodic boundary conditions in the box $[0,L]^d$.\n\n\nsource\n\n\n#\n\n\nLightGraphs.euclidean_graph\n \n \nMethod\n.\n\n\neuclidean_graph(N, d; seed=-1, L=1., p=2., cutoff=-1., bc=:open)\n\n\n\n\nGenerate \nN\n uniformly distributed points in the box $[0,L]^{d}$ and return a Euclidean graph, a map containing the distance on each edge and a matrix with the points' positions.\n\n\nsource\n\n\n\n\nDatasets\n\n\nOther notorious graphs and integration with the \nMatrixDepot.jl\n package are available in the \nDatasets\n submodule of the companion package \nLightGraphsExtras.jl\n ```", 
            "title": "Graph Generators"
        }, 
        {
            "location": "/generators/#generators", 
            "text": "", 
            "title": "Generators"
        }, 
        {
            "location": "/generators/#random-graphs", 
            "text": "LightGraphs.jl  implements some common random graph generators:  #  LightGraphs.StochasticBlockModel     Type .  StochasticBlockModel{T,P}  A type capturing the parameters of the SBM. Each vertex is assigned to a block and the probability of edge  (i,j)  depends only on the block labels of vertex  i  and vertex  j .  The assignement is stored in nodemap and the block affinities a  k  by  k  matrix is stored in affinities.  affinities[k,l]  is the probability of an edge between any vertex in block  k  and any vertex in block  l .  Implementation Notes  Graphs are generated by taking random $i,j \u2208 V$ and flipping a coin with probability  affinities[nodemap[i],nodemap[j]] .  source  #  LightGraphs.barabasi_albert!     Method .  barabasi_albert!(g::AbstractGraph, n::Integer, k::Integer)  Create a  Barab\u00e1si\u2013Albert model  random graph with  n  vertices. It is grown by adding new vertices to an initial graph  g . Each new vertex is attached with  k  edges to  k  different vertices already present in the system by preferential attachment.  Optional Arguments   seed=-1 : set the RNG seed.   source  #  LightGraphs.barabasi_albert     Method .  barabasi_albert(n::Integer, n0::Integer, k::Integer)  Create a  Barab\u00e1si\u2013Albert model  random graph with  n  vertices. It is grown by adding new vertices to an initial graph with  n0  vertices. Each new vertex is attached with  k  edges to  k  different vertices already present in the system by preferential attachment. Initial graphs are undirected and consist of isolated vertices by default.  Optional Arguments   is_directed=false : if true, return a directed graph.  complete=false : if true, use a complete graph for the initial graph.  seed=-1 : set the RNG seed.   source  #  LightGraphs.barabasi_albert     Method .  barabasi_albert(n, k)  Create a  Barab\u00e1si\u2013Albert model  random graph with  n  vertices. It is grown by adding new vertices to an initial graph with  k  vertices. Each new vertex is attached with  k  edges to  k  different vertices already present in the system by preferential attachment. Initial graphs are undirected and consist of isolated vertices by default.  Optional Arguments   is_directed=false : if true, return a directed graph.  complete=false : if true, use a complete graph for the initial graph.  seed=-1 : set the RNG seed.   source  #  LightGraphs.blockcounts     Method .  blockcounts(sbm, A)  Count the number of edges that go between each block.  source  #  LightGraphs.erdos_renyi     Method .  erdos_renyi(n, ne)  Create an  Erd\u0151s\u2013R\u00e9nyi  random graph with  n  vertices and  ne  edges.  Optional Arguments   is_directed=false : if true, return a directed graph.  seed=-1 : set the RNG seed.   source  #  LightGraphs.erdos_renyi     Method .  erdos_renyi(n, p)  Create an  Erd\u0151s\u2013R\u00e9nyi  random graph with  n  vertices. Edges are added between pairs of vertices with probability  p .  Optional Arguments   is_directed=false : if true, return a directed graph.  seed=-1 : set the RNG seed.   source  #  LightGraphs.make_edgestream     Method .  make_edgestream(sbm)  Take an infinite sample from the Stochastic Block Model  sbm . Pass to  Graph(nvg, neg, edgestream)  to get a Graph object based on  sbm .  source  #  LightGraphs.random_configuration_model     Method .  random_configuration_model(n, ks)  Create a random undirected graph according to the  configuration model  containing  n  vertices, with each node  i  having degree  k[i] .  Optional Arguments   seed=-1 : set the RNG seed.  check_graphical=false : if true, ensure that  k  is a graphical sequence   (see  isgraphical ).  Performance  Time complexity is approximately $\\mathcal{O}(n \\bar{k}^2)$.  Implementation Notes  Allocates an array of $n \\bar{k}$  Int s.  source  #  LightGraphs.random_regular_digraph     Method .  random_regular_digraph(n, k)  Create a random directed  regular graph  with  n  vertices, each with degree  k .  Optional Arguments   dir=:out : the direction of the edges for degree parameter.  seed=-1 : set the RNG seed.   Implementation Notes  Allocates an $n \u00d7 n$ sparse matrix of boolean as an adjacency matrix and uses that to generate the directed graph.  source  #  LightGraphs.random_regular_graph     Method .  random_regular_graph(n, k)  Create a random undirected  regular graph  with  n  vertices, each with degree  k .  Optional Arguments   seed=-1 : set the RNG seed.   Performance  Time complexity is approximately $\\mathcal{O}(nk^2)$.  Implementation Notes  Allocates an array of  nk   Int s, and . For $k   \\frac{n}{2}$, generates a graph of degree $n-k-1$ and returns its complement.  source  #  LightGraphs.static_fitness_model     Method .  static_fitness_model(m, fitness_out, fitness_in)  Generate a random graph with $|fitness_out + fitness_in|$ vertices and  m  edges, in which the probability of the existence of $Edge_{ij}$ is proportional with respect to $i \u221d fitness_out$ and $j \u221d fitness_in$.  Optional Arguments   seed=-1 : set the RNG seed.   Performance  Time complexity is $\\mathcal{O}(|V| + |E| log |E|)$.  References   Goh K-I, Kahng B, Kim D: Universal behaviour of load distribution in scale-free networks. Phys Rev Lett 87(27):278701, 2001.   source  #  LightGraphs.static_fitness_model     Method .  static_fitness_model(m, fitness)  Generate a random graph with $|fitness|$ vertices and  m  edges, in which the probability of the existence of $Edge_{ij}$ is proportional to $fitness_i  \u00d7 fitness_j$.  Optional Arguments   seed=-1 : set the RNG seed.   Performance  Time complexity is $\\mathcal{O}(|V| + |E| log |E|)$.  References   Goh K-I, Kahng B, Kim D: Universal behaviour of load distribution in scale-free networks. Phys Rev Lett 87(27):278701, 2001.   source  #  LightGraphs.static_scale_free     Method .  static_scale_free(n, m, \u03b1_out, \u03b1_in)  Generate a random graph with  n  vertices,  m  edges and expected power-law degree distribution with exponent  \u03b1_out  for outbound edges and  \u03b1_in  for inbound edges.  Optional Arguments   seed=-1 : set the RNG seed.  finite_size_correction=true : determines whether to use the finite size correction   proposed by Cho et al.  Performance  Time complexity is $\\mathcal{O}(|V| + |E| log |E|)$.  References   Goh K-I, Kahng B, Kim D: Universal behaviour of load distribution in scale-free networks. Phys Rev Lett 87(27):278701, 2001.  Chung F and Lu L: Connected components in a random graph with given degree sequences. Annals of Combinatorics 6, 125-145, 2002.  Cho YS, Kim JS, Park J, Kahng B, Kim D: Percolation transitions in scale-free networks under the Achlioptas process. Phys Rev Lett 103:135702, 2009.   source  #  LightGraphs.static_scale_free     Method .  static_scale_free(n, m, \u03b1)  Generate a random graph with  n  vertices,  m  edges and expected power-law degree distribution with exponent  \u03b1 .  Optional Arguments   seed=-1 : set the RNG seed.  finite_size_correction=true : determines whether to use the finite size correction   proposed by Cho et al.  Performance  Time complexity is $\\mathcal{O}(|V| + |E| log |E|)$.  References   Goh K-I, Kahng B, Kim D: Universal behaviour of load distribution in scale-free networks. Phys Rev Lett 87(27):278701, 2001.  Chung F and Lu L: Connected components in a random graph with given degree sequences. Annals of Combinatorics 6, 125-145, 2002.  Cho YS, Kim JS, Park J, Kahng B, Kim D: Percolation transitions in scale-free networks under the Achlioptas process. Phys Rev Lett 103:135702, 2009.   source  #  LightGraphs.stochastic_block_model     Method .  stochastic_block_model(c, n)  Return a Graph generated according to the Stochastic Block Model (SBM).  c[a,b]  : Mean number of neighbors of a vertex in block  a  belonging to block  b .            Only the upper triangular part is considered, since the lower traingular is            determined by $c[b,a] = c[a,b] * \\frac{n[a]}{n[b]}$.  n[a]  : Number of vertices in block  a  Optional Arguments   seed=-1 : set the RNG seed.   For a dynamic version of the SBM see the  StochasticBlockModel  type and related functions.  source  #  LightGraphs.stochastic_block_model     Method .  stochastic_block_model(cint, cext, n)  Return a Graph generated according to the Stochastic Block Model (SBM), sampling from an SBM with $c_{a,a}=cint$, and $c_{a,b}=cext$.  source  #  LightGraphs.watts_strogatz     Method .  watts_strogatz(n, k, \u03b2)  Return a  Watts-Strogatz  small model random graph with  n  vertices, each with degree  k . Edges are randomized per the model based on probability  \u03b2 .  Optional Arguments   is_directed=false : if true, return a directed graph.  seed=-1 : set the RNG seed.   source", 
            "title": "Random Graphs"
        }, 
        {
            "location": "/generators/#static-graphs", 
            "text": "LightGraphs.jl  also implements a collection of classic graph generators:  #  LightGraphs.BinaryTree     Method .  BinaryTree(k::Integer)  Create a  binary tree  of depth  k .  source  #  LightGraphs.CliqueGraph     Method .  CliqueGraph(k, n)  Create a graph consisting of  n  connected  k -cliques.  source  #  LightGraphs.CompleteBipartiteGraph     Method .  CompleteBipartiteGraph(n1, n2)  Create an undirected  complete bipartite graph  with  n1 + n2  vertices.  source  #  LightGraphs.CompleteDiGraph     Method .  CompleteDiGraph(n)  Create a directed  complete graph  with  n  vertices.  source  #  LightGraphs.CompleteGraph     Method .  CompleteGraph(n)  Create an undirected  complete graph  with  n  vertices.  source  #  LightGraphs.CycleDiGraph     Method .  CycleDiGraph(n)  Create a directed  cycle graph  with  n  vertices.  source  #  LightGraphs.CycleGraph     Method .  CycleGraph(n)  Create an undirected  cycle graph  with  n  vertices.  source  #  LightGraphs.DoubleBinaryTree     Method .  BinaryTree(k::Integer)  Create a double complete binary tree with  k  levels.  References   Used as an example for spectral clustering by Guattery and Miller 1998.   source  #  LightGraphs.Grid     Method .  Grid(dims; periodic=false)  Create a $|dims|$-dimensional cubic lattice, with length  dims[i]  in dimension  i .  Optional Arguments   periodic=false : If true, the resulting lattice will have periodic boundary   condition in each dimension.  source  #  LightGraphs.PathDiGraph     Method .  PathDiGraph(n)  Creates a directed  path graph  with  n  vertices.  source  #  LightGraphs.PathGraph     Method .  PathGraph(n)  Create an undirected  path graph  with  n  vertices.  source  #  LightGraphs.RoachGraph     Method .  RoachGraph(k)  Create a Roach Graph of size  k .  References   Guattery and Miller 1998   source  #  LightGraphs.StarDiGraph     Method .  StarDiGraph(n)  Create a directed  star graph  with  n  vertices.  source  #  LightGraphs.StarGraph     Method .  StarGraph(n)  Create an undirected  star graph  with  n  vertices.  source  #  LightGraphs.WheelDiGraph     Method .  WheelDiGraph(n)  Create a directed  wheel graph  with  n  vertices.  source  #  LightGraphs.WheelGraph     Method .  WheelGraph(n)  Create an undirected  wheel graph  with  n  vertices.  source", 
            "title": "Static Graphs"
        }, 
        {
            "location": "/generators/#small-graphs", 
            "text": "Other classical graphs can be generated by the following function:  #  LightGraphs.smallgraph     Method .  smallgraph(s)\nsmallgraph(s)  Create a small graph of type  s . Admissible values for  s  are:     s  graph type      :bull  A  bull graph .    :chvatal  A  Chv\u00e1tal graph .    :cubical  A  Platonic cubical graph .    :desargues  A  Desarguesgraph .    :diamond  A  diamond graph .    :dodecahedral  A  Platonic dodecahedral  graph .    :frucht  A  Frucht graph .    :heawood  A  Heawood graph .    :house  A graph mimicing the classic outline of a house.    :housex  A house graph, with two edges crossing the bottom square.    :icosahedral  A  Platonic icosahedral   graph .    :krackhardtkite  A  Krackhardt-Kite social network  graph .    :moebiuskantor  A  M\u00f6bius-Kantor graph .    :octahedral  A  Platonic octahedral graph .    :pappus  A  Pappus graph .    :petersen  A  Petersen graph .    :sedgewickmaze  A simple maze graph used in Sedgewick's  Algorithms in C++: Graph  Algorithms (3rd ed.)    :tetrahedral  A  Platonic tetrahedral  graph .    :truncatedcube  A skeleton of the  truncated cube graph .    :truncatedtetrahedron  A skeleton of the  truncated tetrahedron  graph .    :truncatedtetrahedron_dir  A skeleton of the  truncated tetrahedron digraph .    :tutte  A  Tutte graph .     source", 
            "title": "Small Graphs"
        }, 
        {
            "location": "/generators/#euclidean-graphs", 
            "text": "Generation of random and static graphs embedded in Euclidean space.  #  LightGraphs.euclidean_graph     Method .  euclidean_graph(points)  Given the  d\u00d7N  matrix  points  build an Euclidean graph of  N  vertices and return a graph and Dict containing the distance on each edge.  Optional Arguments   L=1 : used to bound the  d  dimensional box from which points are selected.  p=2  bc=:open   Implementation Notes  Defining the  d -dimensional vectors  x[i] = points[:,i] , an edge between vertices  i  and  j  is inserted if  norm(x[i]-x[j], p)   cutoff . In case of negative  cutoff  instead every edge is inserted. For  p=2  we have the standard Euclidean distance. Set  bc=:periodic  to impose periodic boundary conditions in the box $[0,L]^d$.  source  #  LightGraphs.euclidean_graph     Method .  euclidean_graph(N, d; seed=-1, L=1., p=2., cutoff=-1., bc=:open)  Generate  N  uniformly distributed points in the box $[0,L]^{d}$ and return a Euclidean graph, a map containing the distance on each edge and a matrix with the points' positions.  source", 
            "title": "Euclidean Graphs"
        }, 
        {
            "location": "/generators/#datasets", 
            "text": "Other notorious graphs and integration with the  MatrixDepot.jl  package are available in the  Datasets  submodule of the companion package  LightGraphsExtras.jl  ```", 
            "title": "Datasets"
        }, 
        {
            "location": "/persistence/", 
            "text": "Reading and writing Graphs\n\n\nGraphs may be written to I/O streams and files using the \nsavegraph\n function and read with the \nloadgraph\n function. The default graph format is a proprietary compressed \nLightGraphs.jl\n format \nlg\n. Other formats are available via the \nGraphPersistence\n package.\n\n\n#\n\n\nLightGraphs.loadgraph\n \n \nMethod\n.\n\n\nloadgraph(file, gname=\ngraph\n, format=LGFormat)\n\n\n\n\nRead a graph named \ngname\n from \nfile\n in the format \nformat\n.\n\n\nImplementation Notes\n\n\ngname\n is graph-format dependent and is only used if the file contains multiple graphs; if the file format does not support multiple graphs, this value is ignored. The default value may change in the future.\n\n\nsource\n\n\n#\n\n\nLightGraphs.loadgraphs\n \n \nMethod\n.\n\n\nloadgraphs(file, format=LGFormat)\n\n\n\n\nLoad multiple graphs from \nfile\n in the format \nformat\n. Return a dictionary mapping graph name to graph.\n\n\nImplementation Notes\n\n\nFor unnamed graphs the default name \"graph\" will be used. This default may change in the future.\n\n\nsource\n\n\n#\n\n\nLightGraphs.savegraph\n \n \nMethod\n.\n\n\nsavegraph(file, g, gname=\ngraph\n, format=LGFormat; compress=true)\n\n\n\n\nSaves a graph \ng\n with name \ngname\n to \nfile\n in the format \nformat\n. If \ncompress = true\n, use GZip compression when writing the file. Return the number of graphs written.\n\n\nImplementation Notes\n\n\nThe default graph name assigned to \ngname\n may change in the future.\n\n\nsource\n\n\n#\n\n\nLightGraphs.savegraph\n \n \nMethod\n.\n\n\nsavegraph(file, g, d, format=LGFormat; compress=true)\n\n\n\n\nSave a dictionary of \ngraphname =\n graph\n to \nfile\n in the format \nformat\n. If \ncompress = true\n, use GZip compression when writing the file. Return the number of graphs written.\n\n\nImplementation Notes\n\n\nWill only work if the file format supports multiple graph types.\n\n\nsource\n\n\n\n\nExamples\n\n\nsave(STDOUT, g)\nsave(\nmygraph.jgz\n, g, \nmygraph\n, compress=true)\n\nsavegraph(\nmygraph.jgz\n, g, compress=true)\n\ndg = load(\nmultiplegraphs.jgz\n) # dictionary of graphs", 
            "title": "Reading / Writing Graphs"
        }, 
        {
            "location": "/persistence/#reading-and-writing-graphs", 
            "text": "Graphs may be written to I/O streams and files using the  savegraph  function and read with the  loadgraph  function. The default graph format is a proprietary compressed  LightGraphs.jl  format  lg . Other formats are available via the  GraphPersistence  package.  #  LightGraphs.loadgraph     Method .  loadgraph(file, gname= graph , format=LGFormat)  Read a graph named  gname  from  file  in the format  format .  Implementation Notes  gname  is graph-format dependent and is only used if the file contains multiple graphs; if the file format does not support multiple graphs, this value is ignored. The default value may change in the future.  source  #  LightGraphs.loadgraphs     Method .  loadgraphs(file, format=LGFormat)  Load multiple graphs from  file  in the format  format . Return a dictionary mapping graph name to graph.  Implementation Notes  For unnamed graphs the default name \"graph\" will be used. This default may change in the future.  source  #  LightGraphs.savegraph     Method .  savegraph(file, g, gname= graph , format=LGFormat; compress=true)  Saves a graph  g  with name  gname  to  file  in the format  format . If  compress = true , use GZip compression when writing the file. Return the number of graphs written.  Implementation Notes  The default graph name assigned to  gname  may change in the future.  source  #  LightGraphs.savegraph     Method .  savegraph(file, g, d, format=LGFormat; compress=true)  Save a dictionary of  graphname =  graph  to  file  in the format  format . If  compress = true , use GZip compression when writing the file. Return the number of graphs written.  Implementation Notes  Will only work if the file format supports multiple graph types.  source", 
            "title": "Reading and writing Graphs"
        }, 
        {
            "location": "/persistence/#examples", 
            "text": "save(STDOUT, g)\nsave( mygraph.jgz , g,  mygraph , compress=true)\n\nsavegraph( mygraph.jgz , g, compress=true)\n\ndg = load( multiplegraphs.jgz ) # dictionary of graphs", 
            "title": "Examples"
        }, 
        {
            "location": "/integration/", 
            "text": "Integration with other packages\n\n\nLightGraphs.jl\n's integration with other Julia packages is designed to be straightforward. Here are a few examples.\n\n\n\n\nGraphs.jl\n\n\nCreating a Graphs.jl \nsimple_graph\n is easy:\n\n\njulia\n s = simple_graph(nv(g), is_directed=LightGraphs.is_directed(g))\njulia\n for e in LightGraphs.edges(g)\n           add_edge!(s,src(e), dst(e))\n       end\n\n\n\n\n\n\nGraphLayout.jl\n\n\nThis excellent graph visualization package can be used with \nLightGraphs.jl\n as follows:\n\n\njulia\n g = WheelGraph(10); am = full(adjacency_matrix(g))\njulia\n loc_x, loc_y = layout_spring_adj(am)\njulia\n draw_layout_adj(am, loc_x, loc_y, filename=\nwheel10.svg\n)\n\n\n\n\nproducing a graph like this:\n\n\n\n\n\n\nTikzGraphs.jl\n\n\nAnother nice graph visualization package. (\nTikzPictures.jl\n required to render/save):\n\n\njulia\n g = WheelGraph(10); t = plot(g)\n\njulia\n save(SVG(\nwheel10.svg\n), t)\n\n\n\n\nproducing a graph like this:\n\n\n\n\n\n\nGraphPlot.jl\n\n\nAnother graph visualization package that is very simple to use. \nCompose.jl\n is required for most rendering functionality:\n\n\njulia\n using GraphPlot, Compose\n\njulia\n g = WheelGraph(10)\n\njulia\n draw(PNG(\n/tmp/wheel10.png\n, 16cm, 16cm), gplot(g))\n\n\n\n\n\n\nMetis.jl\n\n\nThe Metis graph partitioning package can interface with \nLightGraphs.jl\n:\n\n\njulia\n using LightGraphs\n\njulia\n g = Graph(100,1000)\n{100, 1000} undirected graph\n\njulia\n partGraphKway(g, 6)  # 6 partitions\n\n\n\n\nNetworkViz.jl\n NetworkViz.jl is tightly coupled with \nLightGraphs.jl\n. Graphs can be visualized in 2D as well as 3D using \nThreeJS.jl\n and \nEscher.jl\n.\n\n\n#Run this code in Escher\n\nusing NetworkViz\nusing LightGraphs\n\nmain(window) = begin\n  push!(window.assets, \nwidgets\n)\n  push!(window.assets,(\nThreeJS\n,\nthreejs\n))\n  g = CompleteGraph(10)\n  drawGraph(g)\nend\n\n\n\n\nThe above code produces the following output:", 
            "title": "Integration with other packages"
        }, 
        {
            "location": "/integration/#integration-with-other-packages", 
            "text": "LightGraphs.jl 's integration with other Julia packages is designed to be straightforward. Here are a few examples.", 
            "title": "Integration with other packages"
        }, 
        {
            "location": "/integration/#graphsjl", 
            "text": "Creating a Graphs.jl  simple_graph  is easy:  julia  s = simple_graph(nv(g), is_directed=LightGraphs.is_directed(g))\njulia  for e in LightGraphs.edges(g)\n           add_edge!(s,src(e), dst(e))\n       end", 
            "title": "Graphs.jl"
        }, 
        {
            "location": "/integration/#graphlayoutjl", 
            "text": "This excellent graph visualization package can be used with  LightGraphs.jl  as follows:  julia  g = WheelGraph(10); am = full(adjacency_matrix(g))\njulia  loc_x, loc_y = layout_spring_adj(am)\njulia  draw_layout_adj(am, loc_x, loc_y, filename= wheel10.svg )  producing a graph like this:", 
            "title": "GraphLayout.jl"
        }, 
        {
            "location": "/integration/#tikzgraphsjl", 
            "text": "Another nice graph visualization package. ( TikzPictures.jl  required to render/save):  julia  g = WheelGraph(10); t = plot(g)\n\njulia  save(SVG( wheel10.svg ), t)  producing a graph like this:", 
            "title": "TikzGraphs.jl"
        }, 
        {
            "location": "/integration/#graphplotjl", 
            "text": "Another graph visualization package that is very simple to use.  Compose.jl  is required for most rendering functionality:  julia  using GraphPlot, Compose\n\njulia  g = WheelGraph(10)\n\njulia  draw(PNG( /tmp/wheel10.png , 16cm, 16cm), gplot(g))", 
            "title": "GraphPlot.jl"
        }, 
        {
            "location": "/integration/#metisjl", 
            "text": "The Metis graph partitioning package can interface with  LightGraphs.jl :  julia  using LightGraphs\n\njulia  g = Graph(100,1000)\n{100, 1000} undirected graph\n\njulia  partGraphKway(g, 6)  # 6 partitions", 
            "title": "Metis.jl"
        }, 
        {
            "location": "/integration/#networkvizjl-networkvizjl-is-tightly-coupled-with-lightgraphsjl-graphs-can-be-visualized-in-2d-as-well-as-3d-using-threejsjl-and-escherjl", 
            "text": "#Run this code in Escher\n\nusing NetworkViz\nusing LightGraphs\n\nmain(window) = begin\n  push!(window.assets,  widgets )\n  push!(window.assets,( ThreeJS , threejs ))\n  g = CompleteGraph(10)\n  drawGraph(g)\nend  The above code produces the following output:", 
            "title": "NetworkViz.jl NetworkViz.jl is tightly coupled with LightGraphs.jl. Graphs can be visualized in 2D as well as 3D using ThreeJS.jl and Escher.jl."
        }, 
        {
            "location": "/contributing/", 
            "text": "We welcome all possible contributors and ask that you read these guidelines before starting to work on this project. Following these guidelines will reduce friction and improve the speed at which your code gets merged.\n\n\n\n\nBug reports\n\n\nIf you notice code that is incorrect/crashes/too slow please file a bug report. The report should be raised as a github issue with a minimal working example that reproduces the error message. The example should include any data needed. If the problem is incorrectness, then please post the correct result along with an incorrect result.\n\n\nPlease include version numbers of all relevant libraries and Julia itself.\n\n\n\n\nDevelopment guidelines\n\n\n\n\nPRs should contain one logical enhancement to the codebase.\n\n\nSquash commits in a PR.\n\n\nOpen an issue to discuss a feature before you start coding (this maximizes the likelihood of patch acceptance).\n\n\n\n\nMinimize dependencies on external packages, and avoid introducing new dependencies. In general,\n\n\n\n\nPRs introducing dependencies on core Julia packages are ok.\n\n\nPRs introducing dependencies on non-core \"leaf\" packages (no subdependencies except for core Julia packages) are less ok.\n\n\nPRs introducing dependencies on non-core non-leaf packages require strict scrutiny and will likely not be accepted without some compelling reason (urgent bugfix or much-needed functionality).\n\n\nPut type assertions on all function arguments (use abstract types, Union, or Any if necessary).\n\n\nIf the algorithm was presented in a paper, include a reference to the paper (i.e. a proper academic citation along with an eprint link).\n\n\nTake steps to ensure that code works on graphs with multiple connected components efficiently.\n\n\nCorrectness is a necessary requirement; efficiency is desirable. Once you have a correct implementation, make a PR so we can help improve performance.\n\n\nWe can accept code that does not work for directed graphs as long as it comes with an explanation of what it would take to make it work for directed graphs.\n\n\nStyle point: prefer the short circuiting conditional over if/else when convenient, and where state is not explicitly being mutated (\ne.g.\n, \ncondition \n error(\"message\")\n is good; \ncondition \n i += 1\n is not).\n\n\nWhen possible write code to reuse memory. For example:\n\n\n\n\n\n\n\n\nfunction f(g, v)\n    storage = Vector{Int}(nv(g))\n    # some code operating on storage, g, and v.\n    for i in 1:nv(g)\n        storage[i] = v-i\n    end\n    return sum(storage)\nend\n\n\n\n\nshould be rewritten as two functions\n\n\nfunction f(g::AbstractGraph, v::Integer)\n    storage = Vector{Int}(nv(g))\n    return inner!(storage, g, v)\nend\n\nfunction inner!(storage::AbstractVector{Int}, g::AbstractGraph, v::Integer)\n    # some code operating on storage, g, and v.\n    for i in 1:nv(g)\n        storage[i] = v-i\n    end\n    return sum(storage)\nend\n\n\n\n\nThis allows us to reuse the memory and improve performance.", 
            "title": "Contributing"
        }, 
        {
            "location": "/contributing/#bug-reports", 
            "text": "If you notice code that is incorrect/crashes/too slow please file a bug report. The report should be raised as a github issue with a minimal working example that reproduces the error message. The example should include any data needed. If the problem is incorrectness, then please post the correct result along with an incorrect result.  Please include version numbers of all relevant libraries and Julia itself.", 
            "title": "Bug reports"
        }, 
        {
            "location": "/contributing/#development-guidelines", 
            "text": "PRs should contain one logical enhancement to the codebase.  Squash commits in a PR.  Open an issue to discuss a feature before you start coding (this maximizes the likelihood of patch acceptance).   Minimize dependencies on external packages, and avoid introducing new dependencies. In general,   PRs introducing dependencies on core Julia packages are ok.  PRs introducing dependencies on non-core \"leaf\" packages (no subdependencies except for core Julia packages) are less ok.  PRs introducing dependencies on non-core non-leaf packages require strict scrutiny and will likely not be accepted without some compelling reason (urgent bugfix or much-needed functionality).  Put type assertions on all function arguments (use abstract types, Union, or Any if necessary).  If the algorithm was presented in a paper, include a reference to the paper (i.e. a proper academic citation along with an eprint link).  Take steps to ensure that code works on graphs with multiple connected components efficiently.  Correctness is a necessary requirement; efficiency is desirable. Once you have a correct implementation, make a PR so we can help improve performance.  We can accept code that does not work for directed graphs as long as it comes with an explanation of what it would take to make it work for directed graphs.  Style point: prefer the short circuiting conditional over if/else when convenient, and where state is not explicitly being mutated ( e.g. ,  condition   error(\"message\")  is good;  condition   i += 1  is not).  When possible write code to reuse memory. For example:     function f(g, v)\n    storage = Vector{Int}(nv(g))\n    # some code operating on storage, g, and v.\n    for i in 1:nv(g)\n        storage[i] = v-i\n    end\n    return sum(storage)\nend  should be rewritten as two functions  function f(g::AbstractGraph, v::Integer)\n    storage = Vector{Int}(nv(g))\n    return inner!(storage, g, v)\nend\n\nfunction inner!(storage::AbstractVector{Int}, g::AbstractGraph, v::Integer)\n    # some code operating on storage, g, and v.\n    for i in 1:nv(g)\n        storage[i] = v-i\n    end\n    return sum(storage)\nend  This allows us to reuse the memory and improve performance.", 
            "title": "Development guidelines"
        }, 
        {
            "location": "/license/", 
            "text": "The LightGraphs.jl package is licensed under the Simplified \"2-clause\" BSD License:\n\n\n\n\nCopyright (c) 2015: Seth Bromberger and other contributors.\n\n\nRedistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n\n\n\n\nRedistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\n\n\nRedistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\n\n\n\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\n\n\n\nLightGraphs uses code derived from and/or inspired by the following packages:\n\n\nNetworkX:\n\n\n\n\nCopyright (C) 2004-2012, NetworkX Developers Aric Hagberg \n Dan Schult \n Pieter Swart \n All rights reserved.\n\n\nRedistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n\n\n\n\nRedistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\n\n\nRedistributions in binary form must reproduce the above with the distribution.\n\n\nNeither the name of the NetworkX Developers nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.\n\n\n\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\n\n\n\nGraphs.jl:\n\n\n\n\nCopyright (c) 2012: John Myles White and other contributors.\n\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n\n\nThe above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.", 
            "title": "License Information"
        }
    ]
}