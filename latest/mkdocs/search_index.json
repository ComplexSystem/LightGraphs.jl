{
    "docs": [
        {
            "location": "/", 
            "text": "LightGraphs\n\n\n \n \n \n\n\n \n \n \n\n\nAn optimized graphs package.\n\n\nSimple graphs (not multi- or hypergraphs) are represented in a memory- and time-efficient manner with adjacency lists and edge iterators. Both directed and undirected graphs are supported via separate types, and conversion is available from directed to undirected.\n\n\nThe project goal is to mirror the functionality of robust network and graph analysis libraries such as \nNetworkX\n while being simpler to use and more efficient than existing Julian graph libraries such as \nGraphs.jl\n. It is an explicit design decision that any data not required for graph manipulation (attributes and other information, for example) is expected to be stored outside of the graph structure itself. Such data lends itself to storage in more traditional and better-optimized mechanisms.\n\n\nAdditional functionality may be found in the companion package \nLightGraphsExtras.jl\n.\n\n\n\n\nDocumentation\n\n\nFull documentation is available at \nGitHub Pages\n. Documentation for methods is also available via the Julia REPL help system. Additional tutorials can be found at \nJuliaGraphsTutorials\n.\n\n\n\n\nCore Concepts\n\n\nA graph \nG\n is described by a set of vertices \nV\n and edges \nE\n: \nG = {V, E}\n. \nV\n is an integer range \n1:n\n; \nE\n is represented as forward (and, for directed graphs, backward) adjacency lists indexed by vertices. Edges may also be accessed via an iterator that yields \nEdge\n types containing \n(src\n:Integer, dst\n:Integer)\n values. Both vertices and edges may be integers of any type, and the smallest type that fits the data is recommended in order to save memory.\n\n\nLightGraphs.jl\n provides two graph types: \nGraph\n is an undirected graph, and \nDiGraph\n is its directed counterpart.\n\n\nGraphs are created using \nGraph()\n or \nDiGraph()\n; there are several options (see the tutorials for examples).\n\n\nMultiple edges between two given vertices are not allowed: an attempt to add an edge that already exists in a graph will result in a silent failure.\n\n\n\n\nInstallation\n\n\nInstallation is straightforward:\n\n\njulia\n Pkg.add(\nLightGraphs\n)\n\n\n\n\n\n\nCurrent functionality\n\n\n\n\ncore functions:\n vertices and edges addition and removal, degree (in/out/histogram), neighbors (in/out/all/common)\n\n\ndistance within graphs:\n eccentricity, diameter, periphery, radius, center\n\n\ndistance between graphs:\n spectral_distance, edit_distance\n\n\nconnectivity:\n strongly- and weakly-connected components, bipartite checks, condensation, attracting components, neighborhood\n\n\noperators:\n complement, reverse, reverse!, union, join, intersect, difference,\n\n\n\n\nsymmetric difference, blkdiag, induced subgraphs, products (cartesian/scalar)\n\n\n\n\nshortest paths:\n Dijkstra, Dijkstra with predecessors, Bellman-Ford, Floyd-Warshall, A*\n\n\nsmall graph generators:\n see \nsmallgraphs.jl\n for list\n\n\nrandom graph generators:\n Erd\u0151s\u2013R\u00e9nyi, Watts-Strogatz, random regular, arbitrary degree sequence, stochastic block model\n\n\ncentrality:\n betweenness, closeness, degree, pagerank, Katz\n\n\ntraversal operations:\n cycle detection, BFS and DFS DAGs, BFS and DFS traversals with visitors, DFS topological sort, maximum adjacency / minimum cut, multiple random walks\n\n\nflow operations:\n maximum flow\n\n\nmatching:\n Matching functions have been moved to \nLightGraphsExtras.jl\n.\n\n\nclique enumeration:\n maximal cliques\n\n\nlinear algebra / spectral graph theory:\n adjacency matrix (works as input to \nGraphLayout\n and \nMetis\n), Laplacian matrix, non-backtracking matrix\n\n\ncommunity:\n modularity, community detection, core-periphery, clustering coefficients\n\n\npersistence formats:\n LightGraphs natively supports a proprietary compressed format. For other formats, please see the \nGraphIO.jl\n package.\n\n\nvisualization:\n integration with\n\n\n\n\nGraphPlot\n, \nPlots\n via \nPlotRecipes\n, \nGraphLayout\n, \nTikzGraphs\n,  \nNetworkViz\n\n\n\n\nCore API\n\n\nThese functions are defined as the public contract of the \nLightGraphs.AbstractGraph\n interface.\n\n\n\n\nConstructing and modifying the graph\n\n\n\n\nGraph\n\n\nDiGraph\n\n\nadd_edge!\n\n\nrem_edge!\n\n\nadd_vertex!\n, \nadd_vertices!\n\n\nrem_vertex!\n\n\nzero\n\n\n\n\n\n\nEdge/Arc interface\n\n\n\n\nsrc\n\n\ndst\n\n\nreverse\n\n\n==\n\n\nPair / Tuple conversion\n\n\n\n\n\n\nAccessing state\n\n\n\n\nnv\n\n\nne\n\n\nvertices\n (Iterable)\n\n\nedges\n (Iterable)\n\n\nneighbors\n, \nin_neighbors\n, \nout_neighbors\n\n\nhas_vertex\n\n\nhas_edge\n\n\nhas_self_loops\n (though this might be a trait or an abstract graph type)\n\n\n\n\n\n\nNon-Core APIs\n\n\nThese functions can be constructed from the Core API functions but can be given specialized implementations in order to improve performance.\n\n\n\n\nadjacency_matrix\n\n\ndegree\n\n\n\n\nThis can be computed from neighbors by default \ndegree(g,v) = length(neighbors(g,v))\n so you don't need to implement this unless your type can compute degree faster than this method.\n\n\n\n\nSupported Versions\n\n\n\n\nLightGraphs master is designed to work with the latest stable version of Julia.\n\n\nJulia 0.3: LightGraphs v0.3.7 is the last version guaranteed to work with Julia 0.3.\n\n\nJulia 0.4: LightGraphs versions in the 0.6 series are designed to work with Julia 0.4.\n\n\nJulia 0.5: LightGraphs versions in the 0.7 series are designed to work with Julia 0.5.\n\n\nJulia 0.6: LightGraphs versions in the 0.8 and 0.9 series are designed to work with Julia 0.6.\n\n\nLater versions: Some functionality might not work with prerelease / unstable / nightly versions of Julia. If you run into a problem, please file an issue.\n\n\n\n\n\n\nContributing and Reporting Bugs\n\n\nWe welcome contributions and bug reports! Please see \nCONTRIBUTING.md\n for guidance on development and bug reporting.", 
            "title": "Getting Started"
        }, 
        {
            "location": "/#lightgraphs", 
            "text": "An optimized graphs package.  Simple graphs (not multi- or hypergraphs) are represented in a memory- and time-efficient manner with adjacency lists and edge iterators. Both directed and undirected graphs are supported via separate types, and conversion is available from directed to undirected.  The project goal is to mirror the functionality of robust network and graph analysis libraries such as  NetworkX  while being simpler to use and more efficient than existing Julian graph libraries such as  Graphs.jl . It is an explicit design decision that any data not required for graph manipulation (attributes and other information, for example) is expected to be stored outside of the graph structure itself. Such data lends itself to storage in more traditional and better-optimized mechanisms.  Additional functionality may be found in the companion package  LightGraphsExtras.jl .", 
            "title": "LightGraphs"
        }, 
        {
            "location": "/#documentation", 
            "text": "Full documentation is available at  GitHub Pages . Documentation for methods is also available via the Julia REPL help system. Additional tutorials can be found at  JuliaGraphsTutorials .", 
            "title": "Documentation"
        }, 
        {
            "location": "/#core-concepts", 
            "text": "A graph  G  is described by a set of vertices  V  and edges  E :  G = {V, E} .  V  is an integer range  1:n ;  E  is represented as forward (and, for directed graphs, backward) adjacency lists indexed by vertices. Edges may also be accessed via an iterator that yields  Edge  types containing  (src :Integer, dst :Integer)  values. Both vertices and edges may be integers of any type, and the smallest type that fits the data is recommended in order to save memory.  LightGraphs.jl  provides two graph types:  Graph  is an undirected graph, and  DiGraph  is its directed counterpart.  Graphs are created using  Graph()  or  DiGraph() ; there are several options (see the tutorials for examples).  Multiple edges between two given vertices are not allowed: an attempt to add an edge that already exists in a graph will result in a silent failure.", 
            "title": "Core Concepts"
        }, 
        {
            "location": "/#installation", 
            "text": "Installation is straightforward:  julia  Pkg.add( LightGraphs )", 
            "title": "Installation"
        }, 
        {
            "location": "/#current-functionality", 
            "text": "core functions:  vertices and edges addition and removal, degree (in/out/histogram), neighbors (in/out/all/common)  distance within graphs:  eccentricity, diameter, periphery, radius, center  distance between graphs:  spectral_distance, edit_distance  connectivity:  strongly- and weakly-connected components, bipartite checks, condensation, attracting components, neighborhood  operators:  complement, reverse, reverse!, union, join, intersect, difference,   symmetric difference, blkdiag, induced subgraphs, products (cartesian/scalar)   shortest paths:  Dijkstra, Dijkstra with predecessors, Bellman-Ford, Floyd-Warshall, A*  small graph generators:  see  smallgraphs.jl  for list  random graph generators:  Erd\u0151s\u2013R\u00e9nyi, Watts-Strogatz, random regular, arbitrary degree sequence, stochastic block model  centrality:  betweenness, closeness, degree, pagerank, Katz  traversal operations:  cycle detection, BFS and DFS DAGs, BFS and DFS traversals with visitors, DFS topological sort, maximum adjacency / minimum cut, multiple random walks  flow operations:  maximum flow  matching:  Matching functions have been moved to  LightGraphsExtras.jl .  clique enumeration:  maximal cliques  linear algebra / spectral graph theory:  adjacency matrix (works as input to  GraphLayout  and  Metis ), Laplacian matrix, non-backtracking matrix  community:  modularity, community detection, core-periphery, clustering coefficients  persistence formats:  LightGraphs natively supports a proprietary compressed format. For other formats, please see the  GraphIO.jl  package.  visualization:  integration with   GraphPlot ,  Plots  via  PlotRecipes ,  GraphLayout ,  TikzGraphs ,   NetworkViz", 
            "title": "Current functionality"
        }, 
        {
            "location": "/#core-api", 
            "text": "These functions are defined as the public contract of the  LightGraphs.AbstractGraph  interface.", 
            "title": "Core API"
        }, 
        {
            "location": "/#constructing-and-modifying-the-graph", 
            "text": "Graph  DiGraph  add_edge!  rem_edge!  add_vertex! ,  add_vertices!  rem_vertex!  zero", 
            "title": "Constructing and modifying the graph"
        }, 
        {
            "location": "/#edgearc-interface", 
            "text": "src  dst  reverse  ==  Pair / Tuple conversion", 
            "title": "Edge/Arc interface"
        }, 
        {
            "location": "/#accessing-state", 
            "text": "nv  ne  vertices  (Iterable)  edges  (Iterable)  neighbors ,  in_neighbors ,  out_neighbors  has_vertex  has_edge  has_self_loops  (though this might be a trait or an abstract graph type)", 
            "title": "Accessing state"
        }, 
        {
            "location": "/#non-core-apis", 
            "text": "These functions can be constructed from the Core API functions but can be given specialized implementations in order to improve performance.   adjacency_matrix  degree   This can be computed from neighbors by default  degree(g,v) = length(neighbors(g,v))  so you don't need to implement this unless your type can compute degree faster than this method.", 
            "title": "Non-Core APIs"
        }, 
        {
            "location": "/#supported-versions", 
            "text": "LightGraphs master is designed to work with the latest stable version of Julia.  Julia 0.3: LightGraphs v0.3.7 is the last version guaranteed to work with Julia 0.3.  Julia 0.4: LightGraphs versions in the 0.6 series are designed to work with Julia 0.4.  Julia 0.5: LightGraphs versions in the 0.7 series are designed to work with Julia 0.5.  Julia 0.6: LightGraphs versions in the 0.8 and 0.9 series are designed to work with Julia 0.6.  Later versions: Some functionality might not work with prerelease / unstable / nightly versions of Julia. If you run into a problem, please file an issue.", 
            "title": "Supported Versions"
        }, 
        {
            "location": "/#contributing-and-reporting-bugs", 
            "text": "We welcome contributions and bug reports! Please see  CONTRIBUTING.md  for guidance on development and bug reporting.", 
            "title": "Contributing and Reporting Bugs"
        }, 
        {
            "location": "/basicmeasures/", 
            "text": "Basic Functions\n\n\nLightGraphs.jl\n defines the following basic types and functionalities:", 
            "title": "Basic Functions"
        }, 
        {
            "location": "/basicmeasures/#basic-functions", 
            "text": "LightGraphs.jl  defines the following basic types and functionalities:", 
            "title": "Basic Functions"
        }, 
        {
            "location": "/operators/", 
            "text": "Operators\n\n\nLightGraphs.jl\n implements the following graph operators. In general, functions with two graph arguments will require them to be of the same type (either both \nGraph\n or both \nDiGraph\n).", 
            "title": "Operators"
        }, 
        {
            "location": "/operators/#operators", 
            "text": "LightGraphs.jl  implements the following graph operators. In general, functions with two graph arguments will require them to be of the same type (either both  Graph  or both  DiGraph ).", 
            "title": "Operators"
        }, 
        {
            "location": "/pathing/", 
            "text": "Path and Traversal\n\n\nLightGraphs.jl\n provides several traversal and shortest-path algorithms, along with various utility functions. Where appropriate, edge distances may be passed in as a matrix of real number values.\n\n\nEdge distances for most traversals may be passed in as a sparse or dense matrix of  values, indexed by \n[src,dst]\n vertices. That is, \ndistmx[2,4] = 2.5\n assigns the distance \n2.5\n to the (directed) edge connecting vertex 2 and vertex 4. Note that also for undirected graphs \ndistmx[4,2]\n has to be set.\n\n\nAny graph traversal  will traverse an edge only if it is present in the graph. When a distance matrix is passed in,\n\n\n\n\ndistance values for undefined edges will be ignored, and\n\n\nany unassigned values (in sparse distance matrices), for edges that are present in the graph, will be assumed to take the default value of 1.0.\n\n\nany zero values (in sparse/dense distance matrices), for edges that are present in the graph, will instead have an implicit edge cost of 1.0.\n\n\n\n\n\n\nGraph Traversal\n\n\nGraph traversal\n refers to a process that traverses vertices of a graph following certain order (starting from user-input sources). This package implements three traversal schemes:\n\n\n\n\nBreadthFirst\n,\n\n\nDepthFirst\n, and\n\n\nMaximumAdjacency\n.\n\n\n\n\n#\n\n\nLightGraphs.bfs_tree\n \n \nFunction\n.\n\n\nbfs_tree(g, s)\n\n\n\n\nProvide a breadth-first traversal of the graph \ng\n starting with source vertex \ns\n, and return a directed acyclic graph of vertices in the order they were discovered.\n\n\nImplementation Notes\n\n\nThis function is a high level wrapper around \nbfs_tree!\n; use that function for more performance.\n\n\nsource\n\n\nbfs_tree(LevelSynchronousBFS(), g, s, nv)\n\n\n\n\nProvide a parallel breadth-first traversal of the graph \ng\n starting with source vertex \ns\n, and return a directed acyclic graph of vertices in the order they were discovered using a frontier based parallel approach.\n\n\nImplementation Notes\n\n\nThis function uses \n@threads\n for parallelism which depends on the \nJULIA_NUM_THREADS\n environment variable to decide the number of threads to use. Refer \n@threads\n documentation for more details. This function is a high level wrapper around \nbfs_tree!\n; use that function for more performance.\n\n\nsource\n\n\n#\n\n\nLightGraphs.dfs_tree\n \n \nFunction\n.\n\n\ndfs_tree(g, s)\n\n\n\n\nReturn an ordered vector of vertices representing a directed acylic graph based on depth-first traversal of the graph \ng\n starting with source vertex \ns\n.\n\n\nsource\n\n\n#\n\n\nLightGraphs.maximum_adjacency_visit\n \n \nFunction\n.\n\n\nmaximum_adjacency_visit(g[, distmx][, log][, io])\n\n\n\n\nReturn the vertices in \ng\n traversed by maximum adjacency search. An optional \ndistmx\n matrix may be specified; if omitted, edge distances are assumed to be 1. If \nlog\n (default \nfalse\n) is \ntrue\n, visitor events will be printed to \nio\n, which defaults to \nSTDOUT\n; otherwise, no event information will be displayed.\n\n\nsource\n\n\n\n\nRandom walks\n\n\nLightGraphs\n includes uniform random walks and self avoiding walks:\n\n\n#\n\n\nLightGraphs.randomwalk\n \n \nFunction\n.\n\n\nrandomwalk(g, s, niter)\n\n\n\n\nPerform a random walk on graph \ng\n starting at vertex \ns\n and continuing for a maximum of \nniter\n steps. Return a vector of vertices visited in order.\n\n\nsource\n\n\n#\n\n\nLightGraphs.saw\n \n \nFunction\n.\n\n\nsaw(g, s, niter)\n\n\n\n\nPerform a \nself-avoiding walk\n on graph \ng\n starting at vertex \ns\n and continuing for a maximum of \nniter\n steps. Return a vector of vertices visited in order.\n\n\nsource\n\n\n\n\nConnectivity / Bipartiteness\n\n\nGraph connectivity\n functions are defined on both undirected and directed graphs:\n\n\nis_connected\nis_strongly_connected\nis_weakly_connected\nconnected_components\nstrongly_connected_components\nweakly_connected_components\nhas_self_loop\nattracting_components\nis_bipartite\ncondensation\nperiod\n\n\n\n\n\n\nCycle Detection\n\n\nIn graph theory, a cycle is defined to be a path that starts from some vertex \nv\n and ends up at \nv\n.\n\n\n#\n\n\nLightGraphs.is_cyclic\n \n \nFunction\n.\n\n\nis_cyclic(g)\n\n\n\n\nReturn \ntrue\n if graph \ng\n contains a cycle.\n\n\nImplementation Notes\n\n\nUses DFS.\n\n\nsource\n\n\n\n\nShortest-Path Algorithms\n\n\n\n\nGeneral properties of shortest path algorithms\n\n\n\n\nThe distance from a vertex to itself is always \n0\n.\n\n\nThe distance between two vertices with no connecting edge is always \nInf\n.\n\n\n\n\n#\n\n\nLightGraphs.a_star\n \n \nFunction\n.\n\n\na_star(g, s, t[, distmx][, heuristic])\n\n\n\n\nReturn a vector of edges comprising the shortest path between vertices \ns\n and \nt\n using the \nA* search algorithm\n. An optional heuristic function and edge distance matrix may be supplied. If missing, the distance matrix is set to \nDefaultDistance\n and the heuristic is set to \nn -\n 0\n.\n\n\nsource\n\n\n#\n\n\nLightGraphs.dijkstra_shortest_paths\n \n \nFunction\n.\n\n\ndijkstra_shortest_paths(g, srcs, distmx=DefaultDistance());\n\n\n\n\nPerform \nDijkstra's algorithm\n on a graph, computing shortest distances between \nsrcs\n and all other vertices. Return a \nDijkstraState\n that contains various traversal information.\n\n\nOptional Arguments\n\n\n\n\nallpaths=false\n: If true, returns a \nDijkstraState\n that keeps track of all\n\n\n\n\npredecessors of a given vertex.\n\n\nsource\n\n\n#\n\n\nLightGraphs.bellman_ford_shortest_paths\n \n \nFunction\n.\n\n\nbellman_ford_shortest_paths(g, s, distmx=DefaultDistance())\nbellman_ford_shortest_paths(g, ss, distmx=DefaultDistance())\n\n\n\n\nCompute shortest paths between a source \ns\n (or list of sources \nss\n) and all other nodes in graph \ng\n using the \nBellman-Ford algorithm\n. Return a \nBellmanFordState\n with relevant traversal information.\n\n\nsource\n\n\n#\n\n\nLightGraphs.floyd_warshall_shortest_paths\n \n \nFunction\n.\n\n\nfloyd_warshall_shortest_paths(g, distmx=DefaultDistance()) Use the \nFloyd-Warshall algorithm\n to compute the shortest paths between all pairs of vertices in graph \ng\n using an optional distance matrix \ndistmx\n. Return a \nFloydWarshallState\n with relevant traversal information.\n\n\nPerformance\n\n\nSpace complexity is on the order of $\\mathcal{O}(|V|^2)$.\n\n\nsource\n\n\n\n\nPath discovery / enumeration\n\n\n#\n\n\nLightGraphs.gdistances\n \n \nFunction\n.\n\n\ngdistances(g, source)\n\n\n\n\nReturn a vector filled with the geodesic distances of vertices in  \ng\n from \nsource\n. If \nsource\n is a collection of vertices each element should be unique. For vertices in disconnected components the default distance is -1.\n\n\nsource\n\n\n#\n\n\nLightGraphs.gdistances!\n \n \nFunction\n.\n\n\ngdistances!(g, source, dists)\n\n\n\n\nFill \ndists\n with the geodesic distances of vertices in \ng\n from \nsource\n. \ndists\n should be a vector of length \nnv(g)\n. Return \ndists\n. For vertices in disconnected components the default distance is -1.\n\n\nsource\n\n\n#\n\n\nLightGraphs.enumerate_paths\n \n \nFunction\n.\n\n\nenumerate_paths(state[, vs])\n\n\n\n\nGiven a path state \nstate\n of type \nAbstractPathState\n, return a vector (indexed by vertex) of the paths between the source vertex used to compute the path state and a single destination vertex, a list of destination vertices, or the entire graph. For multiple destination vertices, each path is represented by a vector of vertices on the path between the source and the destination. Nonexistent paths will be indicated by an empty vector. For single destinations, the path is represented by a single vector of vertices, and will be length 0 if the path does not exist.\n\n\nImplementation Notes\n\n\nFor Floyd-Warshall path states, please note that the output is a bit different, since this algorithm calculates all shortest paths for all pairs of vertices: \nenumerate_paths(state)\n will return a vector (indexed by source vertex) of vectors (indexed by destination vertex) of paths. \nenumerate_paths(state, v)\n will return a vector (indexed by destination vertex) of paths from source \nv\n to all other vertices. In addition, \nenumerate_paths(state, v, d)\n will return a vector representing the path from vertex \nv\n to vertex \nd\n.\n\n\nsource\n\n\nFor Floyd-Warshall path states, please note that the output is a bit different, since this algorithm calculates all shortest paths for all pairs of vertices: \nenumerate_paths(state)\n will return a vector (indexed by source vertex) of vectors (indexed by destination vertex) of paths. \nenumerate_paths(state, v)\n will return a vector (indexed by destination vertex) of paths from source \nv\n to all other vertices. In addition, \nenumerate_paths(state, v, d)\n will return a vector representing the path from vertex \nv\n to vertex \nd\n.\n\n\n\n\nPath States\n\n\nThe \nfloyd_warshall_shortest_paths\n, \nbellman_ford_shortest_paths\n, \ndijkstra_shortest_paths\n, and \ndijkstra_predecessor_and_distance\n functions return a state that contains various information about the graph learned during traversal. The three state types have the following common information, accessible via the type:\n\n\n.dists\n Holds a vector of distances computed, indexed by source vertex.\n\n\n.parents\n Holds a vector of parents of each source vertex. The parent of a source vertex is always \n0\n.\n\n\nIn addition, the \ndijkstra_predecessor_and_distance\n function stores the following information:\n\n\n.predecessors\n Holds a vector, indexed by vertex, of all the predecessors discovered during shortest-path calculations. This keeps track of all parents when there are multiple shortest paths available from the source.\n\n\n.pathcounts\n Holds a vector, indexed by vertex, of the path counts discovered during traversal. This equals the length of each subvector in the \n.predecessors\n output above.", 
            "title": "Path and Traversal"
        }, 
        {
            "location": "/pathing/#path-and-traversal", 
            "text": "LightGraphs.jl  provides several traversal and shortest-path algorithms, along with various utility functions. Where appropriate, edge distances may be passed in as a matrix of real number values.  Edge distances for most traversals may be passed in as a sparse or dense matrix of  values, indexed by  [src,dst]  vertices. That is,  distmx[2,4] = 2.5  assigns the distance  2.5  to the (directed) edge connecting vertex 2 and vertex 4. Note that also for undirected graphs  distmx[4,2]  has to be set.  Any graph traversal  will traverse an edge only if it is present in the graph. When a distance matrix is passed in,   distance values for undefined edges will be ignored, and  any unassigned values (in sparse distance matrices), for edges that are present in the graph, will be assumed to take the default value of 1.0.  any zero values (in sparse/dense distance matrices), for edges that are present in the graph, will instead have an implicit edge cost of 1.0.", 
            "title": "Path and Traversal"
        }, 
        {
            "location": "/pathing/#graph-traversal", 
            "text": "Graph traversal  refers to a process that traverses vertices of a graph following certain order (starting from user-input sources). This package implements three traversal schemes:   BreadthFirst ,  DepthFirst , and  MaximumAdjacency .   #  LightGraphs.bfs_tree     Function .  bfs_tree(g, s)  Provide a breadth-first traversal of the graph  g  starting with source vertex  s , and return a directed acyclic graph of vertices in the order they were discovered.  Implementation Notes  This function is a high level wrapper around  bfs_tree! ; use that function for more performance.  source  bfs_tree(LevelSynchronousBFS(), g, s, nv)  Provide a parallel breadth-first traversal of the graph  g  starting with source vertex  s , and return a directed acyclic graph of vertices in the order they were discovered using a frontier based parallel approach.  Implementation Notes  This function uses  @threads  for parallelism which depends on the  JULIA_NUM_THREADS  environment variable to decide the number of threads to use. Refer  @threads  documentation for more details. This function is a high level wrapper around  bfs_tree! ; use that function for more performance.  source  #  LightGraphs.dfs_tree     Function .  dfs_tree(g, s)  Return an ordered vector of vertices representing a directed acylic graph based on depth-first traversal of the graph  g  starting with source vertex  s .  source  #  LightGraphs.maximum_adjacency_visit     Function .  maximum_adjacency_visit(g[, distmx][, log][, io])  Return the vertices in  g  traversed by maximum adjacency search. An optional  distmx  matrix may be specified; if omitted, edge distances are assumed to be 1. If  log  (default  false ) is  true , visitor events will be printed to  io , which defaults to  STDOUT ; otherwise, no event information will be displayed.  source", 
            "title": "Graph Traversal"
        }, 
        {
            "location": "/pathing/#random-walks", 
            "text": "LightGraphs  includes uniform random walks and self avoiding walks:  #  LightGraphs.randomwalk     Function .  randomwalk(g, s, niter)  Perform a random walk on graph  g  starting at vertex  s  and continuing for a maximum of  niter  steps. Return a vector of vertices visited in order.  source  #  LightGraphs.saw     Function .  saw(g, s, niter)  Perform a  self-avoiding walk  on graph  g  starting at vertex  s  and continuing for a maximum of  niter  steps. Return a vector of vertices visited in order.  source", 
            "title": "Random walks"
        }, 
        {
            "location": "/pathing/#connectivity-bipartiteness", 
            "text": "Graph connectivity  functions are defined on both undirected and directed graphs:  is_connected\nis_strongly_connected\nis_weakly_connected\nconnected_components\nstrongly_connected_components\nweakly_connected_components\nhas_self_loop\nattracting_components\nis_bipartite\ncondensation\nperiod", 
            "title": "Connectivity / Bipartiteness"
        }, 
        {
            "location": "/pathing/#cycle-detection", 
            "text": "In graph theory, a cycle is defined to be a path that starts from some vertex  v  and ends up at  v .  #  LightGraphs.is_cyclic     Function .  is_cyclic(g)  Return  true  if graph  g  contains a cycle.  Implementation Notes  Uses DFS.  source", 
            "title": "Cycle Detection"
        }, 
        {
            "location": "/pathing/#shortest-path-algorithms", 
            "text": "", 
            "title": "Shortest-Path Algorithms"
        }, 
        {
            "location": "/pathing/#general-properties-of-shortest-path-algorithms", 
            "text": "The distance from a vertex to itself is always  0 .  The distance between two vertices with no connecting edge is always  Inf .   #  LightGraphs.a_star     Function .  a_star(g, s, t[, distmx][, heuristic])  Return a vector of edges comprising the shortest path between vertices  s  and  t  using the  A* search algorithm . An optional heuristic function and edge distance matrix may be supplied. If missing, the distance matrix is set to  DefaultDistance  and the heuristic is set to  n -  0 .  source  #  LightGraphs.dijkstra_shortest_paths     Function .  dijkstra_shortest_paths(g, srcs, distmx=DefaultDistance());  Perform  Dijkstra's algorithm  on a graph, computing shortest distances between  srcs  and all other vertices. Return a  DijkstraState  that contains various traversal information.  Optional Arguments   allpaths=false : If true, returns a  DijkstraState  that keeps track of all   predecessors of a given vertex.  source  #  LightGraphs.bellman_ford_shortest_paths     Function .  bellman_ford_shortest_paths(g, s, distmx=DefaultDistance())\nbellman_ford_shortest_paths(g, ss, distmx=DefaultDistance())  Compute shortest paths between a source  s  (or list of sources  ss ) and all other nodes in graph  g  using the  Bellman-Ford algorithm . Return a  BellmanFordState  with relevant traversal information.  source  #  LightGraphs.floyd_warshall_shortest_paths     Function .  floyd_warshall_shortest_paths(g, distmx=DefaultDistance()) Use the  Floyd-Warshall algorithm  to compute the shortest paths between all pairs of vertices in graph  g  using an optional distance matrix  distmx . Return a  FloydWarshallState  with relevant traversal information.  Performance  Space complexity is on the order of $\\mathcal{O}(|V|^2)$.  source", 
            "title": "General properties of shortest path algorithms"
        }, 
        {
            "location": "/pathing/#path-discovery-enumeration", 
            "text": "#  LightGraphs.gdistances     Function .  gdistances(g, source)  Return a vector filled with the geodesic distances of vertices in   g  from  source . If  source  is a collection of vertices each element should be unique. For vertices in disconnected components the default distance is -1.  source  #  LightGraphs.gdistances!     Function .  gdistances!(g, source, dists)  Fill  dists  with the geodesic distances of vertices in  g  from  source .  dists  should be a vector of length  nv(g) . Return  dists . For vertices in disconnected components the default distance is -1.  source  #  LightGraphs.enumerate_paths     Function .  enumerate_paths(state[, vs])  Given a path state  state  of type  AbstractPathState , return a vector (indexed by vertex) of the paths between the source vertex used to compute the path state and a single destination vertex, a list of destination vertices, or the entire graph. For multiple destination vertices, each path is represented by a vector of vertices on the path between the source and the destination. Nonexistent paths will be indicated by an empty vector. For single destinations, the path is represented by a single vector of vertices, and will be length 0 if the path does not exist.  Implementation Notes  For Floyd-Warshall path states, please note that the output is a bit different, since this algorithm calculates all shortest paths for all pairs of vertices:  enumerate_paths(state)  will return a vector (indexed by source vertex) of vectors (indexed by destination vertex) of paths.  enumerate_paths(state, v)  will return a vector (indexed by destination vertex) of paths from source  v  to all other vertices. In addition,  enumerate_paths(state, v, d)  will return a vector representing the path from vertex  v  to vertex  d .  source  For Floyd-Warshall path states, please note that the output is a bit different, since this algorithm calculates all shortest paths for all pairs of vertices:  enumerate_paths(state)  will return a vector (indexed by source vertex) of vectors (indexed by destination vertex) of paths.  enumerate_paths(state, v)  will return a vector (indexed by destination vertex) of paths from source  v  to all other vertices. In addition,  enumerate_paths(state, v, d)  will return a vector representing the path from vertex  v  to vertex  d .", 
            "title": "Path discovery / enumeration"
        }, 
        {
            "location": "/pathing/#path-states", 
            "text": "The  floyd_warshall_shortest_paths ,  bellman_ford_shortest_paths ,  dijkstra_shortest_paths , and  dijkstra_predecessor_and_distance  functions return a state that contains various information about the graph learned during traversal. The three state types have the following common information, accessible via the type:  .dists  Holds a vector of distances computed, indexed by source vertex.  .parents  Holds a vector of parents of each source vertex. The parent of a source vertex is always  0 .  In addition, the  dijkstra_predecessor_and_distance  function stores the following information:  .predecessors  Holds a vector, indexed by vertex, of all the predecessors discovered during shortest-path calculations. This keeps track of all parents when there are multiple shortest paths available from the source.  .pathcounts  Holds a vector, indexed by vertex, of the path counts discovered during traversal. This equals the length of each subvector in the  .predecessors  output above.", 
            "title": "Path States"
        }, 
        {
            "location": "/distance/", 
            "text": "Distance\n\n\nLightGraphs.jl\n includes the following distance measurements:", 
            "title": "Distance"
        }, 
        {
            "location": "/distance/#distance", 
            "text": "LightGraphs.jl  includes the following distance measurements:", 
            "title": "Distance"
        }, 
        {
            "location": "/centrality/", 
            "text": "Centrality Measures\n\n\nCentrality measures\n describe the importance of a vertex to the rest of the graph using some set of criteria. Centrality measures implemented in \nLightGraphs.jl\n include the following:", 
            "title": "Centrality Measures"
        }, 
        {
            "location": "/centrality/#centrality-measures", 
            "text": "Centrality measures  describe the importance of a vertex to the rest of the graph using some set of criteria. Centrality measures implemented in  LightGraphs.jl  include the following:", 
            "title": "Centrality Measures"
        }, 
        {
            "location": "/linalg/", 
            "text": "Linear Algebra\n\n\nLightGraphs.jl\n provides the following matrix operations on both directed and undirected graphs:", 
            "title": "Linear Algebra"
        }, 
        {
            "location": "/linalg/#linear-algebra", 
            "text": "LightGraphs.jl  provides the following matrix operations on both directed and undirected graphs:", 
            "title": "Linear Algebra"
        }, 
        {
            "location": "/matching/", 
            "text": "Matching\n\n\nMaximum weight matching  is supperted in the companion package \nLightGraphsExtras.jl", 
            "title": "Matching"
        }, 
        {
            "location": "/matching/#matching", 
            "text": "Maximum weight matching  is supperted in the companion package  LightGraphsExtras.jl", 
            "title": "Matching"
        }, 
        {
            "location": "/community/", 
            "text": "Community Structures\n\n\nLightGraphs.jl\n contains many algorithm to detect and analyze community structures in graphs.", 
            "title": "Community Structures"
        }, 
        {
            "location": "/community/#community-structures", 
            "text": "LightGraphs.jl  contains many algorithm to detect and analyze community structures in graphs.", 
            "title": "Community Structures"
        }, 
        {
            "location": "/flowcut/", 
            "text": "Flow and Cut\n\n\nLightGraphs.jl\n provides different algorithms for \nmaximum flow\n and minimum cut computations.", 
            "title": "Flow and Cut"
        }, 
        {
            "location": "/flowcut/#flow-and-cut", 
            "text": "LightGraphs.jl  provides different algorithms for  maximum flow  and minimum cut computations.", 
            "title": "Flow and Cut"
        }, 
        {
            "location": "/generators/", 
            "text": "Generators\n\n\n\n\nRandom Graphs\n\n\nLightGraphs.jl\n implements some common random graph generators:\n\n\n\n\nStatic Graphs\n\n\nLightGraphs.jl\n also implements a collection of classic graph generators:\n\n\n\n\nSmall Graphs\n\n\nOther classical graphs can be generated by the following function:\n\n\n\n\nEuclidean Graphs\n\n\nGeneration of random and static graphs embedded in Euclidean space.\n\n\n\n\nDatasets\n\n\nOther notorious graphs and integration with the \nMatrixDepot.jl\n package are available in the \nDatasets\n submodule of the companion package \nLightGraphsExtras.jl\n ```", 
            "title": "Graph Generators"
        }, 
        {
            "location": "/generators/#generators", 
            "text": "", 
            "title": "Generators"
        }, 
        {
            "location": "/generators/#random-graphs", 
            "text": "LightGraphs.jl  implements some common random graph generators:", 
            "title": "Random Graphs"
        }, 
        {
            "location": "/generators/#static-graphs", 
            "text": "LightGraphs.jl  also implements a collection of classic graph generators:", 
            "title": "Static Graphs"
        }, 
        {
            "location": "/generators/#small-graphs", 
            "text": "Other classical graphs can be generated by the following function:", 
            "title": "Small Graphs"
        }, 
        {
            "location": "/generators/#euclidean-graphs", 
            "text": "Generation of random and static graphs embedded in Euclidean space.", 
            "title": "Euclidean Graphs"
        }, 
        {
            "location": "/generators/#datasets", 
            "text": "Other notorious graphs and integration with the  MatrixDepot.jl  package are available in the  Datasets  submodule of the companion package  LightGraphsExtras.jl  ```", 
            "title": "Datasets"
        }, 
        {
            "location": "/persistence/", 
            "text": "Reading and writing Graphs\n\n\nGraphs may be written to I/O streams and files using the \nsave\n function and read with the \nload\n function. Currently supported graph formats are the  \nLightGraphs.jl\n format \nlg\n and the common formats \ngml, graphml, gexf, dot, net\n.\n\n\n\n\nExamples\n\n\nsave(STDOUT, g)\nsave(\nmygraph.jgz\n, g, \nmygraph\n, compress=true)\n\nsavegraph(\nmygraph.jgz\n, g, compress=true)\n\ndg = load(\nmultiplegraphs.jgz\n) # dictionary of graphs\ndg = load(\nmultiplegraphs.graphml\n, :graphml)\ndg = load(\nmygraph.gml\n, \nmygraph\n, :gml)\n\ng = laoadgraph(\nmygraph.gml\n,  :gml)", 
            "title": "Reading / Writing Graphs"
        }, 
        {
            "location": "/persistence/#reading-and-writing-graphs", 
            "text": "Graphs may be written to I/O streams and files using the  save  function and read with the  load  function. Currently supported graph formats are the   LightGraphs.jl  format  lg  and the common formats  gml, graphml, gexf, dot, net .", 
            "title": "Reading and writing Graphs"
        }, 
        {
            "location": "/persistence/#examples", 
            "text": "save(STDOUT, g)\nsave( mygraph.jgz , g,  mygraph , compress=true)\n\nsavegraph( mygraph.jgz , g, compress=true)\n\ndg = load( multiplegraphs.jgz ) # dictionary of graphs\ndg = load( multiplegraphs.graphml , :graphml)\ndg = load( mygraph.gml ,  mygraph , :gml)\n\ng = laoadgraph( mygraph.gml ,  :gml)", 
            "title": "Examples"
        }, 
        {
            "location": "/integration/", 
            "text": "Integration with other packages\n\n\nLightGraphs.jl\n's integration with other Julia packages is designed to be straightforward. Here are a few examples.\n\n\n\n\nGraphs.jl\n\n\nCreating a Graphs.jl \nsimple_graph\n is easy:\n\n\njulia\n s = simple_graph(nv(g), is_directed=LightGraphs.is_directed(g))\njulia\n for e in LightGraphs.edges(g)\n           add_edge!(s,src(e), dst(e))\n       end\n\n\n\n\n\n\nGraphLayout.jl\n\n\nThis excellent graph visualization package can be used with \nLightGraphs.jl\n as follows:\n\n\njulia\n g = WheelGraph(10); am = full(adjacency_matrix(g))\njulia\n loc_x, loc_y = layout_spring_adj(am)\njulia\n draw_layout_adj(am, loc_x, loc_y, filename=\nwheel10.svg\n)\n\n\n\n\nproducing a graph like this:\n\n\n\n\n\n\nTikzGraphs.jl\n\n\nAnother nice graph visualization package. (\nTikzPictures.jl\n required to render/save):\n\n\njulia\n g = WheelGraph(10); t = plot(g)\n\njulia\n save(SVG(\nwheel10.svg\n), t)\n\n\n\n\nproducing a graph like this:\n\n\n\n\n\n\nGraphPlot.jl\n\n\nAnother graph visualization package that is very simple to use. \nCompose.jl\n is required for most rendering functionality:\n\n\njulia\n using GraphPlot, Compose\n\njulia\n g = WheelGraph(10)\n\njulia\n draw(PNG(\n/tmp/wheel10.png\n, 16cm, 16cm), gplot(g))\n\n\n\n\n\n\nMetis.jl\n\n\nThe Metis graph partitioning package can interface with \nLightGraphs.jl\n:\n\n\njulia\n using LightGraphs\n\njulia\n g = Graph(100,1000)\n{100, 1000} undirected graph\n\njulia\n partGraphKway(g, 6)  # 6 partitions\n\n\n\n\nNetworkViz.jl\n NetworkViz.jl is tightly coupled with \nLightGraphs.jl\n. Graphs can be visualized in 2D as well as 3D using \nThreeJS.jl\n and \nEscher.jl\n.\n\n\n#Run this code in Escher\n\nusing NetworkViz\nusing LightGraphs\n\nmain(window) = begin\n  push!(window.assets, \nwidgets\n)\n  push!(window.assets,(\nThreeJS\n,\nthreejs\n))\n  g = CompleteGraph(10)\n  drawGraph(g)\nend\n\n\n\n\nThe above code produces the following output:", 
            "title": "Integration with other packages"
        }, 
        {
            "location": "/integration/#integration-with-other-packages", 
            "text": "LightGraphs.jl 's integration with other Julia packages is designed to be straightforward. Here are a few examples.", 
            "title": "Integration with other packages"
        }, 
        {
            "location": "/integration/#graphsjl", 
            "text": "Creating a Graphs.jl  simple_graph  is easy:  julia  s = simple_graph(nv(g), is_directed=LightGraphs.is_directed(g))\njulia  for e in LightGraphs.edges(g)\n           add_edge!(s,src(e), dst(e))\n       end", 
            "title": "Graphs.jl"
        }, 
        {
            "location": "/integration/#graphlayoutjl", 
            "text": "This excellent graph visualization package can be used with  LightGraphs.jl  as follows:  julia  g = WheelGraph(10); am = full(adjacency_matrix(g))\njulia  loc_x, loc_y = layout_spring_adj(am)\njulia  draw_layout_adj(am, loc_x, loc_y, filename= wheel10.svg )  producing a graph like this:", 
            "title": "GraphLayout.jl"
        }, 
        {
            "location": "/integration/#tikzgraphsjl", 
            "text": "Another nice graph visualization package. ( TikzPictures.jl  required to render/save):  julia  g = WheelGraph(10); t = plot(g)\n\njulia  save(SVG( wheel10.svg ), t)  producing a graph like this:", 
            "title": "TikzGraphs.jl"
        }, 
        {
            "location": "/integration/#graphplotjl", 
            "text": "Another graph visualization package that is very simple to use.  Compose.jl  is required for most rendering functionality:  julia  using GraphPlot, Compose\n\njulia  g = WheelGraph(10)\n\njulia  draw(PNG( /tmp/wheel10.png , 16cm, 16cm), gplot(g))", 
            "title": "GraphPlot.jl"
        }, 
        {
            "location": "/integration/#metisjl", 
            "text": "The Metis graph partitioning package can interface with  LightGraphs.jl :  julia  using LightGraphs\n\njulia  g = Graph(100,1000)\n{100, 1000} undirected graph\n\njulia  partGraphKway(g, 6)  # 6 partitions", 
            "title": "Metis.jl"
        }, 
        {
            "location": "/integration/#networkvizjl-networkvizjl-is-tightly-coupled-with-lightgraphsjl-graphs-can-be-visualized-in-2d-as-well-as-3d-using-threejsjl-and-escherjl", 
            "text": "#Run this code in Escher\n\nusing NetworkViz\nusing LightGraphs\n\nmain(window) = begin\n  push!(window.assets,  widgets )\n  push!(window.assets,( ThreeJS , threejs ))\n  g = CompleteGraph(10)\n  drawGraph(g)\nend  The above code produces the following output:", 
            "title": "NetworkViz.jl NetworkViz.jl is tightly coupled with LightGraphs.jl. Graphs can be visualized in 2D as well as 3D using ThreeJS.jl and Escher.jl."
        }, 
        {
            "location": "/contributing/", 
            "text": "We welcome all possible contributors and ask that you read these guidelines before starting to work on this project. Following these guidelines will reduce friction and improve the speed at which your code gets merged.\n\n\n\n\nBug reports\n\n\nIf you notice code that is incorrect/crashes/too slow please file a bug report. The report should be raised as a github issue with a minimal working example that reproduces the error message. The example should include any data needed. If the problem is incorrectness, then please post the correct result along with an incorrect result.\n\n\nPlease include version numbers of all relevant libraries and Julia itself.\n\n\n\n\nDevelopment guidelines\n\n\n\n\nPRs should contain one logical enhancement to the codebase.\n\n\nSquash commits in a PR.\n\n\nOpen an issue to discuss a feature before you start coding (this maximizes the likelihood of patch acceptance).\n\n\n\n\nMinimize dependencies on external packages, and avoid introducing new dependencies. In general,\n\n\n\n\nPRs introducing dependencies on core Julia packages are ok.\n\n\nPRs introducing dependencies on non-core \"leaf\" packages (no subdependencies except for core Julia packages) are less ok.\n\n\nPRs introducing dependencies on non-core non-leaf packages require strict scrutiny and will likely not be accepted without some compelling reason (urgent bugfix or much-needed functionality).\n\n\nPut type assertions on all function arguments (use abstract types, Union, or Any if necessary).\n\n\nIf the algorithm was presented in a paper, include a reference to the paper (i.e. a proper academic citation along with an eprint link).\n\n\nTake steps to ensure that code works on graphs with multiple connected components efficiently.\n\n\nCorrectness is a necessary requirement; efficiency is desirable. Once you have a correct implementation, make a PR so we can help improve performance.\n\n\nWe can accept code that does not work for directed graphs as long as it comes with an explanation of what it would take to make it work for directed graphs.\n\n\nStyle point: prefer the short circuiting conditional over if/else when convenient, and where state is not explicitly being mutated (\ne.g.\n, \ncondition \n error(\"message\")\n is good; \ncondition \n i += 1\n is not).\n\n\nWhen possible write code to reuse memory. For example:\n\n\n\n\n\n\n\n\nfunction f(g, v)\n    storage = Vector{Int}(nv(g))\n    # some code operating on storage, g, and v.\n    for i in 1:nv(g)\n        storage[i] = v-i\n    end\n    return sum(storage)\nend\n\n\n\n\nshould be rewritten as two functions\n\n\nfunction f(g::AbstractGraph, v::Integer)\n    storage = Vector{Int}(nv(g))\n    return inner!(storage, g, v)\nend\n\nfunction inner!(storage::AbstractVector{Int}, g::AbstractGraph, v::Integer)\n    # some code operating on storage, g, and v.\n    for i in 1:nv(g)\n        storage[i] = v-i\n    end\n    return sum(storage)\nend\n\n\n\n\nThis allows us to reuse the memory and improve performance.", 
            "title": "Contributing"
        }, 
        {
            "location": "/contributing/#bug-reports", 
            "text": "If you notice code that is incorrect/crashes/too slow please file a bug report. The report should be raised as a github issue with a minimal working example that reproduces the error message. The example should include any data needed. If the problem is incorrectness, then please post the correct result along with an incorrect result.  Please include version numbers of all relevant libraries and Julia itself.", 
            "title": "Bug reports"
        }, 
        {
            "location": "/contributing/#development-guidelines", 
            "text": "PRs should contain one logical enhancement to the codebase.  Squash commits in a PR.  Open an issue to discuss a feature before you start coding (this maximizes the likelihood of patch acceptance).   Minimize dependencies on external packages, and avoid introducing new dependencies. In general,   PRs introducing dependencies on core Julia packages are ok.  PRs introducing dependencies on non-core \"leaf\" packages (no subdependencies except for core Julia packages) are less ok.  PRs introducing dependencies on non-core non-leaf packages require strict scrutiny and will likely not be accepted without some compelling reason (urgent bugfix or much-needed functionality).  Put type assertions on all function arguments (use abstract types, Union, or Any if necessary).  If the algorithm was presented in a paper, include a reference to the paper (i.e. a proper academic citation along with an eprint link).  Take steps to ensure that code works on graphs with multiple connected components efficiently.  Correctness is a necessary requirement; efficiency is desirable. Once you have a correct implementation, make a PR so we can help improve performance.  We can accept code that does not work for directed graphs as long as it comes with an explanation of what it would take to make it work for directed graphs.  Style point: prefer the short circuiting conditional over if/else when convenient, and where state is not explicitly being mutated ( e.g. ,  condition   error(\"message\")  is good;  condition   i += 1  is not).  When possible write code to reuse memory. For example:     function f(g, v)\n    storage = Vector{Int}(nv(g))\n    # some code operating on storage, g, and v.\n    for i in 1:nv(g)\n        storage[i] = v-i\n    end\n    return sum(storage)\nend  should be rewritten as two functions  function f(g::AbstractGraph, v::Integer)\n    storage = Vector{Int}(nv(g))\n    return inner!(storage, g, v)\nend\n\nfunction inner!(storage::AbstractVector{Int}, g::AbstractGraph, v::Integer)\n    # some code operating on storage, g, and v.\n    for i in 1:nv(g)\n        storage[i] = v-i\n    end\n    return sum(storage)\nend  This allows us to reuse the memory and improve performance.", 
            "title": "Development guidelines"
        }, 
        {
            "location": "/license/", 
            "text": "The LightGraphs.jl package is licensed under the Simplified \"2-clause\" BSD License:\n\n\n\n\nCopyright (c) 2015: Seth Bromberger and other contributors.\n\n\nRedistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n\n\n\n\nRedistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\n\n\nRedistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\n\n\n\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\n\n\n\nLightGraphs uses code derived from and/or inspired by the following packages:\n\n\nNetworkX:\n\n\n\n\nCopyright (C) 2004-2012, NetworkX Developers Aric Hagberg \n Dan Schult \n Pieter Swart \n All rights reserved.\n\n\nRedistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n\n\n\n\nRedistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\n\n\nRedistributions in binary form must reproduce the above with the distribution.\n\n\nNeither the name of the NetworkX Developers nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.\n\n\n\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\n\n\n\nGraphs.jl:\n\n\n\n\nCopyright (c) 2012: John Myles White and other contributors.\n\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n\n\nThe above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.", 
            "title": "License Information"
        }
    ]
}