<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Path and Traversal · LightGraphs</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link href="assets/highlightjs/default.css" rel="stylesheet" type="text/css"/><link href="assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>LightGraphs</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" action="search.html"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="index.html">Getting Started</a></li><li><a class="toctext" href="basicmeasures.html">Basic Functions</a></li><li><a class="toctext" href="operators.html">Operators</a></li><li class="current"><a class="toctext" href="pathing.html">Path and Traversal</a><ul class="internal"><li><a class="toctext" href="#Graph-Traversal-1">Graph Traversal</a></li><li><a class="toctext" href="#Random-walks-1">Random walks</a></li><li><a class="toctext" href="#Connectivity-/-Bipartiteness-1">Connectivity / Bipartiteness</a></li><li><a class="toctext" href="#Cycle-Detection-1">Cycle Detection</a></li><li><a class="toctext" href="#Shortest-Path-Algorithms-1">Shortest-Path Algorithms</a></li><li><a class="toctext" href="#Path-discovery-/-enumeration-1">Path discovery / enumeration</a></li></ul></li><li><a class="toctext" href="distance.html">Distance</a></li><li><a class="toctext" href="centrality.html">Centrality Measures</a></li><li><a class="toctext" href="linalg.html">Linear Algebra</a></li><li><a class="toctext" href="matching.html">Matching</a></li><li><a class="toctext" href="community.html">Community Structures</a></li><li><a class="toctext" href="degeneracy.html">Degeneracy</a></li><li><a class="toctext" href="flowcut.html">Flow and Cut</a></li><li><a class="toctext" href="generators.html">Graph Generators</a></li><li><a class="toctext" href="persistence.html">Reading / Writing Graphs</a></li><li><a class="toctext" href="integration.html">Integration with other packages</a></li><li><a class="toctext" href="contributing.html">Contributing</a></li><li><a class="toctext" href="license.html">License Information</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href="pathing.html">Path and Traversal</a></li></ul><a class="edit-page" href="https://github.com/JuliaGraphs/LightGraphs.jl/tree/7f7db189e08fb8ea1ad799ae72f68a6abbe7b253/docs/src/pathing.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Path and Traversal</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Path-and-Traversal-1" href="#Path-and-Traversal-1">Path and Traversal</a></h1><p><em>LightGraphs.jl</em> provides several traversal and shortest-path algorithms, along with various utility functions. Where appropriate, edge distances may be passed in as a matrix of real number values.</p><p>Edge distances for most traversals may be passed in as a sparse or dense matrix of  values, indexed by <code>[src,dst]</code> vertices. That is, <code>distmx[2,4] = 2.5</code> assigns the distance <code>2.5</code> to the (directed) edge connecting vertex 2 and vertex 4. Note that also for undirected graphs <code>distmx[4,2]</code> has to be set.</p><p>Any graph traversal  will traverse an edge only if it is present in the graph. When a distance matrix is passed in,</p><ol><li><p>distance values for undefined edges will be ignored, and</p></li><li><p>any unassigned values (in sparse distance matrices), for edges that are present in the graph, will be assumed to take the default value of 1.0.</p></li><li><p>any zero values (in sparse/dense distance matrices), for edges that are present in the graph, will instead have an implicit edge cost of 1.0.</p></li></ol><h2><a class="nav-anchor" id="Graph-Traversal-1" href="#Graph-Traversal-1">Graph Traversal</a></h2><p><em>Graph traversal</em> refers to a process that traverses vertices of a graph following certain order (starting from user-input sources). This package implements three traversal schemes:</p><ul><li><p><code>BreadthFirst</code>,</p></li><li><p><code>DepthFirst</code>, and</p></li><li><p><code>MaximumAdjacency</code>.</p></li></ul><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LightGraphs.bfs_tree" href="#LightGraphs.bfs_tree"><code>LightGraphs.bfs_tree</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">bfs_tree(g, s)</code></pre><p>Provide a breadth-first traversal of the graph <code>g</code> starting with source vertex <code>s</code>, and return a directed acyclic graph of vertices in the order they were discovered.</p><p><strong>Implementation Notes</strong></p><p>This function is a high level wrapper around <a href="@ref"><code>bfs_tree!</code></a>; use that function for more performance.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphs/LightGraphs.jl/tree/7f7db189e08fb8ea1ad799ae72f68a6abbe7b253/docs/../src/traversals/bfs.jl#L147-L155">source</a><br/><div><pre><code class="language-none">bfs_tree(LevelSynchronousBFS(), g, s, nv)</code></pre><p>Provide a parallel breadth-first traversal of the graph <code>g</code> starting with source vertex <code>s</code>, and return a directed acyclic graph of vertices in the order they were discovered using a frontier based parallel approach.</p><p><strong>Implementation Notes</strong></p><p>This function uses <code>@threads</code> for parallelism which depends on the <code>JULIA_NUM_THREADS</code> environment variable to decide the number of threads to use. Refer <code>@threads</code> documentation for more details. This function is a high level wrapper around <a href="@ref"><code>bfs_tree!</code></a>; use that function for more performance.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphs/LightGraphs.jl/tree/7f7db189e08fb8ea1ad799ae72f68a6abbe7b253/docs/../src/traversals/parallel_bfs.jl#L106-L118">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LightGraphs.dfs_tree" href="#LightGraphs.dfs_tree"><code>LightGraphs.dfs_tree</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">dfs_tree(g, s)</code></pre><p>Return an ordered vector of vertices representing a directed acylic graph based on depth-first traversal of the graph <code>g</code> starting with source vertex <code>s</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphs/LightGraphs.jl/tree/7f7db189e08fb8ea1ad799ae72f68a6abbe7b253/docs/../src/traversals/dfs.jl#L186-L191">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LightGraphs.maximum_adjacency_visit" href="#LightGraphs.maximum_adjacency_visit"><code>LightGraphs.maximum_adjacency_visit</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">maximum_adjacency_visit(g[, distmx][, log][, io])</code></pre><p>Return the vertices in <code>g</code> traversed by maximum adjacency search. An optional <code>distmx</code> matrix may be specified; if omitted, edge distances are assumed to be 1. If <code>log</code> (default <code>false</code>) is <code>true</code>, visitor events will be printed to <code>io</code>, which defaults to <code>STDOUT</code>; otherwise, no event information will be displayed.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphs/LightGraphs.jl/tree/7f7db189e08fb8ea1ad799ae72f68a6abbe7b253/docs/../src/traversals/maxadjvisit.jl#L196-L204">source</a><br/></section><h2><a class="nav-anchor" id="Random-walks-1" href="#Random-walks-1">Random walks</a></h2><p><em>LightGraphs</em> includes uniform random walks and self avoiding walks:</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LightGraphs.randomwalk" href="#LightGraphs.randomwalk"><code>LightGraphs.randomwalk</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">randomwalk(g, s, niter)</code></pre><p>Perform a random walk on graph <code>g</code> starting at vertex <code>s</code> and continuing for a maximum of <code>niter</code> steps. Return a vector of vertices visited in order.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphs/LightGraphs.jl/tree/7f7db189e08fb8ea1ad799ae72f68a6abbe7b253/docs/../src/traversals/randomwalks.jl#L1-L6">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LightGraphs.saw" href="#LightGraphs.saw"><code>LightGraphs.saw</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">saw(g, s, niter)</code></pre><p>Perform a <a href="https://en.wikipedia.org/wiki/Self-avoiding_walk">self-avoiding walk</a> on graph <code>g</code> starting at vertex <code>s</code> and continuing for a maximum of <code>niter</code> steps. Return a vector of vertices visited in order.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphs/LightGraphs.jl/tree/7f7db189e08fb8ea1ad799ae72f68a6abbe7b253/docs/../src/traversals/randomwalks.jl#L93-L98">source</a><br/></section><h2><a class="nav-anchor" id="Connectivity-/-Bipartiteness-1" href="#Connectivity-/-Bipartiteness-1">Connectivity / Bipartiteness</a></h2><p><code>Graph connectivity</code> functions are defined on both undirected and directed graphs:</p><pre><code class="language-none">is_connected
is_strongly_connected
is_weakly_connected
connected_components
strongly_connected_components
weakly_connected_components
has_self_loop
attracting_components
is_bipartite
condensation
period</code></pre><h2><a class="nav-anchor" id="Cycle-Detection-1" href="#Cycle-Detection-1">Cycle Detection</a></h2><p>In graph theory, a cycle is defined to be a path that starts from some vertex <code>v</code> and ends up at <code>v</code>.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LightGraphs.is_cyclic" href="#LightGraphs.is_cyclic"><code>LightGraphs.is_cyclic</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">is_cyclic(g)</code></pre><p>Return <code>true</code> if graph <code>g</code> contains a cycle.</p><p><strong>Implementation Notes</strong></p><p>Uses DFS.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphs/LightGraphs.jl/tree/7f7db189e08fb8ea1ad799ae72f68a6abbe7b253/docs/../src/traversals/dfs.jl#L114-L121">source</a><br/></section><h2><a class="nav-anchor" id="Shortest-Path-Algorithms-1" href="#Shortest-Path-Algorithms-1">Shortest-Path Algorithms</a></h2><h3><a class="nav-anchor" id="General-properties-of-shortest-path-algorithms-1" href="#General-properties-of-shortest-path-algorithms-1">General properties of shortest path algorithms</a></h3><ul><li><p>The distance from a vertex to itself is always <code>0</code>.</p></li><li><p>The distance between two vertices with no connecting edge is always <code>Inf</code>.</p></li></ul><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LightGraphs.a_star" href="#LightGraphs.a_star"><code>LightGraphs.a_star</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">a_star(g, s, t[, distmx][, heuristic])</code></pre><p>Return a vector of edges comprising the shortest path between vertices <code>s</code> and <code>t</code> using the <a href="http://en.wikipedia.org/wiki/A%2A_search_algorithm">A* search algorithm</a>. An optional heuristic function and edge distance matrix may be supplied. If missing, the distance matrix is set to <a href="@ref"><code>DefaultDistance</code></a> and the heuristic is set to <code>n -&gt; 0</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphs/LightGraphs.jl/tree/7f7db189e08fb8ea1ad799ae72f68a6abbe7b253/docs/../src/shortestpaths/astar.jl#L38-L46">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LightGraphs.dijkstra_shortest_paths" href="#LightGraphs.dijkstra_shortest_paths"><code>LightGraphs.dijkstra_shortest_paths</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">dijkstra_shortest_paths(g, srcs, distmx=weights(g));</code></pre><p>Perform <a href="http://en.wikipedia.org/wiki/Dijkstra%27s_algorithm">Dijkstra&#39;s algorithm</a> on a graph, computing shortest distances between <code>srcs</code> and all other vertices. Return a <a href="@ref"><code>DijkstraState</code></a> that contains various traversal information.</p><p><strong>Optional Arguments</strong></p><ul><li><p><code>allpaths=false</code>: If true, returns a <a href="@ref"><code>DijkstraState</code></a> that keeps track of all</p></li></ul><p>predecessors of a given vertex.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphs/LightGraphs.jl/tree/7f7db189e08fb8ea1ad799ae72f68a6abbe7b253/docs/../src/shortestpaths/dijkstra.jl#L21-L31">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LightGraphs.bellman_ford_shortest_paths" href="#LightGraphs.bellman_ford_shortest_paths"><code>LightGraphs.bellman_ford_shortest_paths</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">bellman_ford_shortest_paths(g, s, distmx=weights(g))
bellman_ford_shortest_paths(g, ss, distmx=weights(g))</code></pre><p>Compute shortest paths between a source <code>s</code> (or list of sources <code>ss</code>) and all other nodes in graph <code>g</code> using the <a href="http://en.wikipedia.org/wiki/Bellman–Ford_algorithm">Bellman-Ford algorithm</a>. Return a <a href="@ref"><code>BellmanFordState</code></a> with relevant traversal information.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphs/LightGraphs.jl/tree/7f7db189e08fb8ea1ad799ae72f68a6abbe7b253/docs/../src/shortestpaths/bellman-ford.jl#L62-L69">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LightGraphs.floyd_warshall_shortest_paths" href="#LightGraphs.floyd_warshall_shortest_paths"><code>LightGraphs.floyd_warshall_shortest_paths</code></a> — <span class="docstring-category">Function</span>.</div><div><p>floyd_warshall_shortest_paths(g, distmx=weights(g)) Use the <a href="http://en.wikipedia.org/wiki/Floyd–Warshall_algorithm">Floyd-Warshall algorithm</a> to compute the shortest paths between all pairs of vertices in graph <code>g</code> using an optional distance matrix <code>distmx</code>. Return a <a href="@ref"><code>FloydWarshallState</code></a> with relevant traversal information.</p><p><strong>Performance</strong></p><p>Space complexity is on the order of <span>$\mathcal{O}(|V|^2)$</span>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphs/LightGraphs.jl/tree/7f7db189e08fb8ea1ad799ae72f68a6abbe7b253/docs/../src/shortestpaths/floyd-warshall.jl#L15">source</a><br/></section><h2><a class="nav-anchor" id="Path-discovery-/-enumeration-1" href="#Path-discovery-/-enumeration-1">Path discovery / enumeration</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LightGraphs.gdistances" href="#LightGraphs.gdistances"><code>LightGraphs.gdistances</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">gdistances(g, source)</code></pre><p>Return a vector filled with the geodesic distances of vertices in  <code>g</code> from <code>source</code>. If <code>source</code> is a collection of vertices each element should be unique. For vertices in disconnected components the default distance is -1.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphs/LightGraphs.jl/tree/7f7db189e08fb8ea1ad799ae72f68a6abbe7b253/docs/../src/traversals/bfs.jl#L297-L303">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LightGraphs.gdistances!" href="#LightGraphs.gdistances!"><code>LightGraphs.gdistances!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">gdistances!(g, source, dists)</code></pre><p>Fill <code>dists</code> with the geodesic distances of vertices in <code>g</code> from <code>source</code>. <code>dists</code> should be a vector of length <code>nv(g)</code>. Return <code>dists</code>. For vertices in disconnected components the default distance is -1.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphs/LightGraphs.jl/tree/7f7db189e08fb8ea1ad799ae72f68a6abbe7b253/docs/../src/traversals/bfs.jl#L263-L269">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LightGraphs.enumerate_paths" href="#LightGraphs.enumerate_paths"><code>LightGraphs.enumerate_paths</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">enumerate_paths(state[, vs])</code></pre><p>Given a path state <code>state</code> of type <code>AbstractPathState</code>, return a vector (indexed by vertex) of the paths between the source vertex used to compute the path state and a single destination vertex, a list of destination vertices, or the entire graph. For multiple destination vertices, each path is represented by a vector of vertices on the path between the source and the destination. Nonexistent paths will be indicated by an empty vector. For single destinations, the path is represented by a single vector of vertices, and will be length 0 if the path does not exist.</p><p><strong>Implementation Notes</strong></p><p>For Floyd-Warshall path states, please note that the output is a bit different, since this algorithm calculates all shortest paths for all pairs of vertices: <code>enumerate_paths(state)</code> will return a vector (indexed by source vertex) of vectors (indexed by destination vertex) of paths. <code>enumerate_paths(state, v)</code> will return a vector (indexed by destination vertex) of paths from source <code>v</code> to all other vertices. In addition, <code>enumerate_paths(state, v, d)</code> will return a vector representing the path from vertex <code>v</code> to vertex <code>d</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphs/LightGraphs.jl/tree/7f7db189e08fb8ea1ad799ae72f68a6abbe7b253/docs/../src/shortestpaths/bellman-ford.jl#L120-L139">source</a><br/></section><h3><a class="nav-anchor" id="Path-States-1" href="#Path-States-1">Path States</a></h3><p>The <code>floyd_warshall_shortest_paths</code>, <code>bellman_ford_shortest_paths</code>, <code>dijkstra_shortest_paths</code>, and <code>dijkstra_predecessor_and_distance</code> functions return a state that contains various information about the graph learned during traversal. The three state types have the following common information, accessible via the type:</p><p><code>.dists</code> Holds a vector of distances computed, indexed by source vertex.</p><p><code>.parents</code> Holds a vector of parents of each source vertex. The parent of a source vertex is always <code>0</code>.</p><p>In addition, the <code>dijkstra_predecessor_and_distance</code> function stores the following information:</p><p><code>.predecessors</code> Holds a vector, indexed by vertex, of all the predecessors discovered during shortest-path calculations. This keeps track of all parents when there are multiple shortest paths available from the source.</p><p><code>.pathcounts</code> Holds a vector, indexed by vertex, of the path counts discovered during traversal. This equals the length of each subvector in the <code>.predecessors</code> output above.</p><footer><hr/><a class="previous" href="operators.html"><span class="direction">Previous</span><span class="title">Operators</span></a><a class="next" href="distance.html"><span class="direction">Next</span><span class="title">Distance</span></a></footer></article></body></html>
