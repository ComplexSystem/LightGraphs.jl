
<!DOCTYPE html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
        <meta name="author" content="Seth Bromberger">
      
      
        <link rel="shortcut icon" href="../assets/images/favicon.png">
      
      <meta name="generator" content="mkdocs-0.16.3, mkdocs-material-1.6.4">
    
    
      
        <title>Flow and Cut - LightGraphs.jl</title>
      
    
    
      <script src="../assets/javascripts/modernizr-1df76c4e58.js"></script>
    
    
      <link rel="stylesheet" href="../assets/stylesheets/application-e2807e330f.css">
      
        <link rel="stylesheet" href="../assets/stylesheets/application-f78e5cb881.palette.css">
      
    
    
      
        
        
        
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,400,400i,700|Roboto+Mono">
        <style>body,input{font-family:"Roboto","Helvetica Neue",Helvetica,Arial,sans-serif}code,kbd,pre{font-family:"Roboto Mono","Courier New",Courier,monospace}</style>
      
      <link rel="stylesheet" href="https://fonts.googleapis.com/icon?family=Material+Icons">
    
    
      <link rel="stylesheet" href="../assets/Documenter.css">
    
    
  </head>
  
  
  
  
    <body data-md-color-primary="indigo" data-md-color-accent="blue">
  
    <svg class="md-svg">
      <defs>
        
        
          <svg xmlns="http://www.w3.org/2000/svg" width="416" height="448" viewBox="0 0 416 448" id="github"><path fill="currentColor" d="M160 304q0 10-3.125 20.5t-10.75 19T128 352t-18.125-8.5-10.75-19T96 304t3.125-20.5 10.75-19T128 256t18.125 8.5 10.75 19T160 304zm160 0q0 10-3.125 20.5t-10.75 19T288 352t-18.125-8.5-10.75-19T256 304t3.125-20.5 10.75-19T288 256t18.125 8.5 10.75 19T320 304zm40 0q0-30-17.25-51T296 232q-10.25 0-48.75 5.25Q229.5 240 208 240t-39.25-2.75Q130.75 232 120 232q-29.5 0-46.75 21T56 304q0 22 8 38.375t20.25 25.75 30.5 15 35 7.375 37.25 1.75h42q20.5 0 37.25-1.75t35-7.375 30.5-15 20.25-25.75T360 304zm56-44q0 51.75-15.25 82.75-9.5 19.25-26.375 33.25t-35.25 21.5-42.5 11.875-42.875 5.5T212 416q-19.5 0-35.5-.75t-36.875-3.125-38.125-7.5-34.25-12.875T37 371.5t-21.5-28.75Q0 312 0 260q0-59.25 34-99-6.75-20.5-6.75-42.5 0-29 12.75-54.5 27 0 47.5 9.875t47.25 30.875Q171.5 96 212 96q37 0 70 8 26.25-20.5 46.75-30.25T376 64q12.75 25.5 12.75 54.5 0 21.75-6.75 42 34 40 34 99.5z"/></svg>
        
      </defs>
    </svg>
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="drawer">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="search">
    <label class="md-overlay" data-md-component="overlay" for="drawer"></label>
    
      <header class="md-header" data-md-component="header">
  <nav class="md-header-nav md-grid">
    <div class="md-flex">
      <div class="md-flex__cell md-flex__cell--shrink">
        
          <a href=".." title="LightGraphs.jl" class="md-icon md-icon--home md-header-nav__button">
          </a>
        
      </div>
      <div class="md-flex__cell md-flex__cell--shrink">
        <label class="md-icon md-icon--menu md-header-nav__button" for="drawer"></label>
      </div>
      <div class="md-flex__cell md-flex__cell--stretch">
        <span class="md-flex__ellipsis md-header-nav__title">
          
            
              
            
            Flow and Cut
          
        </span>
      </div>
      <div class="md-flex__cell md-flex__cell--shrink">
        
          <label class="md-icon md-icon--search md-header-nav__button" for="search"></label>
          
<div class="md-search" data-md-component="search">
  <label class="md-search__overlay" for="search"></label>
  <div class="md-search__inner">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" required placeholder="Search" accesskey="s" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="query">
      <label class="md-icon md-search__icon" for="search"></label>
      <button type="reset" class="md-icon md-search__icon" data-md-component="reset">close</button>
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" data-md-scrollfix>
        <div class="md-search-result" data-md-component="result">
          <div class="md-search-result__meta" data-md-lang-result-none="No matching documents" data-md-lang-result-one="1 matching document" data-md-lang-result-other="# matching documents">
            Type to start searching
          </div>
          <ol class="md-search-result__list"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
        
      </div>
      <div class="md-flex__cell md-flex__cell--shrink">
        <div class="md-header-nav__source">
          
            


  


  <a href="https://github.com/JuliaGraphs/LightGraphs.jl/" title="Go to repository" class="md-source" data-md-source="github">
    
      <div class="md-source__icon">
        <svg viewBox="0 0 24 24" width="24" height="24">
          <use xlink:href="#github" width="24" height="24"></use>
        </svg>
      </div>
    
    <div class="md-source__repository">
      GitHub
    </div>
  </a>

          
        </div>
      </div>
    </div>
  </nav>
</header>
    
    <div class="md-container">
      
      
      <main class="md-main">
        <div class="md-main__inner md-grid" data-md-component="container">
          
            
              <div class="md-sidebar md-sidebar--primary" data-md-component="navigation">
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    <nav class="md-nav md-nav--primary" data-md-level="0">
  <label class="md-nav__title md-nav__title--site" for="drawer">
    
      <i class="md-icon md-icon--home md-nav__button"></i>
    
    LightGraphs.jl
  </label>
  
    <div class="md-nav__source">
      


  


  <a href="https://github.com/JuliaGraphs/LightGraphs.jl/" title="Go to repository" class="md-source" data-md-source="github">
    
      <div class="md-source__icon">
        <svg viewBox="0 0 24 24" width="24" height="24">
          <use xlink:href="#github" width="24" height="24"></use>
        </svg>
      </div>
    
    <div class="md-source__repository">
      GitHub
    </div>
  </a>

    </div>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
      


  <li class="md-nav__item">
    <a href=".." title="Getting Started" class="md-nav__link">
      Getting Started
    </a>
  </li>

    
      
      
      


  <li class="md-nav__item">
    <a href="../basicmeasures/" title="Basic Functions" class="md-nav__link">
      Basic Functions
    </a>
  </li>

    
      
      
      


  <li class="md-nav__item">
    <a href="../operators/" title="Operators" class="md-nav__link">
      Operators
    </a>
  </li>

    
      
      
      


  <li class="md-nav__item">
    <a href="../pathing/" title="Path and Traversal" class="md-nav__link">
      Path and Traversal
    </a>
  </li>

    
      
      
      


  <li class="md-nav__item">
    <a href="../distance/" title="Distance" class="md-nav__link">
      Distance
    </a>
  </li>

    
      
      
      


  <li class="md-nav__item">
    <a href="../centrality/" title="Centrality Measures" class="md-nav__link">
      Centrality Measures
    </a>
  </li>

    
      
      
      


  <li class="md-nav__item">
    <a href="../linalg/" title="Linear Algebra" class="md-nav__link">
      Linear Algebra
    </a>
  </li>

    
      
      
      


  <li class="md-nav__item">
    <a href="../matching/" title="Matching" class="md-nav__link">
      Matching
    </a>
  </li>

    
      
      
      


  <li class="md-nav__item">
    <a href="../community/" title="Community Structures" class="md-nav__link">
      Community Structures
    </a>
  </li>

    
      
      
      

  


  <li class="md-nav__item md-nav__item--active">
    
    <input class="md-toggle md-nav__toggle" data-md-toggle="toc" type="checkbox" id="toc">
    
      
    
    
    <a href="./" title="Flow and Cut" class="md-nav__link md-nav__link--active">
      Flow and Cut
    </a>
    
  </li>

    
      
      
      


  <li class="md-nav__item">
    <a href="../generators/" title="Graph Generators" class="md-nav__link">
      Graph Generators
    </a>
  </li>

    
      
      
      


  <li class="md-nav__item">
    <a href="../persistence/" title="Reading / Writing Graphs" class="md-nav__link">
      Reading / Writing Graphs
    </a>
  </li>

    
      
      
      


  <li class="md-nav__item">
    <a href="../integration/" title="Integration with other packages" class="md-nav__link">
      Integration with other packages
    </a>
  </li>

    
      
      
      


  <li class="md-nav__item">
    <a href="../contributing/" title="Contributing" class="md-nav__link">
      Contributing
    </a>
  </li>

    
      
      
      


  <li class="md-nav__item">
    <a href="../license/" title="License Information" class="md-nav__link">
      License Information
    </a>
  </li>

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              <div class="md-sidebar md-sidebar--secondary" data-md-component="toc">
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    
<nav class="md-nav md-nav--secondary">
  
  
    
  
  
</nav>
                  </div>
                </div>
              </div>
            
          
          <div class="md-content">
            <article class="md-content__inner md-typeset">
              
                
                  <a href="https://github.com/JuliaGraphs/LightGraphs.jl/edit/master/docs/flowcut.md" title="Edit this page" class="md-icon md-content__icon">edit</a>
                
                
                <p><a id='Flow-and-Cut-1'></a></p>
<h1 id="flow-and-cut">Flow and Cut</h1>
<p><em>LightGraphs.jl</em> provides different algorithms for <a href="https://en.wikipedia.org/wiki/Maximum_flow_problem">maximum flow</a> and minimum cut computations.</p>
<p><a id='LightGraphs' href='#LightGraphs'>#</a>
<strong><code>LightGraphs</code></strong> &mdash; <em>Module</em>.</p>
<pre><code>LightGraphs
</code></pre>

<p>An optimized graphs package.</p>
<p>Simple graphs (not multi- or hypergraphs) are represented in a memory- and time-efficient manner with adjacency lists and edge sets. Both directed and undirected graphs are supported via separate types, and conversion is available from directed to undirected.</p>
<p>The project goal is to mirror the functionality of robust network and graph analysis libraries such as NetworkX while being simpler to use and more efficient than existing Julian graph libraries such as Graphs.jl. It is an explicit design decision that any data not required for graph manipulation (attributes and other information, for example) is expected to be stored outside of the graph structure itself. Such data lends itself to storage in more traditional and better-optimized mechanisms.</p>
<p><a href="http://codecov.io/github/JuliaGraphs/LightGraphs.jl">Full documentation</a> is available, and tutorials are available at the <a href="https://github.com/JuliaGraphs/JuliaGraphsTutorials">JuliaGraphsTutorials repository</a>.</p>
<p><a target='_blank' href='https://github.com/JuliaLang/julia/tree/82e96382251a1e163860df03c846acec86d07c36/base/docs/Docs.jl#L120-L141' class='documenter-source'>source</a><br></p>
<p><a id='LightGraphs.Nonbacktracking' href='#LightGraphs.Nonbacktracking'>#</a>
<strong><code>LightGraphs.Nonbacktracking</code></strong> &mdash; <em>Type</em>.</p>
<pre><code>Nonbacktracking{G}
</code></pre>

<p>A compact representation of the nonbacktracking operator.</p>
<p>The Nonbacktracking operator can be used for community detection. This representation is compact in that it uses only ne(g) additional storage and provides an implicit representation of the matrix B_g defined below.</p>
<p>Given two arcs $A_{i j}<code>and</code>A_{k l}<code>in</code>g`, the non-backtraking matrix$B`` is defined as</p>
<p>$B_{A_{i j}, A_{k l}} = δ_{j k} * (1 - δ_{i l})$</p>
<p>This type is in the style of GraphMatrices.jl and supports the necessary operations for computed eigenvectors and conducting linear solves.</p>
<p>Additionally the <code>contract!(vertexspace, nbt, edgespace)</code> method takes vectors represented in the domain of $B$ and represents them in the domain of the adjacency matrix of <code>g</code>.</p>
<p><a target='_blank' href='https://github.com/JuliaLang/julia/tree/82e96382251a1e163860df03c846acec86d07c36/base/docs/Docs.jl#L47' class='documenter-source'>source</a><br></p>
<p><a id='LightGraphs.StochasticBlockModel' href='#LightGraphs.StochasticBlockModel'>#</a>
<strong><code>LightGraphs.StochasticBlockModel</code></strong> &mdash; <em>Type</em>.</p>
<pre><code>StochasticBlockModel{T,P}
</code></pre>

<p>A type capturing the parameters of the SBM. Each vertex is assigned to a block and the probability of edge <code>(i,j)</code> depends only on the block labels of vertex <code>i</code> and vertex <code>j</code>.</p>
<p>The assignement is stored in nodemap and the block affinities a <code>k</code> by <code>k</code> matrix is stored in affinities.</p>
<p><code>affinities[k,l]</code> is the probability of an edge between any vertex in block <code>k</code> and any vertex in block <code>l</code>.</p>
<p><strong>Implementation Notes</strong></p>
<p>Graphs are generated by taking random $i,j ∈ V$ and flipping a coin with probability <code>affinities[nodemap[i],nodemap[j]]</code>.</p>
<p><a target='_blank' href='https://github.com/JuliaLang/julia/tree/82e96382251a1e163860df03c846acec86d07c36/base/docs/Docs.jl#L659-L675' class='documenter-source'>source</a><br></p>
<p><a id='LightGraphs.AbstractEdge' href='#LightGraphs.AbstractEdge'>#</a>
<strong><code>LightGraphs.AbstractEdge</code></strong> &mdash; <em>Type</em>.</p>
<pre><code>AbstractEdge
</code></pre>

<p>An absract type representing a single edge between two vertices of a graph.</p>
<p><a target='_blank' href='https://github.com/JuliaLang/julia/tree/82e96382251a1e163860df03c846acec86d07c36/base/docs/Docs.jl#L5-L9' class='documenter-source'>source</a><br></p>
<p><a id='LightGraphs.AbstractGraph' href='#LightGraphs.AbstractGraph'>#</a>
<strong><code>LightGraphs.AbstractGraph</code></strong> &mdash; <em>Type</em>.</p>
<pre><code>AbstractGraph
</code></pre>

<p>An abstract type representing a graph.</p>
<p><a target='_blank' href='https://github.com/JuliaLang/julia/tree/82e96382251a1e163860df03c846acec86d07c36/base/docs/Docs.jl#L19-L23' class='documenter-source'>source</a><br></p>
<p><a id='LightGraphs.BoykovKolmogorovAlgorithm' href='#LightGraphs.BoykovKolmogorovAlgorithm'>#</a>
<strong><code>LightGraphs.BoykovKolmogorovAlgorithm</code></strong> &mdash; <em>Type</em>.</p>
<pre><code>BoykovKolmogorovAlgorithm &lt;: AbstractFlowAlgorithm
</code></pre>

<p>Forces the maximum_flow function to use the Boykov-Kolmogorov algorithm.</p>
<p><a target='_blank' href='https://github.com/JuliaLang/julia/tree/82e96382251a1e163860df03c846acec86d07c36/base/docs/Docs.jl#L22-L26' class='documenter-source'>source</a><br></p>
<p><a id='LightGraphs.BreadthFirst' href='#LightGraphs.BreadthFirst'>#</a>
<strong><code>LightGraphs.BreadthFirst</code></strong> &mdash; <em>Type</em>.</p>
<pre><code>BreadthFirst
</code></pre>

<p><strong>Conventions in Breadth First Search and Depth First Search</strong></p>
<p><strong>VertexColorMap</strong></p>
<ul>
<li>color == 0    =&gt; unseen</li>
<li>color &lt; 0     =&gt; examined but not closed</li>
<li>color &gt; 0     =&gt; examined and closed</li>
</ul>
<p><strong>EdgeColorMap</strong></p>
<ul>
<li>color == 0    =&gt; unseen</li>
<li>color == 1    =&gt; examined</li>
</ul>
<p><a target='_blank' href='https://github.com/JuliaLang/julia/tree/82e96382251a1e163860df03c846acec86d07c36/base/docs/Docs.jl#L11-L23' class='documenter-source'>source</a><br></p>
<p><a id='LightGraphs.DepthFirst' href='#LightGraphs.DepthFirst'>#</a>
<strong><code>LightGraphs.DepthFirst</code></strong> &mdash; <em>Type</em>.</p>
<pre><code>DepthFirst
</code></pre>

<p><strong>Conventions in Breadth First Search and Depth First Search</strong></p>
<p><strong>VertexColorMap</strong></p>
<ul>
<li>color == 0    =&gt; unseen</li>
<li>color &lt; 0     =&gt; examined but not closed</li>
<li>color &gt; 0     =&gt; examined and closed</li>
</ul>
<p><strong>EdgeColorMap</strong></p>
<ul>
<li>color == 0    =&gt; unseen</li>
<li>color == 1     =&gt; examined</li>
</ul>
<p><a target='_blank' href='https://github.com/JuliaLang/julia/tree/82e96382251a1e163860df03c846acec86d07c36/base/docs/Docs.jl#L12-L23' class='documenter-source'>source</a><br></p>
<p><a id='LightGraphs.DinicAlgorithm' href='#LightGraphs.DinicAlgorithm'>#</a>
<strong><code>LightGraphs.DinicAlgorithm</code></strong> &mdash; <em>Type</em>.</p>
<pre><code>DinicAlgorithm &lt;: AbstractFlowAlgorithm
</code></pre>

<p>Forces the maximum_flow function to use Dinic's algorithm.</p>
<p><a target='_blank' href='https://github.com/JuliaLang/julia/tree/82e96382251a1e163860df03c846acec86d07c36/base/docs/Docs.jl#L15-L19' class='documenter-source'>source</a><br></p>
<p><a id='LightGraphs.EdmondsKarpAlgorithm' href='#LightGraphs.EdmondsKarpAlgorithm'>#</a>
<strong><code>LightGraphs.EdmondsKarpAlgorithm</code></strong> &mdash; <em>Type</em>.</p>
<pre><code>EdmondsKarpAlgorithm &lt;: AbstractFlowAlgorithm
</code></pre>

<p>Forces the maximum_flow function to use the Edmonds–Karp algorithm.</p>
<p><a target='_blank' href='https://github.com/JuliaLang/julia/tree/82e96382251a1e163860df03c846acec86d07c36/base/docs/Docs.jl#L8-L12' class='documenter-source'>source</a><br></p>
<p><a id='LightGraphs.ExtendedMultirouteFlowAlgorithm' href='#LightGraphs.ExtendedMultirouteFlowAlgorithm'>#</a>
<strong><code>LightGraphs.ExtendedMultirouteFlowAlgorithm</code></strong> &mdash; <em>Type</em>.</p>
<pre><code>ExtendedMultirouteFlowAlgorithm
</code></pre>

<p>Used to specify the Extended Multiroute Flow algorithm.</p>
<p><a target='_blank' href='https://github.com/JuliaLang/julia/tree/82e96382251a1e163860df03c846acec86d07c36/base/docs/Docs.jl#L15-L19' class='documenter-source'>source</a><br></p>
<p><a id='LightGraphs.KishimotoAlgorithm' href='#LightGraphs.KishimotoAlgorithm'>#</a>
<strong><code>LightGraphs.KishimotoAlgorithm</code></strong> &mdash; <em>Type</em>.</p>
<pre><code>KishimotoAlgorithm
</code></pre>

<p>Used to specify the Kishimoto algorithm.</p>
<p><a target='_blank' href='https://github.com/JuliaLang/julia/tree/82e96382251a1e163860df03c846acec86d07c36/base/docs/Docs.jl#L8-L12' class='documenter-source'>source</a><br></p>
<p><a id='LightGraphs.PushRelabelAlgorithm' href='#LightGraphs.PushRelabelAlgorithm'>#</a>
<strong><code>LightGraphs.PushRelabelAlgorithm</code></strong> &mdash; <em>Type</em>.</p>
<p>Forces the maximum_flow function to use the Push-Relabel algorithm.</p>
<p><a target='_blank' href='https://github.com/JuliaLang/julia/tree/82e96382251a1e163860df03c846acec86d07c36/base/docs/Docs.jl#L29-L31' class='documenter-source'>source</a><br></p>
<p><a id='Base.SparseArrays.blkdiag-Union{Tuple{T,T}, Tuple{T}} where T<:LightGraphs.AbstractGraph' href='#Base.SparseArrays.blkdiag-Union{Tuple{T,T}, Tuple{T}} where T<:LightGraphs.AbstractGraph'>#</a>
<strong><code>Base.SparseArrays.blkdiag</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>blkdiag(g, h)
</code></pre>

<p>Return a graph with $|V(g)| + |V(h)|$ vertices and $|E(g)| + |E(h)|$ edges where the vertices an edges from graph <code>h</code> are appended to graph <code>g</code>.</p>
<p><strong>Implementation Notes</strong></p>
<p>Preserves the eltype of the input graph. Will error if the number of vertices in the generated graph exceeds the eltype.</p>
<p><a target='_blank' href='https://github.com/JuliaLang/julia/tree/82e96382251a1e163860df03c846acec86d07c36/base/docs/Docs.jl#L65' class='documenter-source'>source</a><br></p>
<p><a id='Base.intersect-Union{Tuple{T,T}, Tuple{T}} where T<:LightGraphs.AbstractGraph' href='#Base.intersect-Union{Tuple{T,T}, Tuple{T}} where T<:LightGraphs.AbstractGraph'>#</a>
<strong><code>Base.intersect</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>intersect(g, h)
</code></pre>

<p>Return a graph with edges that are only in both graph <code>g</code> and graph <code>h</code>.</p>
<p><strong>Implementation Notes</strong></p>
<p>This function may produce a graph with 0-degree vertices. Preserves the eltype of the input graph.</p>
<p><a target='_blank' href='https://github.com/JuliaLang/julia/tree/82e96382251a1e163860df03c846acec86d07c36/base/docs/Docs.jl#L87-L95' class='documenter-source'>source</a><br></p>
<p><a id='Base.join-Union{Tuple{T,T}, Tuple{T}} where T<:LightGraphs.AbstractGraph' href='#Base.join-Union{Tuple{T,T}, Tuple{T}} where T<:LightGraphs.AbstractGraph'>#</a>
<strong><code>Base.join</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>join(g, h)
</code></pre>

<p>Return a graph that combines graphs <code>g</code> and <code>h</code> using <code>blkdiag</code> and then adds all the edges between the vertices in <code>g</code> and those in <code>h</code>.</p>
<p><strong>Implementation Notes</strong></p>
<p>Preserves the eltype of the input graph. Will error if the number of vertices in the generated graph exceeds the eltype.</p>
<p><a target='_blank' href='https://github.com/JuliaLang/julia/tree/82e96382251a1e163860df03c846acec86d07c36/base/docs/Docs.jl#L181-L190' class='documenter-source'>source</a><br></p>
<p><a id='Base.reverse' href='#Base.reverse'>#</a>
<strong><code>Base.reverse</code></strong> &mdash; <em>Function</em>.</p>
<pre><code>reverse(g)
</code></pre>

<p>Return a directed graph where all edges are reversed from the original directed graph.</p>
<p><strong>Implementation Notes</strong></p>
<p>Preserves the eltype of the input graph.</p>
<p><a target='_blank' href='https://github.com/JuliaLang/julia/tree/82e96382251a1e163860df03c846acec86d07c36/base/docs/Docs.jl#L34-L42' class='documenter-source'>source</a><br></p>
<p><a id='Base.reverse!' href='#Base.reverse!'>#</a>
<strong><code>Base.reverse!</code></strong> &mdash; <em>Function</em>.</p>
<pre><code>reverse!(g)
</code></pre>

<p>In-place reverse of a directed graph (modifies the original graph).</p>
<p><a target='_blank' href='https://github.com/JuliaLang/julia/tree/82e96382251a1e163860df03c846acec86d07c36/base/docs/Docs.jl#L54-L58' class='documenter-source'>source</a><br></p>
<p><a id='Base.reverse-Tuple{LightGraphs.AbstractEdge}' href='#Base.reverse-Tuple{LightGraphs.AbstractEdge}'>#</a>
<strong><code>Base.reverse</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>reverse(e)
</code></pre>

<p>Create a new edge from <code>e</code> with source and destination vertices reversed.</p>
<p><a target='_blank' href='https://github.com/JuliaLang/julia/tree/82e96382251a1e163860df03c846acec86d07c36/base/docs/Docs.jl#L52-L56' class='documenter-source'>source</a><br></p>
<p><a id='Base.union-Union{Tuple{T,T}, Tuple{T}} where T<:LightGraphs.AbstractGraph' href='#Base.union-Union{Tuple{T,T}, Tuple{T}} where T<:LightGraphs.AbstractGraph'>#</a>
<strong><code>Base.union</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>union(g, h)
</code></pre>

<p>Return a graph that combines graphs <code>g</code> and <code>h</code> by taking the set union of all vertices and edges.</p>
<p><strong>Implementation Notes</strong></p>
<p>Preserves the eltype of the input graph. Will error if the number of vertices in the generated graph exceeds the eltype.</p>
<p><a target='_blank' href='https://github.com/JuliaLang/julia/tree/82e96382251a1e163860df03c846acec86d07c36/base/docs/Docs.jl#L152-L161' class='documenter-source'>source</a><br></p>
<p><a id='LightGraphs.BinaryTree-Tuple{Integer}' href='#LightGraphs.BinaryTree-Tuple{Integer}'>#</a>
<strong><code>LightGraphs.BinaryTree</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>BinaryTree(k::Integer)
</code></pre>

<p>Create a <a href="https://en.wikipedia.org/wiki/Binary_tree">binary tree</a> of depth <code>k</code>.</p>
<p><a target='_blank' href='https://github.com/JuliaLang/julia/tree/82e96382251a1e163860df03c846acec86d07c36/base/docs/Docs.jl#L197-L202' class='documenter-source'>source</a><br></p>
<p><a id='LightGraphs.BoundedMinkowskiCost-Tuple{AbstractArray{T,1} where T,AbstractArray{T,1} where T}' href='#LightGraphs.BoundedMinkowskiCost-Tuple{AbstractArray{T,1} where T,AbstractArray{T,1} where T}'>#</a>
<strong><code>LightGraphs.BoundedMinkowskiCost</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>BoundedMinkowskiCost(μ₁, μ₂)
</code></pre>

<p>Return value similar to <code>MinkowskiCost</code>, but ensure costs smaller than 2τ.</p>
<p><strong>Optional Arguments</strong></p>
<p><code>p=1</code>: the p value for p-norm calculation. <code>τ=1</code>: value specifying half of the upper limit of the Minkowski cost.</p>
<p><a target='_blank' href='https://github.com/JuliaLang/julia/tree/82e96382251a1e163860df03c846acec86d07c36/base/docs/Docs.jl#L125-L133' class='documenter-source'>source</a><br></p>
<p><a id='LightGraphs.CliqueGraph-Tuple{Integer,Integer}' href='#LightGraphs.CliqueGraph-Tuple{Integer,Integer}'>#</a>
<strong><code>LightGraphs.CliqueGraph</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>CliqueGraph(k, n)
</code></pre>

<p>Create a graph consisting of <code>n</code> connected <code>k</code>-cliques.</p>
<p><a target='_blank' href='https://github.com/JuliaLang/julia/tree/82e96382251a1e163860df03c846acec86d07c36/base/docs/Docs.jl#L252-L256' class='documenter-source'>source</a><br></p>
<p><a id='LightGraphs.CompleteBipartiteGraph-Tuple{Integer,Integer}' href='#LightGraphs.CompleteBipartiteGraph-Tuple{Integer,Integer}'>#</a>
<strong><code>LightGraphs.CompleteBipartiteGraph</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>CompleteBipartiteGraph(n1, n2)
</code></pre>

<p>Create an undirected <a href="https://en.wikipedia.org/wiki/Complete_bipartite_graph">complete bipartite graph</a> with <code>n1 + n2</code> vertices.</p>
<p><a target='_blank' href='https://github.com/JuliaLang/julia/tree/82e96382251a1e163860df03c846acec86d07c36/base/docs/Docs.jl#L21' class='documenter-source'>source</a><br></p>
<p><a id='LightGraphs.CompleteDiGraph-Tuple{Integer}' href='#LightGraphs.CompleteDiGraph-Tuple{Integer}'>#</a>
<strong><code>LightGraphs.CompleteDiGraph</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>CompleteDiGraph(n)
</code></pre>

<p>Create a directed <a href="https://en.wikipedia.org/wiki/Complete_graph">complete graph</a> with <code>n</code> vertices.</p>
<p><a target='_blank' href='https://github.com/JuliaLang/julia/tree/82e96382251a1e163860df03c846acec86d07c36/base/docs/Docs.jl#L35-L40' class='documenter-source'>source</a><br></p>
<p><a id='LightGraphs.CompleteGraph-Tuple{Integer}' href='#LightGraphs.CompleteGraph-Tuple{Integer}'>#</a>
<strong><code>LightGraphs.CompleteGraph</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>CompleteGraph(n)
</code></pre>

<p>Create an undirected <a href="https://en.wikipedia.org/wiki/Complete_graph">complete graph</a> with <code>n</code> vertices.</p>
<p><a target='_blank' href='https://github.com/JuliaLang/julia/tree/82e96382251a1e163860df03c846acec86d07c36/base/docs/Docs.jl#L4-L9' class='documenter-source'>source</a><br></p>
<p><a id='LightGraphs.CycleDiGraph-Tuple{Integer}' href='#LightGraphs.CycleDiGraph-Tuple{Integer}'>#</a>
<strong><code>LightGraphs.CycleDiGraph</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>CycleDiGraph(n)
</code></pre>

<p>Create a directed <a href="https://en.wikipedia.org/wiki/Cycle_graph">cycle graph</a> with <code>n</code> vertices.</p>
<p><a target='_blank' href='https://github.com/JuliaLang/julia/tree/82e96382251a1e163860df03c846acec86d07c36/base/docs/Docs.jl#L122-L127' class='documenter-source'>source</a><br></p>
<p><a id='LightGraphs.CycleGraph-Tuple{Integer}' href='#LightGraphs.CycleGraph-Tuple{Integer}'>#</a>
<strong><code>LightGraphs.CycleGraph</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>CycleGraph(n)
</code></pre>

<p>Create an undirected <a href="https://en.wikipedia.org/wiki/Cycle_graph">cycle graph</a> with <code>n</code> vertices.</p>
<p><a target='_blank' href='https://github.com/JuliaLang/julia/tree/82e96382251a1e163860df03c846acec86d07c36/base/docs/Docs.jl#L107-L112' class='documenter-source'>source</a><br></p>
<p><a id='LightGraphs.DoubleBinaryTree-Tuple{Integer}' href='#LightGraphs.DoubleBinaryTree-Tuple{Integer}'>#</a>
<strong><code>LightGraphs.DoubleBinaryTree</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>BinaryTree(k::Integer)
</code></pre>

<p>Create a double complete binary tree with <code>k</code> levels.</p>
<p><strong>References</strong></p>
<ul>
<li>Used as an example for spectral clustering by Guattery and Miller 1998.</li>
</ul>
<p><a target='_blank' href='https://github.com/JuliaLang/julia/tree/82e96382251a1e163860df03c846acec86d07c36/base/docs/Docs.jl#L215-L222' class='documenter-source'>source</a><br></p>
<p><a id='LightGraphs.Grid-Tuple{AbstractArray{T,1} where T}' href='#LightGraphs.Grid-Tuple{AbstractArray{T,1} where T}'>#</a>
<strong><code>LightGraphs.Grid</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>Grid(dims; periodic=false)
</code></pre>

<p>Create a $|dims|$-dimensional cubic lattice, with length <code>dims[i]</code> in dimension <code>i</code>.</p>
<p><strong>Optional Arguments</strong></p>
<ul>
<li><code>periodic=false</code>: If true, the resulting lattice will have periodic boundary</li>
</ul>
<p>condition in each dimension.</p>
<p><a target='_blank' href='https://github.com/JuliaLang/julia/tree/82e96382251a1e163860df03c846acec86d07c36/base/docs/Docs.jl#L172' class='documenter-source'>source</a><br></p>
<p><a id='LightGraphs.MinkowskiCost-Tuple{AbstractArray{T,1} where T,AbstractArray{T,1} where T}' href='#LightGraphs.MinkowskiCost-Tuple{AbstractArray{T,1} where T,AbstractArray{T,1} where T}'>#</a>
<strong><code>LightGraphs.MinkowskiCost</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>MinkowskiCost(μ₁, μ₂; p::Real=1)
</code></pre>

<p>For labels μ₁ on the vertices of graph G₁ and labels μ₂ on the vertices of graph G₂, compute the p-norm cost of substituting vertex u ∈ G₁ by vertex v ∈ G₂.</p>
<p><strong>Optional Arguments</strong></p>
<p><code>p=1</code>: the p value for p-norm calculation.</p>
<p><a target='_blank' href='https://github.com/JuliaLang/julia/tree/82e96382251a1e163860df03c846acec86d07c36/base/docs/Docs.jl#L111-L120' class='documenter-source'>source</a><br></p>
<p><a id='LightGraphs.PathDiGraph-Tuple{Integer}' href='#LightGraphs.PathDiGraph-Tuple{Integer}'>#</a>
<strong><code>LightGraphs.PathDiGraph</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>PathDiGraph(n)
</code></pre>

<p>Creates a directed <a href="https://en.wikipedia.org/wiki/Path_graph">path graph</a> with <code>n</code> vertices.</p>
<p><a target='_blank' href='https://github.com/JuliaLang/julia/tree/82e96382251a1e163860df03c846acec86d07c36/base/docs/Docs.jl#L93-L98' class='documenter-source'>source</a><br></p>
<p><a id='LightGraphs.PathGraph-Tuple{Integer}' href='#LightGraphs.PathGraph-Tuple{Integer}'>#</a>
<strong><code>LightGraphs.PathGraph</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>PathGraph(n)
</code></pre>

<p>Create an undirected <a href="https://en.wikipedia.org/wiki/Path_graph">path graph</a> with <code>n</code> vertices.</p>
<p><a target='_blank' href='https://github.com/JuliaLang/julia/tree/82e96382251a1e163860df03c846acec86d07c36/base/docs/Docs.jl#L79-L84' class='documenter-source'>source</a><br></p>
<p><a id='LightGraphs.RoachGraph-Tuple{Integer}' href='#LightGraphs.RoachGraph-Tuple{Integer}'>#</a>
<strong><code>LightGraphs.RoachGraph</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>RoachGraph(k)
</code></pre>

<p>Create a Roach Graph of size <code>k</code>.</p>
<p><strong>References</strong></p>
<ul>
<li>Guattery and Miller 1998</li>
</ul>
<p><a target='_blank' href='https://github.com/JuliaLang/julia/tree/82e96382251a1e163860df03c846acec86d07c36/base/docs/Docs.jl#L232-L239' class='documenter-source'>source</a><br></p>
<p><a id='LightGraphs.StarDiGraph-Tuple{Integer}' href='#LightGraphs.StarDiGraph-Tuple{Integer}'>#</a>
<strong><code>LightGraphs.StarDiGraph</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>StarDiGraph(n)
</code></pre>

<p>Create a directed <a href="https://en.wikipedia.org/wiki/Star_(graph_theory)">star graph</a> with <code>n</code> vertices.</p>
<p><a target='_blank' href='https://github.com/JuliaLang/julia/tree/82e96382251a1e163860df03c846acec86d07c36/base/docs/Docs.jl#L65-L70' class='documenter-source'>source</a><br></p>
<p><a id='LightGraphs.StarGraph-Tuple{Integer}' href='#LightGraphs.StarGraph-Tuple{Integer}'>#</a>
<strong><code>LightGraphs.StarGraph</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>StarGraph(n)
</code></pre>

<p>Create an undirected <a href="https://en.wikipedia.org/wiki/Star_(graph_theory)">star graph</a> with <code>n</code> vertices.</p>
<p><a target='_blank' href='https://github.com/JuliaLang/julia/tree/82e96382251a1e163860df03c846acec86d07c36/base/docs/Docs.jl#L51-L56' class='documenter-source'>source</a><br></p>
<p><a id='LightGraphs.WheelDiGraph-Tuple{Integer}' href='#LightGraphs.WheelDiGraph-Tuple{Integer}'>#</a>
<strong><code>LightGraphs.WheelDiGraph</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>WheelDiGraph(n)
</code></pre>

<p>Create a directed <a href="https://en.wikipedia.org/wiki/Wheel_graph">wheel graph</a> with <code>n</code> vertices.</p>
<p><a target='_blank' href='https://github.com/JuliaLang/julia/tree/82e96382251a1e163860df03c846acec86d07c36/base/docs/Docs.jl#L155-L160' class='documenter-source'>source</a><br></p>
<p><a id='LightGraphs.WheelGraph-Tuple{Integer}' href='#LightGraphs.WheelGraph-Tuple{Integer}'>#</a>
<strong><code>LightGraphs.WheelGraph</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>WheelGraph(n)
</code></pre>

<p>Create an undirected <a href="https://en.wikipedia.org/wiki/Wheel_graph">wheel graph</a> with <code>n</code> vertices.</p>
<p><a target='_blank' href='https://github.com/JuliaLang/julia/tree/82e96382251a1e163860df03c846acec86d07c36/base/docs/Docs.jl#L138-L143' class='documenter-source'>source</a><br></p>
<p><a id='LightGraphs.a_star-Union{Tuple{LightGraphs.AbstractGraph,Integer,Integer,AbstractArray{T,2},Function}, Tuple{LightGraphs.AbstractGraph,Integer,Integer,AbstractArray{T,2}}, Tuple{LightGraphs.AbstractGraph,Integer,Integer}, Tuple{T}} where T' href='#LightGraphs.a_star-Union{Tuple{LightGraphs.AbstractGraph,Integer,Integer,AbstractArray{T,2},Function}, Tuple{LightGraphs.AbstractGraph,Integer,Integer,AbstractArray{T,2}}, Tuple{LightGraphs.AbstractGraph,Integer,Integer}, Tuple{T}} where T'>#</a>
<strong><code>LightGraphs.a_star</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>a_star(g, s, t[, distmx][, heuristic])
</code></pre>

<p>Return a vector of edges comprising the shortest path between vertices <code>s</code> and <code>t</code> using the <a href="http://en.wikipedia.org/wiki/A%2A_search_algorithm">A* search algorithm</a>. An optional heuristic function and edge distance matrix may be supplied. If missing, the distance matrix is set to <a href="../@ref"><code>DefaultDistance</code></a> and the heuristic is set to <code>n -&gt; 0</code>.</p>
<p><a target='_blank' href='https://github.com/JuliaLang/julia/tree/82e96382251a1e163860df03c846acec86d07c36/base/docs/Docs.jl#L38-L46' class='documenter-source'>source</a><br></p>
<p><a id='LightGraphs.add_edge!-Tuple' href='#LightGraphs.add_edge!-Tuple'>#</a>
<strong><code>LightGraphs.add_edge!</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>add_edge!(g, e)
</code></pre>

<p>Add a new edge <code>e</code> to <code>g</code>. Return false if add fails (e.g., if vertices are not in the graph, or edge already exists), true otherwise.</p>
<p><a target='_blank' href='https://github.com/JuliaLang/julia/tree/82e96382251a1e163860df03c846acec86d07c36/base/docs/Docs.jl#L125-L130' class='documenter-source'>source</a><br></p>
<p><a id='LightGraphs.add_vertex!-Tuple' href='#LightGraphs.add_vertex!-Tuple'>#</a>
<strong><code>LightGraphs.add_vertex!</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>add_vertex!(g)
</code></pre>

<p>Add a new vertex to the graph <code>g</code>. Return true if the vertex was added successfully, false otherwise.</p>
<p><a target='_blank' href='https://github.com/JuliaLang/julia/tree/82e96382251a1e163860df03c846acec86d07c36/base/docs/Docs.jl#L117-L122' class='documenter-source'>source</a><br></p>
<p><a id='LightGraphs.add_vertices!-Tuple{LightGraphs.AbstractGraph,Integer}' href='#LightGraphs.add_vertices!-Tuple{LightGraphs.AbstractGraph,Integer}'>#</a>
<strong><code>LightGraphs.add_vertices!</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>add_vertices!(g, n)
</code></pre>

<p>Add <code>n</code> new vertices to the graph <code>g</code>. Return <code>true</code> if all vertices were added successfully, <code>false</code> otherwise.</p>
<p><a target='_blank' href='https://github.com/JuliaLang/julia/tree/82e96382251a1e163860df03c846acec86d07c36/base/docs/Docs.jl#L13-L17' class='documenter-source'>source</a><br></p>
<p><a id='LightGraphs.adjacency_matrix' href='#LightGraphs.adjacency_matrix'>#</a>
<strong><code>LightGraphs.adjacency_matrix</code></strong> &mdash; <em>Function</em>.</p>
<pre><code>adjacency_matrix(g, dir=:out, T=Int)
</code></pre>

<p>Return a sparse adjacency matrix for a graph, indexed by <code>[u, v]</code> vertices. Non-zero values indicate an edge between <code>u</code> and <code>v</code>. Users may specify a direction (<code>:in</code>, <code>:out</code>, or <code>:both</code> are currently supported; <code>:out</code> is default for both directed and undirected graphs) and a data type for the matrix (defaults to <code>Int</code>).</p>
<p><strong>Implementation Notes</strong></p>
<p>This function is optimized for speed and directly manipulates CSC sparse matrix fields.</p>
<p><a target='_blank' href='https://github.com/JuliaLang/julia/tree/82e96382251a1e163860df03c846acec86d07c36/base/docs/Docs.jl#L9-L20' class='documenter-source'>source</a><br></p>
<p><a id='LightGraphs.adjacency_spectrum' href='#LightGraphs.adjacency_spectrum'>#</a>
<strong><code>LightGraphs.adjacency_spectrum</code></strong> &mdash; <em>Function</em>.</p>
<p>Return the eigenvalues of the adjacency matrix for a graph <code>g</code>, indexed by vertex. Default values for <code>dir</code> and <code>T</code> are the same as those in <a href="./#LightGraphs.adjacency_matrix"><code>adjacency_matrix</code></a>.</p>
<p><strong>Performance</strong></p>
<p>Converts the matrix to dense with $nv^2$ memory usage.</p>
<p><strong>Implementation Notes</strong></p>
<p>Use <code>eigs(adjacency_matrix(g);  kwargs...)</code> to compute some of the eigenvalues/eigenvectors.</p>
<p><a target='_blank' href='https://github.com/JuliaLang/julia/tree/82e96382251a1e163860df03c846acec86d07c36/base/docs/Docs.jl#L103' class='documenter-source'>source</a><br></p>
<p><a id='LightGraphs.all_neighbors' href='#LightGraphs.all_neighbors'>#</a>
<strong><code>LightGraphs.all_neighbors</code></strong> &mdash; <em>Function</em>.</p>
<pre><code>all_neighbors(g, v)
</code></pre>

<p>Return a list of all inbound and outbound neighbors of <code>v</code> in <code>g</code>. For undirected graphs, this is equivalent to both <a href="./#LightGraphs.out_neighbors-Tuple"><code>out_neighbors</code></a> and <a href="./#LightGraphs.in_neighbors-Tuple"><code>in_neighbors</code></a>.</p>
<p><strong>Implementation Notes</strong></p>
<p>Returns a reference, not a copy. Do not modify result.</p>
<p><a target='_blank' href='https://github.com/JuliaLang/julia/tree/82e96382251a1e163860df03c846acec86d07c36/base/docs/Docs.jl#L139-L147' class='documenter-source'>source</a><br></p>
<p><a id='LightGraphs.articulation-Tuple{LightGraphs.AbstractGraph}' href='#LightGraphs.articulation-Tuple{LightGraphs.AbstractGraph}'>#</a>
<strong><code>LightGraphs.articulation</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>articulation(g)
</code></pre>

<p>Compute the <a href="https://en.wikipedia.org/wiki/Biconnected_component">articulation points</a> of a connected graph <code>g</code> and return an array containing all cut vertices.</p>
<p><a target='_blank' href='https://github.com/JuliaLang/julia/tree/82e96382251a1e163860df03c846acec86d07c36/base/docs/Docs.jl#L51-L56' class='documenter-source'>source</a><br></p>
<p><a id='LightGraphs.barabasi_albert!-Tuple{LightGraphs.AbstractGraph,Integer,Integer}' href='#LightGraphs.barabasi_albert!-Tuple{LightGraphs.AbstractGraph,Integer,Integer}'>#</a>
<strong><code>LightGraphs.barabasi_albert!</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>barabasi_albert!(g::AbstractGraph, n::Integer, k::Integer)
</code></pre>

<p>Create a <a href="https://en.wikipedia.org/wiki/Barab%C3%A1si%E2%80%93Albert_model">Barabási–Albert model</a> random graph with <code>n</code> vertices. It is grown by adding new vertices to an initial graph <code>g</code>. Each new vertex is attached with <code>k</code> edges to <code>k</code> different vertices already present in the system by preferential attachment.</p>
<p><strong>Optional Arguments</strong></p>
<ul>
<li><code>seed=-1</code>: set the RNG seed.</li>
</ul>
<p><a target='_blank' href='https://github.com/JuliaLang/julia/tree/82e96382251a1e163860df03c846acec86d07c36/base/docs/Docs.jl#L226-L236' class='documenter-source'>source</a><br></p>
<p><a id='LightGraphs.barabasi_albert-Tuple{Integer,Integer,Integer}' href='#LightGraphs.barabasi_albert-Tuple{Integer,Integer,Integer}'>#</a>
<strong><code>LightGraphs.barabasi_albert</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>barabasi_albert(n::Integer, n0::Integer, k::Integer)
</code></pre>

<p>Create a <a href="https://en.wikipedia.org/wiki/Barab%C3%A1si%E2%80%93Albert_model">Barabási–Albert model</a> random graph with <code>n</code> vertices. It is grown by adding new vertices to an initial graph with <code>n0</code> vertices. Each new vertex is attached with <code>k</code> edges to <code>k</code> different vertices already present in the system by preferential attachment. Initial graphs are undirected and consist of isolated vertices by default.</p>
<p><strong>Optional Arguments</strong></p>
<ul>
<li><code>is_directed=false</code>: if true, return a directed graph.</li>
<li><code>complete=false</code>: if true, use a complete graph for the initial graph.</li>
<li><code>seed=-1</code>: set the RNG seed.</li>
</ul>
<p><a target='_blank' href='https://github.com/JuliaLang/julia/tree/82e96382251a1e163860df03c846acec86d07c36/base/docs/Docs.jl#L201-L214' class='documenter-source'>source</a><br></p>
<p><a id='LightGraphs.barabasi_albert-Tuple{Integer,Integer}' href='#LightGraphs.barabasi_albert-Tuple{Integer,Integer}'>#</a>
<strong><code>LightGraphs.barabasi_albert</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>barabasi_albert(n, k)
</code></pre>

<p>Create a <a href="https://en.wikipedia.org/wiki/Barab%C3%A1si%E2%80%93Albert_model">Barabási–Albert model</a> random graph with <code>n</code> vertices. It is grown by adding new vertices to an initial graph with <code>k</code> vertices. Each new vertex is attached with <code>k</code> edges to <code>k</code> different vertices already present in the system by preferential attachment. Initial graphs are undirected and consist of isolated vertices by default.</p>
<p><strong>Optional Arguments</strong></p>
<ul>
<li><code>is_directed=false</code>: if true, return a directed graph.</li>
<li><code>complete=false</code>: if true, use a complete graph for the initial graph.</li>
<li><code>seed=-1</code>: set the RNG seed.</li>
</ul>
<p><a target='_blank' href='https://github.com/JuliaLang/julia/tree/82e96382251a1e163860df03c846acec86d07c36/base/docs/Docs.jl#L184-L197' class='documenter-source'>source</a><br></p>
<p><a id='LightGraphs.bellman_ford_shortest_paths-Union{Tuple{LightGraphs.AbstractGraph,AbstractArray{U,1},AbstractArray{T,2}}, Tuple{LightGraphs.AbstractGraph,AbstractArray{U,1}}, Tuple{T}, Tuple{U}} where T where U<:Integer' href='#LightGraphs.bellman_ford_shortest_paths-Union{Tuple{LightGraphs.AbstractGraph,AbstractArray{U,1},AbstractArray{T,2}}, Tuple{LightGraphs.AbstractGraph,AbstractArray{U,1}}, Tuple{T}, Tuple{U}} where T where U<:Integer'>#</a>
<strong><code>LightGraphs.bellman_ford_shortest_paths</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>bellman_ford_shortest_paths(g, s, distmx=DefaultDistance())
bellman_ford_shortest_paths(g, ss, distmx=DefaultDistance())
</code></pre>

<p>Compute shortest paths between a source <code>s</code> (or list of sources <code>ss</code>) and all other nodes in graph <code>g</code> using the <a href="http://en.wikipedia.org/wiki/Bellman–Ford_algorithm">Bellman-Ford algorithm</a>. Return a <a href="./#LightGraphs.BellmanFordState"><code>BellmanFordState</code></a> with relevant traversal information.</p>
<p><a target='_blank' href='https://github.com/JuliaLang/julia/tree/82e96382251a1e163860df03c846acec86d07c36/base/docs/Docs.jl#L62-L69' class='documenter-source'>source</a><br></p>
<p><a id='LightGraphs.betweenness_centrality' href='#LightGraphs.betweenness_centrality'>#</a>
<strong><code>LightGraphs.betweenness_centrality</code></strong> &mdash; <em>Function</em>.</p>
<pre><code>betweenness_centrality(g[, vs])
betweenness_centrality(g, k)
</code></pre>

<p>Calculate the <a href="https://en.wikipedia.org/wiki/Centrality#Betweenness_centrality">betweenness centrality</a> of a graph <code>g</code> across all vertices, a specified subset of vertices <code>vs</code>, or a random subset of <code>k</code> vertices. Return a vector representing the centrality calculated for each node in <code>g</code>.</p>
<p><strong>Optional Arguments</strong></p>
<ul>
<li><code>normalize=true</code>: If true, normalize the betweenness values by the</li>
</ul>
<p>total number of possible distinct paths between all pairsin the graphs. For an undirected graph, this number is $\frac{(|V|-1)(|V|-2)}{2}$ and for a directed graph, ${(|V|-1)(|V|-2)}$.</p>
<ul>
<li><code>endpoints=false</code>: If true, include endpoints in the shortest path count.</li>
</ul>
<p>Betweenness centrality is defined as: $bc(v) = \frac{1}{\mathcal{N}} sum_{s \neq t \neq v} \frac{\sigma_{st}(v)}{\sigma_{st}}$.</p>
<p><strong>References</strong></p>
<ul>
<li>Brandes 2001 &amp; Brandes 2008</li>
</ul>
<p><a target='_blank' href='https://github.com/JuliaLang/julia/tree/82e96382251a1e163860df03c846acec86d07c36/base/docs/Docs.jl#L5' class='documenter-source'>source</a><br></p>
<p><a id='LightGraphs.bfs_tree-Tuple{LightGraphs.AbstractGraph,Integer}' href='#LightGraphs.bfs_tree-Tuple{LightGraphs.AbstractGraph,Integer}'>#</a>
<strong><code>LightGraphs.bfs_tree</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>bfs_tree(g, s)
</code></pre>

<p>Provide a breadth-first traversal of the graph <code>g</code> starting with source vertex <code>s</code>, and return a directed acyclic graph of vertices in the order they were discovered.</p>
<p><strong>Implementation Notes</strong></p>
<p>This function is a high level wrapper around <a href="./#LightGraphs.bfs_tree!-Union{Tuple{LightGraphs.LevelSynchronousBFS,LightGraphs.ThreadQueue,LightGraphs.AbstractGraph,T,Array{Base.Threads.Atomic{T},N} where N}, Tuple{T}} where T&lt;:Integer"><code>bfs_tree!</code></a>; use that function for more performance.</p>
<p><a target='_blank' href='https://github.com/JuliaLang/julia/tree/82e96382251a1e163860df03c846acec86d07c36/base/docs/Docs.jl#L148-L156' class='documenter-source'>source</a><br></p>
<p><a id='LightGraphs.bfs_tree-Union{Tuple{LightGraphs.LevelSynchronousBFS,LightGraphs.AbstractGraph,T,T}, Tuple{T}} where T<:Integer' href='#LightGraphs.bfs_tree-Union{Tuple{LightGraphs.LevelSynchronousBFS,LightGraphs.AbstractGraph,T,T}, Tuple{T}} where T<:Integer'>#</a>
<strong><code>LightGraphs.bfs_tree</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>bfs_tree(LevelSynchronousBFS(), g, s, nv)
</code></pre>

<p>Provide a parallel breadth-first traversal of the graph <code>g</code> starting with source vertex <code>s</code>, and return a directed acyclic graph of vertices in the order they were discovered using a frontier based parallel approach.</p>
<p><strong>Implementation Notes</strong></p>
<p>This function uses <code>@threads</code> for parallelism which depends on the <code>JULIA_NUM_THREADS</code> environment variable to decide the number of threads to use. Refer <code>@threads</code> documentation for more details. This function is a high level wrapper around <a href="./#LightGraphs.bfs_tree!-Union{Tuple{LightGraphs.LevelSynchronousBFS,LightGraphs.ThreadQueue,LightGraphs.AbstractGraph,T,Array{Base.Threads.Atomic{T},N} where N}, Tuple{T}} where T&lt;:Integer"><code>bfs_tree!</code></a>; use that function for more performance.</p>
<p><a target='_blank' href='https://github.com/JuliaLang/julia/tree/82e96382251a1e163860df03c846acec86d07c36/base/docs/Docs.jl#L106-L118' class='documenter-source'>source</a><br></p>
<p><a id='LightGraphs.biconnected_components' href='#LightGraphs.biconnected_components'>#</a>
<strong><code>LightGraphs.biconnected_components</code></strong> &mdash; <em>Function</em>.</p>
<pre><code>biconnected_components(g)
</code></pre>

<p>Compute the <a href="https://en.wikipedia.org/wiki/Biconnected_component">biconnected components</a> of an undirected graph <code>g</code>and return a vector of vectors containing each biconnected component.</p>
<p>Performance: Time complexity is $\mathcal{O}(|V|)$.</p>
<p><a target='_blank' href='https://github.com/JuliaLang/julia/tree/82e96382251a1e163860df03c846acec86d07c36/base/docs/Docs.jl#L56' class='documenter-source'>source</a><br></p>
<p><a id='LightGraphs.bipartite_map-Tuple{LightGraphs.AbstractGraph}' href='#LightGraphs.bipartite_map-Tuple{LightGraphs.AbstractGraph}'>#</a>
<strong><code>LightGraphs.bipartite_map</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>bipartite_map(g)
</code></pre>

<p>For a bipartite graph <code>g</code>, return a vector <code>c</code> of size $|V|$ containing the assignment of each vertex to one of the two sets ($c_i == 1$ or c_i == 2<code>`). If</code>g` is not bipartite, return an empty vector.</p>
<p><a target='_blank' href='https://github.com/JuliaLang/julia/tree/82e96382251a1e163860df03c846acec86d07c36/base/docs/Docs.jl#L242' class='documenter-source'>source</a><br></p>
<p><a id='LightGraphs.blockcounts-Tuple{LightGraphs.StochasticBlockModel,AbstractArray{T,2} where T}' href='#LightGraphs.blockcounts-Tuple{LightGraphs.StochasticBlockModel,AbstractArray{T,2} where T}'>#</a>
<strong><code>LightGraphs.blockcounts</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>blockcounts(sbm, A)
</code></pre>

<p>Count the number of edges that go between each block.</p>
<p><a target='_blank' href='https://github.com/JuliaLang/julia/tree/82e96382251a1e163860df03c846acec86d07c36/base/docs/Docs.jl#L820-L824' class='documenter-source'>source</a><br></p>
<p><a id='LightGraphs.cartesian_product-Union{Tuple{G,G}, Tuple{G}} where G<:LightGraphs.AbstractGraph' href='#LightGraphs.cartesian_product-Union{Tuple{G,G}, Tuple{G}} where G<:LightGraphs.AbstractGraph'>#</a>
<strong><code>LightGraphs.cartesian_product</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>cartesian_product(g, h)
</code></pre>

<p>Return the (cartesian product)[https://en.wikipedia.org/wiki/Tensor_product_of_graphs] of <code>g</code> and <code>h</code>.</p>
<p><strong>Implementation Notes</strong></p>
<p>Preserves the eltype of the input graph. Will error if the number of vertices in the generated graph exceeds the eltype.</p>
<p><a target='_blank' href='https://github.com/JuliaLang/julia/tree/82e96382251a1e163860df03c846acec86d07c36/base/docs/Docs.jl#L287-L296' class='documenter-source'>source</a><br></p>
<p><a id='LightGraphs.center-Tuple{Array{T,1} where T}' href='#LightGraphs.center-Tuple{Array{T,1} where T}'>#</a>
<strong><code>LightGraphs.center</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>center(g, distmx=DefaultDistance())
center(eccentricities)
</code></pre>

<p>Given a graph and optional distance matrix, or a vector of precomputed eccentricities, return the set of all vertices whose eccentricity is equal to the graph's radius (that is, the set of vertices with the smallest eccentricity).</p>
<p><a target='_blank' href='https://github.com/JuliaLang/julia/tree/82e96382251a1e163860df03c846acec86d07c36/base/docs/Docs.jl#L98-L105' class='documenter-source'>source</a><br></p>
<p><a id='LightGraphs.closeness_centrality-Tuple{LightGraphs.AbstractGraph}' href='#LightGraphs.closeness_centrality-Tuple{LightGraphs.AbstractGraph}'>#</a>
<strong><code>LightGraphs.closeness_centrality</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>closeness_centrality(g)
</code></pre>

<p>Calculate the <a href="https://en.wikipedia.org/wiki/Centrality#Closeness_centrality">closeness centrality</a> of the graph <code>g</code>. Return a vector representing the centrality calculated for each node in <code>g</code>.</p>
<p><strong>Optional Arguments</strong></p>
<ul>
<li><code>normalize=true</code>: If true, normalize the centrality value of each</li>
</ul>
<p>node <code>n</code> by $\frac{|δ_n|}{|V|-1}$, where $δ_n$ is the set of vertices reachable from node <code>n</code>.</p>
<p><a target='_blank' href='https://github.com/JuliaLang/julia/tree/82e96382251a1e163860df03c846acec86d07c36/base/docs/Docs.jl#L1' class='documenter-source'>source</a><br></p>
<p><a id='LightGraphs.common_neighbors-Tuple{LightGraphs.AbstractGraph,Integer,Integer}' href='#LightGraphs.common_neighbors-Tuple{LightGraphs.AbstractGraph,Integer,Integer}'>#</a>
<strong><code>LightGraphs.common_neighbors</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>common_neighbors(g, u, v)
</code></pre>

<p>Return the neighbors common to vertices <code>u</code> and <code>v</code> in <code>g</code>.</p>
<p><strong>Implementation Notes</strong></p>
<p>Returns a reference, not a copy. Do not modify result.</p>
<p><a target='_blank' href='https://github.com/JuliaLang/julia/tree/82e96382251a1e163860df03c846acec86d07c36/base/docs/Docs.jl#L155-L162' class='documenter-source'>source</a><br></p>
<p><a id='LightGraphs.complement-Tuple{LightGraphs.SimpleGraphs.SimpleGraph}' href='#LightGraphs.complement-Tuple{LightGraphs.SimpleGraphs.SimpleGraph}'>#</a>
<strong><code>LightGraphs.complement</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>complement(g)
</code></pre>

<p>Return the <a href="https://en.wikipedia.org/wiki/Complement_graph">graph complement</a> of a graph</p>
<p><strong>Implementation Notes</strong></p>
<p>Preserves the eltype of the input graph.</p>
<p><a target='_blank' href='https://github.com/JuliaLang/julia/tree/82e96382251a1e163860df03c846acec86d07c36/base/docs/Docs.jl#L1-L9' class='documenter-source'>source</a><br></p>
<p><a id='LightGraphs.contract!-Tuple{Array{T,1} where T,LightGraphs.Nonbacktracking,Array{T,1} where T}' href='#LightGraphs.contract!-Tuple{Array{T,1} where T,LightGraphs.Nonbacktracking,Array{T,1} where T}'>#</a>
<strong><code>LightGraphs.contract!</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>contract!(vertexspace, nbt, edgespace)
</code></pre>

<p>The mutating version of <code>contract(nbt, edgespace)</code>. Modifies <code>vertexspace</code>.</p>
<p><a target='_blank' href='https://github.com/JuliaLang/julia/tree/82e96382251a1e163860df03c846acec86d07c36/base/docs/Docs.jl#L143-L147' class='documenter-source'>source</a><br></p>
<p><a id='LightGraphs.contract-Tuple{LightGraphs.Nonbacktracking,Array{T,1} where T}' href='#LightGraphs.contract-Tuple{LightGraphs.Nonbacktracking,Array{T,1} where T}'>#</a>
<strong><code>LightGraphs.contract</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>contract(nbt, edgespace)
</code></pre>

<p>Integrate out the edges by summing over the edges incident to each vertex.</p>
<p><a target='_blank' href='https://github.com/JuliaLang/julia/tree/82e96382251a1e163860df03c846acec86d07c36/base/docs/Docs.jl#L157-L161' class='documenter-source'>source</a><br></p>
<p><a id='LightGraphs.core_periphery_deg' href='#LightGraphs.core_periphery_deg'>#</a>
<strong><code>LightGraphs.core_periphery_deg</code></strong> &mdash; <em>Function</em>.</p>
<pre><code>core_periphery_deg(g)
</code></pre>

<p>Compute the degree-based core-periphery for graph <code>g</code>. Return the vertex assignments (<code>1</code> for core and <code>2</code> for periphery) for each node in <code>g</code>.</p>
<p>References:     <a href="http://arxiv.org/abs/1102.5511">Lip</a>)</p>
<p><a target='_blank' href='https://github.com/JuliaLang/julia/tree/82e96382251a1e163860df03c846acec86d07c36/base/docs/Docs.jl#L1-L9' class='documenter-source'>source</a><br></p>
<p><a id='LightGraphs.crosspath' href='#LightGraphs.crosspath'>#</a>
<strong><code>LightGraphs.crosspath</code></strong> &mdash; <em>Function</em>.</p>
<pre><code>crosspath(len::Integer, g::Graph)
</code></pre>

<p>Return a graph that duplicates <code>g</code> <code>len</code> times and connects each vertex with its copies in a path.</p>
<p><strong>Implementation Notes</strong></p>
<p>Preserves the eltype of the input graph. Will error if the number of vertices in the generated graph exceeds the eltype.</p>
<p><a target='_blank' href='https://github.com/JuliaLang/julia/tree/82e96382251a1e163860df03c846acec86d07c36/base/docs/Docs.jl#L202-L211' class='documenter-source'>source</a><br></p>
<p><a id='LightGraphs.degree' href='#LightGraphs.degree'>#</a>
<strong><code>LightGraphs.degree</code></strong> &mdash; <em>Function</em>.</p>
<pre><code>degree(g[, v])
</code></pre>

<p>Return a vector corresponding to the number of edges which start or end at each vertex in graph <code>g</code>. If <code>v</code> is specified, only return degrees for vertices in <code>v</code>. For directed graphs, this value equals the incoming plus outgoing edges. For undirected graphs, it equals the connected edges.</p>
<p><a target='_blank' href='https://github.com/JuliaLang/julia/tree/82e96382251a1e163860df03c846acec86d07c36/base/docs/Docs.jl#L38-L44' class='documenter-source'>source</a><br></p>
<p><a id='LightGraphs.degree_centrality-Tuple{LightGraphs.AbstractGraph}' href='#LightGraphs.degree_centrality-Tuple{LightGraphs.AbstractGraph}'>#</a>
<strong><code>LightGraphs.degree_centrality</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>degree_centrality(g)
indegree_centrality(g)
outdegree_centrality(g)
</code></pre>

<p>Calculate the <a href="https://en.wikipedia.org/wiki/Centrality#Degree_centrality">degree centrality</a> of graph <code>g</code>. Return a vector representing the centrality calculated for each node in <code>g</code>.</p>
<p><strong>Optional Arguments</strong></p>
<ul>
<li><code>normalize=true</code>: If true, normalize each centrality measure by $\frac{1}{|V|-1}$.</li>
</ul>
<p><a target='_blank' href='https://github.com/JuliaLang/julia/tree/82e96382251a1e163860df03c846acec86d07c36/base/docs/Docs.jl#L18-L28' class='documenter-source'>source</a><br></p>
<p><a id='LightGraphs.degree_histogram' href='#LightGraphs.degree_histogram'>#</a>
<strong><code>LightGraphs.degree_histogram</code></strong> &mdash; <em>Function</em>.</p>
<pre><code>degree_histogram(g, degfn=degree)
</code></pre>

<p>Return a Dict with values representing the number of vertices that have degree represented by the key.</p>
<p>Degree function (for example, <code>indegree</code> or <code>outdegree</code>) may be specified by overriding <code>degfn</code>.</p>
<p><a target='_blank' href='https://github.com/JuliaLang/julia/tree/82e96382251a1e163860df03c846acec86d07c36/base/docs/Docs.jl#L107-L115' class='documenter-source'>source</a><br></p>
<p><a id='LightGraphs.density' href='#LightGraphs.density'>#</a>
<strong><code>LightGraphs.density</code></strong> &mdash; <em>Function</em>.</p>
<pre><code>density(g)
</code></pre>

<p>Return the density of <code>g</code>. Density is defined as the ratio of the number of actual edges to the number of possible edges ($|V|×(|V|-1)$ for directed graphs and $\frac{|V|×(|V|-1)}{2}$ for undirected graphs).</p>
<p><a target='_blank' href='https://github.com/JuliaLang/julia/tree/82e96382251a1e163860df03c846acec86d07c36/base/docs/Docs.jl#L180' class='documenter-source'>source</a><br></p>
<p><a id='LightGraphs.dfs_tree-Tuple{LightGraphs.AbstractGraph,Integer}' href='#LightGraphs.dfs_tree-Tuple{LightGraphs.AbstractGraph,Integer}'>#</a>
<strong><code>LightGraphs.dfs_tree</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>dfs_tree(g, s)
</code></pre>

<p>Return an ordered vector of vertices representing a directed acylic graph based on depth-first traversal of the graph <code>g</code> starting with source vertex <code>s</code>.</p>
<p><a target='_blank' href='https://github.com/JuliaLang/julia/tree/82e96382251a1e163860df03c846acec86d07c36/base/docs/Docs.jl#L186-L191' class='documenter-source'>source</a><br></p>
<p><a id='LightGraphs.diameter-Tuple{Array{T,1} where T}' href='#LightGraphs.diameter-Tuple{Array{T,1} where T}'>#</a>
<strong><code>LightGraphs.diameter</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>diameter(g, distmx=DefaultDistance())
diameter(eccentricities)
</code></pre>

<p>Given a graph and optional distance matrix, or a vector of precomputed eccentricities, return the maximum eccentricity of the graph.</p>
<p><a target='_blank' href='https://github.com/JuliaLang/julia/tree/82e96382251a1e163860df03c846acec86d07c36/base/docs/Docs.jl#L59-L65' class='documenter-source'>source</a><br></p>
<p><a id='LightGraphs.difference-Union{Tuple{T,T}, Tuple{T}} where T<:LightGraphs.AbstractGraph' href='#LightGraphs.difference-Union{Tuple{T,T}, Tuple{T}} where T<:LightGraphs.AbstractGraph'>#</a>
<strong><code>LightGraphs.difference</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>difference(g, h)
</code></pre>

<p>Return a graph with edges in graph <code>g</code> that are not in graph <code>h</code>.</p>
<p><strong>Implementation Notes</strong></p>
<p>Note that this function may produce a graph with 0-degree vertices. Preserves the eltype of the input graph.</p>
<p><a target='_blank' href='https://github.com/JuliaLang/julia/tree/82e96382251a1e163860df03c846acec86d07c36/base/docs/Docs.jl#L107-L115' class='documenter-source'>source</a><br></p>
<p><a id='LightGraphs.dijkstra_shortest_paths-Union{Tuple{LightGraphs.AbstractGraph,Array{U,1},AbstractArray{T,2}}, Tuple{LightGraphs.AbstractGraph,Array{U,1}}, Tuple{T}, Tuple{U}} where T where U<:Integer' href='#LightGraphs.dijkstra_shortest_paths-Union{Tuple{LightGraphs.AbstractGraph,Array{U,1},AbstractArray{T,2}}, Tuple{LightGraphs.AbstractGraph,Array{U,1}}, Tuple{T}, Tuple{U}} where T where U<:Integer'>#</a>
<strong><code>LightGraphs.dijkstra_shortest_paths</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>dijkstra_shortest_paths(g, srcs, distmx=DefaultDistance());
</code></pre>

<p>Perform <a href="http://en.wikipedia.org/wiki/Dijkstra%27s_algorithm">Dijkstra's algorithm</a> on a graph, computing shortest distances between <code>srcs</code> and all other vertices. Return a <a href="./#LightGraphs.DijkstraState"><code>DijkstraState</code></a> that contains various traversal information.</p>
<p><strong>Optional Arguments</strong></p>
<ul>
<li><code>allpaths=false</code>: If true, returns a <a href="./#LightGraphs.DijkstraState"><code>DijkstraState</code></a> that keeps track of all</li>
</ul>
<p>predecessors of a given vertex.</p>
<p><a target='_blank' href='https://github.com/JuliaLang/julia/tree/82e96382251a1e163860df03c846acec86d07c36/base/docs/Docs.jl#L21-L31' class='documenter-source'>source</a><br></p>
<p><a id='LightGraphs.dst-Tuple{LightGraphs.AbstractEdge}' href='#LightGraphs.dst-Tuple{LightGraphs.AbstractEdge}'>#</a>
<strong><code>LightGraphs.dst</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>dst(e)
</code></pre>

<p>Return the destination vertex of edge <code>e</code>.</p>
<p><a target='_blank' href='https://github.com/JuliaLang/julia/tree/82e96382251a1e163860df03c846acec86d07c36/base/docs/Docs.jl#L42-L46' class='documenter-source'>source</a><br></p>
<p><a id='LightGraphs.eccentricity-Union{Tuple{LightGraphs.AbstractGraph,Integer,AbstractArray{T,2}}, Tuple{LightGraphs.AbstractGraph,Integer}, Tuple{T}} where T' href='#LightGraphs.eccentricity-Union{Tuple{LightGraphs.AbstractGraph,Integer,AbstractArray{T,2}}, Tuple{LightGraphs.AbstractGraph,Integer}, Tuple{T}} where T'>#</a>
<strong><code>LightGraphs.eccentricity</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>eccentricity(g[, v][, distmx])
</code></pre>

<p>Return the eccentricity[ies] of a vertex / vertex list <code>v</code> or the entire graph. An optional matrix of edge distances may be supplied; if missing, edge distances default to <code>1</code>.</p>
<p>The eccentricity of a vertex is the maximum shortest-path distance between it and all other vertices in the graph.</p>
<p>The output is either a single float (when a single vertex is provided) or a vector of floats corresponding to the vertex vector. If no vertex vector is provided, the vector returned corresponds to each vertex in the graph.</p>
<p><strong>Performance</strong></p>
<p>Because this function must calculate shortest paths for all vertices supplied in the argument list, it may take a long time.</p>
<p><strong>Implementation Notes</strong></p>
<p>The eccentricity vector returned by <code>eccentricity()</code> may be used as input for the rest of the distance measures below. If an eccentricity vector is provided, it will be used. Otherwise, an eccentricity vector will be calculated for each call to the function. It may therefore be more efficient to calculate, store, and pass the eccentricities if multiple distance measures are desired.</p>
<p><a target='_blank' href='https://github.com/JuliaLang/julia/tree/82e96382251a1e163860df03c846acec86d07c36/base/docs/Docs.jl#L14-L38' class='documenter-source'>source</a><br></p>
<p><a id='LightGraphs.edges-Tuple' href='#LightGraphs.edges-Tuple'>#</a>
<strong><code>LightGraphs.edges</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>edges(g)
</code></pre>

<p>Return (an iterator to or collection of) the edges of a graph.</p>
<p><strong>Implementation Notes</strong></p>
<p>A returned iterator is valid for one pass over the edges, and is invalidated by changes to <code>g</code>.</p>
<p><a target='_blank' href='https://github.com/JuliaLang/julia/tree/82e96382251a1e163860df03c846acec86d07c36/base/docs/Docs.jl#L105-L112' class='documenter-source'>source</a><br></p>
<p><a id='LightGraphs.edgetype-Tuple{LightGraphs.AbstractGraph}' href='#LightGraphs.edgetype-Tuple{LightGraphs.AbstractGraph}'>#</a>
<strong><code>LightGraphs.edgetype</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>edgetype(g)
</code></pre>

<p>Return the type of graph <code>g</code>'s edge</p>
<p><a target='_blank' href='https://github.com/JuliaLang/julia/tree/82e96382251a1e163860df03c846acec86d07c36/base/docs/Docs.jl#L65-L69' class='documenter-source'>source</a><br></p>
<p><a id='LightGraphs.edit_distance-Tuple{LightGraphs.AbstractGraph,LightGraphs.AbstractGraph}' href='#LightGraphs.edit_distance-Tuple{LightGraphs.AbstractGraph,LightGraphs.AbstractGraph}'>#</a>
<strong><code>LightGraphs.edit_distance</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>edit_distance(G₁::AbstractGraph, G₂::AbstractGraph)
</code></pre>

<p>Compute the edit distance between graphs <code>G₁</code> and <code>G₂</code>. Return the minimum edit cost and edit path to transform graph <code>G₁</code> into graph `G₂<code>. An edit path consists of a sequence of pairs of vertices</code>(u,v) ∈ [0,|G₁|] × [0,|G₂|]`` representing vertex operations:</p>
<ul>
<li>$(0,v)$: insertion of vertex $v ∈ G₂$</li>
<li>$(u,0)$: deletion of vertex $u ∈ G₁$</li>
<li>$(u&gt;0,v&gt;0)$: substitution of vertex $u ∈ G₁$ by vertex $v ∈ G₂$</li>
</ul>
<p><strong>Optional Arguments</strong></p>
<ul>
<li><code>insert_cost::Function=v-&gt;1.0</code></li>
<li><code>delete_cost::Function=u-&gt;1.0</code></li>
<li><code>subst_cost::Function=(u,v)-&gt;0.5</code></li>
</ul>
<p>By default, the algorithm uses constant operation costs. The user can provide classical Minkowski costs computed from vertex labels μ₁ (for G₁) and μ₂ (for G₂) in order to further guide the search, for example:</p>
<pre><code>edit_distance(G₁, G₂, subst_cost=MinkowskiCost(μ₁, μ₂))
</code></pre>

<ul>
<li><code>heuristic::Function=DefaultEditHeuristic</code>: a custom heuristic provided to the A*</li>
</ul>
<p>search in case the default heuristic is not satisfactory.</p>
<p><strong>Performance</strong></p>
<ul>
<li>Given two graphs $|G₁| &lt; |G₂|$, <code>edit_distance(G₁, G₂)</code> is faster to</li>
</ul>
<p>compute than <code>edit_distance(G₂, G₁)</code>. Consider swapping the arguments if involved costs are equivalent.</p>
<ul>
<li>The use of simple Minkowski costs can improve performance considerably.</li>
<li>Exploit vertex attributes when designing operation costs.</li>
</ul>
<p><strong>References</strong></p>
<ul>
<li>RIESEN, K., 2015. Structural Pattern Recognition with Graph Edit Distance: Approximation Algorithms and Applications. (Chapter 2)</li>
</ul>
<p><strong>Author</strong></p>
<ul>
<li>Júlio Hoffimann Mendes (juliohm@stanford.edu)</li>
</ul>
<p><a target='_blank' href='https://github.com/JuliaLang/julia/tree/82e96382251a1e163860df03c846acec86d07c36/base/docs/Docs.jl#L1' class='documenter-source'>source</a><br></p>
<p><a id='LightGraphs.egonet-Tuple{LightGraphs.AbstractGraph,Integer,Integer}' href='#LightGraphs.egonet-Tuple{LightGraphs.AbstractGraph,Integer,Integer}'>#</a>
<strong><code>LightGraphs.egonet</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>egonet(g, v:, d)
</code></pre>

<p>Return the subgraph of <code>g</code> induced by the neighbors of <code>v</code> up to distance <code>d</code>. This is equivalent to <a href="./#LightGraphs.induced_subgraph-Union{Tuple{T,AbstractArray{U,1}}, Tuple{T}, Tuple{U}} where T&lt;:LightGraphs.AbstractGraph where U&lt;:Integer"><code>induced_subgraph</code></a><code>(g, neighborhood(g, v, d, dir=dir))[1].</code></p>
<p><strong>Optional Arguments</strong></p>
<ul>
<li><code>dir=:out</code>: if <code>g</code> is directed, this argument specifies the edge direction</li>
</ul>
<p>with respect to <code>v</code> (i.e. <code>:in</code> or <code>:out</code>).</p>
<p><a target='_blank' href='https://github.com/JuliaLang/julia/tree/82e96382251a1e163860df03c846acec86d07c36/base/docs/Docs.jl#L433-L443' class='documenter-source'>source</a><br></p>
<p><a id='LightGraphs.eigenvector_centrality-Tuple{LightGraphs.AbstractGraph}' href='#LightGraphs.eigenvector_centrality-Tuple{LightGraphs.AbstractGraph}'>#</a>
<strong><code>LightGraphs.eigenvector_centrality</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>eigenvector_centrality(g)
</code></pre>

<p>Compute the eigenvector centrality for the graph <code>g</code>.</p>
<p>Eigenvector centrality computes the centrality for a node based on the centrality of its neighbors. The eigenvector centrality for node <code>i</code> is</p>
<pre><code>``mathbf{Ax} = lambda mathbf{x}``
</code></pre>

<p>where <code>A</code> is the adjacency matrix of the graph <code>g</code> with eigenvalue <code>lambda</code>. By virtue of the Perron–Frobenius theorem, there is a unique and positive solution if <code>lambda</code> is the largest eigenvalue associated with the eigenvector of the adjacency matrix <code>A</code>.</p>
<p><strong>References</strong></p>
<ul>
<li>Phillip Bonacich: Power and Centrality: A Family of Measures.   American Journal of Sociology 92(5):1170–1182, 1986   http://www.leonidzhukov.net/hse/2014/socialnetworks/papers/Bonacich-Centrality.pdf</li>
<li>Mark E. J. Newman: Networks: An Introduction.      Oxford University Press, USA, 2010, pp. 169.</li>
</ul>
<p><a target='_blank' href='https://github.com/JuliaLang/julia/tree/82e96382251a1e163860df03c846acec86d07c36/base/docs/Docs.jl#L1' class='documenter-source'>source</a><br></p>
<p><a id='LightGraphs.erdos_renyi-Tuple{Integer,Integer}' href='#LightGraphs.erdos_renyi-Tuple{Integer,Integer}'>#</a>
<strong><code>LightGraphs.erdos_renyi</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>erdos_renyi(n, ne)
</code></pre>

<p>Create an <a href="http://en.wikipedia.org/wiki/Erdős–Rényi_model">Erdős–Rényi</a> random graph with <code>n</code> vertices and <code>ne</code> edges.</p>
<p><strong>Optional Arguments</strong></p>
<ul>
<li><code>is_directed=false</code>: if true, return a directed graph.</li>
<li><code>seed=-1</code>: set the RNG seed.</li>
</ul>
<p><a target='_blank' href='https://github.com/JuliaLang/julia/tree/82e96382251a1e163860df03c846acec86d07c36/base/docs/Docs.jl#L73-L82' class='documenter-source'>source</a><br></p>
<p><a id='LightGraphs.erdos_renyi-Tuple{Integer,Real}' href='#LightGraphs.erdos_renyi-Tuple{Integer,Real}'>#</a>
<strong><code>LightGraphs.erdos_renyi</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>erdos_renyi(n, p)
</code></pre>

<p>Create an <a href="http://en.wikipedia.org/wiki/Erdős–Rényi_model">Erdős–Rényi</a> random graph with <code>n</code> vertices. Edges are added between pairs of vertices with probability <code>p</code>.</p>
<p><strong>Optional Arguments</strong></p>
<ul>
<li><code>is_directed=false</code>: if true, return a directed graph.</li>
<li><code>seed=-1</code>: set the RNG seed.</li>
</ul>
<p><a target='_blank' href='https://github.com/JuliaLang/julia/tree/82e96382251a1e163860df03c846acec86d07c36/base/docs/Docs.jl#L56-L66' class='documenter-source'>source</a><br></p>
<p><a id='LightGraphs.euclidean_graph-Tuple{Array{T,2} where T}' href='#LightGraphs.euclidean_graph-Tuple{Array{T,2} where T}'>#</a>
<strong><code>LightGraphs.euclidean_graph</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>euclidean_graph(points)
</code></pre>

<p>Given the <code>d×N</code> matrix <code>points</code> build an Euclidean graph of <code>N</code> vertices and return a graph and Dict containing the distance on each edge.</p>
<p><strong>Optional Arguments</strong></p>
<ul>
<li><code>L=1</code>: used to bound the <code>d</code> dimensional box from which points are selected.</li>
<li><code>p=2</code></li>
<li><code>bc=:open</code></li>
</ul>
<p><strong>Implementation Notes</strong></p>
<p>Defining the <code>d</code>-dimensional vectors <code>x[i] = points[:,i]</code>, an edge between vertices <code>i</code> and <code>j</code> is inserted if <code>norm(x[i]-x[j], p) &lt; cutoff</code>. In case of negative <code>cutoff</code> instead every edge is inserted. For <code>p=2</code> we have the standard Euclidean distance. Set <code>bc=:periodic</code> to impose periodic boundary conditions in the box $[0,L]^d$.</p>
<p><a target='_blank' href='https://github.com/JuliaLang/julia/tree/82e96382251a1e163860df03c846acec86d07c36/base/docs/Docs.jl#L15-L32' class='documenter-source'>source</a><br></p>
<p><a id='LightGraphs.euclidean_graph-Tuple{Int64,Int64}' href='#LightGraphs.euclidean_graph-Tuple{Int64,Int64}'>#</a>
<strong><code>LightGraphs.euclidean_graph</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>euclidean_graph(N, d; seed=-1, L=1., p=2., cutoff=-1., bc=:open)
</code></pre>

<p>Generate <code>N</code> uniformly distributed points in the box $[0,L]^{d}$ and return a Euclidean graph, a map containing the distance on each edge and a matrix with the points' positions.</p>
<p><a target='_blank' href='https://github.com/JuliaLang/julia/tree/82e96382251a1e163860df03c846acec86d07c36/base/docs/Docs.jl#L1' class='documenter-source'>source</a><br></p>
<p><a id='LightGraphs.floyd_warshall_shortest_paths-Union{Tuple{LightGraphs.AbstractGraph,AbstractArray{T,2}}, Tuple{LightGraphs.AbstractGraph}, Tuple{T}} where T' href='#LightGraphs.floyd_warshall_shortest_paths-Union{Tuple{LightGraphs.AbstractGraph,AbstractArray{T,2}}, Tuple{LightGraphs.AbstractGraph}, Tuple{T}} where T'>#</a>
<strong><code>LightGraphs.floyd_warshall_shortest_paths</code></strong> &mdash; <em>Method</em>.</p>
<p>floyd_warshall_shortest_paths(g, distmx=DefaultDistance()) Use the <a href="http://en.wikipedia.org/wiki/Floyd–Warshall_algorithm">Floyd-Warshall algorithm</a> to compute the shortest paths between all pairs of vertices in graph <code>g</code> using an optional distance matrix <code>distmx</code>. Return a <a href="./#LightGraphs.FloydWarshallState"><code>FloydWarshallState</code></a> with relevant traversal information.</p>
<p><strong>Performance</strong></p>
<p>Space complexity is on the order of $\mathcal{O}(|V|^2)$.</p>
<p><a target='_blank' href='https://github.com/JuliaLang/julia/tree/82e96382251a1e163860df03c846acec86d07c36/base/docs/Docs.jl#L15' class='documenter-source'>source</a><br></p>
<p><a id='LightGraphs.gdistances!-Tuple{LightGraphs.AbstractGraph,Any,Any}' href='#LightGraphs.gdistances!-Tuple{LightGraphs.AbstractGraph,Any,Any}'>#</a>
<strong><code>LightGraphs.gdistances!</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>gdistances!(g, source, dists)
</code></pre>

<p>Fill <code>dists</code> with the geodesic distances of vertices in <code>g</code> from <code>source</code>. <code>dists</code> should be a vector of length <code>nv(g)</code>. Return <code>dists</code>. For vertices in disconnected components the default distance is -1.</p>
<p><a target='_blank' href='https://github.com/JuliaLang/julia/tree/82e96382251a1e163860df03c846acec86d07c36/base/docs/Docs.jl#L264-L270' class='documenter-source'>source</a><br></p>
<p><a id='LightGraphs.gdistances-Tuple{LightGraphs.AbstractGraph,Any}' href='#LightGraphs.gdistances-Tuple{LightGraphs.AbstractGraph,Any}'>#</a>
<strong><code>LightGraphs.gdistances</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>gdistances(g, source)
</code></pre>

<p>Return a vector filled with the geodesic distances of vertices in  <code>g</code> from <code>source</code>. If <code>source</code> is a collection of vertices each element should be unique. For vertices in disconnected components the default distance is -1.</p>
<p><a target='_blank' href='https://github.com/JuliaLang/julia/tree/82e96382251a1e163860df03c846acec86d07c36/base/docs/Docs.jl#L298-L304' class='documenter-source'>source</a><br></p>
<p><a id='LightGraphs.global_clustering_coefficient-Tuple{LightGraphs.AbstractGraph}' href='#LightGraphs.global_clustering_coefficient-Tuple{LightGraphs.AbstractGraph}'>#</a>
<strong><code>LightGraphs.global_clustering_coefficient</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>global_clustering_coefficient(g)
</code></pre>

<p>Return the <a href="https://en.wikipedia.org/wiki/Clustering_coefficient">global clustering coefficient</a> of graph <code>g</code>.</p>
<p><a target='_blank' href='https://github.com/JuliaLang/julia/tree/82e96382251a1e163860df03c846acec86d07c36/base/docs/Docs.jl#L66-L71' class='documenter-source'>source</a><br></p>
<p><a id='LightGraphs.has_edge-Tuple' href='#LightGraphs.has_edge-Tuple'>#</a>
<strong><code>LightGraphs.has_edge</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>has_edge(g, e)
</code></pre>

<p>Return true if the graph <code>g</code> has an edge <code>e</code>.</p>
<p><a target='_blank' href='https://github.com/JuliaLang/julia/tree/82e96382251a1e163860df03c846acec86d07c36/base/docs/Docs.jl#L156-L160' class='documenter-source'>source</a><br></p>
<p><a id='LightGraphs.has_self_loops-Tuple{LightGraphs.AbstractGraph}' href='#LightGraphs.has_self_loops-Tuple{LightGraphs.AbstractGraph}'>#</a>
<strong><code>LightGraphs.has_self_loops</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>has_self_loops(g)
</code></pre>

<p>Return true if <code>g</code> has any self loops.</p>
<p><a target='_blank' href='https://github.com/JuliaLang/julia/tree/82e96382251a1e163860df03c846acec86d07c36/base/docs/Docs.jl#L166-L170' class='documenter-source'>source</a><br></p>
<p><a id='LightGraphs.has_vertex-Tuple' href='#LightGraphs.has_vertex-Tuple'>#</a>
<strong><code>LightGraphs.has_vertex</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>has_vertex(g, v)
</code></pre>

<p>Return true if <code>v</code> is a vertex of <code>g</code>.</p>
<p><a target='_blank' href='https://github.com/JuliaLang/julia/tree/82e96382251a1e163860df03c846acec86d07c36/base/docs/Docs.jl#L149-L153' class='documenter-source'>source</a><br></p>
<p><a id='LightGraphs.in_neighbors-Tuple' href='#LightGraphs.in_neighbors-Tuple'>#</a>
<strong><code>LightGraphs.in_neighbors</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>in_neighbors(g, v)
</code></pre>

<p>Return a list of all neighbors connected to vertex <code>v</code> by an incoming edge.</p>
<p><strong>Implementation Notes</strong></p>
<p>Returns a reference, not a copy. Do not modify result.</p>
<p><a target='_blank' href='https://github.com/JuliaLang/julia/tree/82e96382251a1e163860df03c846acec86d07c36/base/docs/Docs.jl#L163-L170' class='documenter-source'>source</a><br></p>
<p><a id='LightGraphs.incidence_matrix' href='#LightGraphs.incidence_matrix'>#</a>
<strong><code>LightGraphs.incidence_matrix</code></strong> &mdash; <em>Function</em>.</p>
<pre><code>incidence_matrix(g, T=Int)
</code></pre>

<p>Return a sparse node-arc incidence matrix for a graph, indexed by <code>[v, i]</code>, where <code>i</code> is in <code>1:ne(g)</code>, indexing an edge <code>e</code>. For directed graphs, a value of <code>-1</code> indicates that <code>src(e) == v</code>, while a value of <code>1</code> indicates that <code>dst(e) == v</code>. Otherwise, the value is <code>0</code>. For undirected graphs, both entries are <code>1</code> by default (this behavior can be overridden by the <code>oriented</code> optional argument).</p>
<p><strong>Optional Arguments</strong></p>
<ul>
<li><code>oriented=false</code>: If true, for an undirected graph <code>g</code>, the matrix will</li>
</ul>
<p>contain arbitrary non-zero values representing connectivity between <code>v</code> and <code>i</code>.</p>
<p><a target='_blank' href='https://github.com/JuliaLang/julia/tree/82e96382251a1e163860df03c846acec86d07c36/base/docs/Docs.jl#L122-L135' class='documenter-source'>source</a><br></p>
<p><a id='LightGraphs.indegree-Tuple{LightGraphs.AbstractGraph,Integer}' href='#LightGraphs.indegree-Tuple{LightGraphs.AbstractGraph,Integer}'>#</a>
<strong><code>LightGraphs.indegree</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>indegree(g[, v])
</code></pre>

<p>Return a vector corresponding to the number of edges which end at each vertex in graph <code>g</code>. If <code>v</code> is specified, only return degrees for vertices in <code>v</code>.</p>
<p><a target='_blank' href='https://github.com/JuliaLang/julia/tree/82e96382251a1e163860df03c846acec86d07c36/base/docs/Docs.jl#L20-L25' class='documenter-source'>source</a><br></p>
<p><a id='LightGraphs.induced_subgraph-Union{Tuple{T,AbstractArray{U,1}}, Tuple{T}, Tuple{U}} where T<:LightGraphs.AbstractGraph where U<:Integer' href='#LightGraphs.induced_subgraph-Union{Tuple{T,AbstractArray{U,1}}, Tuple{T}, Tuple{U}} where T<:LightGraphs.AbstractGraph where U<:Integer'>#</a>
<strong><code>LightGraphs.induced_subgraph</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>induced_subgraph(g, vlist)
induced_subgraph(g, elist)
</code></pre>

<p>Return the subgraph of <code>g</code> induced by the vertices in  <code>vlist</code> or edges in <code>elist</code> along with a vector mapping the new vertices to the old ones (the  vertex <code>i</code> in the subgraph corresponds to the vertex <code>vmap[i]</code> in <code>g</code>.)</p>
<p>The returned graph has <code>length(vlist)</code> vertices, with the new vertex <code>i</code> corresponding to the vertex of the original graph in the <code>i</code>-th position of <code>vlist</code>.</p>
<p><strong>Usage Examples</strong></p>
<pre><code class="doctestjl">julia&gt; g = CompleteGraph(10)

julia&gt; sg, vmap = induced_subgraph(g, 5:8)

julia&gt; @assert g[5:8] == sg

julia&gt; @assert nv(sg) == 4

julia&gt; @assert ne(sg) == 6

julia&gt; @assert vm[4] == 8

julia&gt; sg, vmap = induced_subgraph(g, [2,8,3,4])

julia&gt; @assert sg == g[[2,8,3,4]]

julia&gt; elist = [Edge(1,2), Edge(3,4), Edge(4,8)]

julia&gt; sg, vmap = induced_subgraph(g, elist)

julia&gt; @assert sg == g[elist]
</code></pre>

<p><a target='_blank' href='https://github.com/JuliaLang/julia/tree/82e96382251a1e163860df03c846acec86d07c36/base/docs/Docs.jl#L342-L378' class='documenter-source'>source</a><br></p>
<p><a id='LightGraphs.is_bipartite-Tuple{LightGraphs.AbstractGraph}' href='#LightGraphs.is_bipartite-Tuple{LightGraphs.AbstractGraph}'>#</a>
<strong><code>LightGraphs.is_bipartite</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>is_bipartite(g[, v])
</code></pre>

<p>Return <code>true</code> if graph <code>g</code> is <a href="https://en.wikipedia.org/wiki/Bipartite_graph">bipartite</a>. If a node <code>v</code> is specified, only the connected component to which it belongs is considered.</p>
<p><a target='_blank' href='https://github.com/JuliaLang/julia/tree/82e96382251a1e163860df03c846acec86d07c36/base/docs/Docs.jl#L208-L213' class='documenter-source'>source</a><br></p>
<p><a id='LightGraphs.is_ordered-Tuple{LightGraphs.AbstractEdge}' href='#LightGraphs.is_ordered-Tuple{LightGraphs.AbstractEdge}'>#</a>
<strong><code>LightGraphs.is_ordered</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>is_ordered(e)
</code></pre>

<p>Return true if the source vertex of edge <code>e</code> is less than or equal to the destination vertex.</p>
<p><a target='_blank' href='https://github.com/JuliaLang/julia/tree/82e96382251a1e163860df03c846acec86d07c36/base/docs/Docs.jl#L6-L10' class='documenter-source'>source</a><br></p>
<p><a id='LightGraphs.isgraphical-Tuple{Array{Int64,1}}' href='#LightGraphs.isgraphical-Tuple{Array{Int64,1}}'>#</a>
<strong><code>LightGraphs.isgraphical</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>isgraphical(degs)
</code></pre>

<p>Return true if the degree sequence <code>degs</code> is graphical, according to <a href="http://mathworld.wolfram.com/GraphicSequence.html">Erdös-Gallai condition</a>.</p>
<p><strong>Performance</strong></p>
<pre><code>Time complexity: ``\mathcal{O}(|degs|^2)``
</code></pre>

<p><a target='_blank' href='https://github.com/JuliaLang/julia/tree/82e96382251a1e163860df03c846acec86d07c36/base/docs/Docs.jl#L313-L321' class='documenter-source'>source</a><br></p>
<p><a id='LightGraphs.katz_centrality' href='#LightGraphs.katz_centrality'>#</a>
<strong><code>LightGraphs.katz_centrality</code></strong> &mdash; <em>Function</em>.</p>
<pre><code>katz_centrality(g, α=0.3)
</code></pre>

<p>Calculate the <a href="https://en.wikipedia.org/wiki/Katz_centrality">Katz centrality</a> of the graph <code>g</code> optionally parameterized by <code>α</code>. Return a vector representing the centrality calculated for each node in <code>g</code>.</p>
<p><a target='_blank' href='https://github.com/JuliaLang/julia/tree/82e96382251a1e163860df03c846acec86d07c36/base/docs/Docs.jl#L24-L29' class='documenter-source'>source</a><br></p>
<p><a id='LightGraphs.kruskal_mst' href='#LightGraphs.kruskal_mst'>#</a>
<strong><code>LightGraphs.kruskal_mst</code></strong> &mdash; <em>Function</em>.</p>
<pre><code>kruskal_mst(g, distmx=DefaultDistance())
</code></pre>

<p>Return a vector of edges representing the minimum spanning tree of a connected, undirected graph <code>g</code> with optional distance matrix <code>distmx</code> using <a href="https://en.wikipedia.org/wiki/Kruskal%27s_algorithm">Kruskal's algorithm</a>.</p>
<p><a target='_blank' href='https://github.com/JuliaLang/julia/tree/82e96382251a1e163860df03c846acec86d07c36/base/docs/Docs.jl#L24-L29' class='documenter-source'>source</a><br></p>
<p><a id='LightGraphs.label_propagation' href='#LightGraphs.label_propagation'>#</a>
<strong><code>LightGraphs.label_propagation</code></strong> &mdash; <em>Function</em>.</p>
<pre><code>label_propagation(g, maxiter=1000)
</code></pre>

<p>Community detection using the label propagation algorithm. Return two vectors: the first is the label number assigned to each node, and the second is the convergence history for each node. Will return after <code>maxiter</code> iterations if convergence has not completed.</p>
<p><strong>References</strong></p>
<ul>
<li><a href="http://arxiv.org/abs/0709.2938">Raghavan et al.</a></li>
</ul>
<p><a target='_blank' href='https://github.com/JuliaLang/julia/tree/82e96382251a1e163860df03c846acec86d07c36/base/docs/Docs.jl#L1-L11' class='documenter-source'>source</a><br></p>
<p><a id='LightGraphs.laplacian_matrix' href='#LightGraphs.laplacian_matrix'>#</a>
<strong><code>LightGraphs.laplacian_matrix</code></strong> &mdash; <em>Function</em>.</p>
<pre><code>laplacian_matrix(g, dir=:unspec, T=Int)
</code></pre>

<p>Return a sparse <a href="https://en.wikipedia.org/wiki/Laplacian_matrix">Laplacian matrix</a> for a graph <code>g</code>, indexed by <code>[u, v]</code> vertices. For undirected graphs, <code>dir</code> defaults to <code>:out</code>; for directed graphs, <code>dir</code> defaults to <code>:both</code>. <code>T</code> defaults to <code>Int</code> for both graph types.</p>
<p><a target='_blank' href='https://github.com/JuliaLang/julia/tree/82e96382251a1e163860df03c846acec86d07c36/base/docs/Docs.jl#L70-L77' class='documenter-source'>source</a><br></p>
<p><a id='LightGraphs.laplacian_spectrum' href='#LightGraphs.laplacian_spectrum'>#</a>
<strong><code>LightGraphs.laplacian_spectrum</code></strong> &mdash; <em>Function</em>.</p>
<pre><code>laplacian_spectrum(g, dir=:unspec, T=Int)
</code></pre>

<p>Return the eigenvalues of the Laplacian matrix for a graph <code>g</code>, indexed by vertex. Default values for <code>dir</code> and <code>T</code> are the same as those in <a href="./#LightGraphs.laplacian_matrix"><code>laplacian_matrix</code></a>.</p>
<p><strong>Performance</strong></p>
<p>Converts the matrix to dense with $nv^2$ memory usage.</p>
<p><strong>Implementation Notes</strong></p>
<p>Use <code>eigs(laplacian_matrix(g);  kwargs...)</code> to compute some of the eigenvalues/eigenvectors.</p>
<p><a target='_blank' href='https://github.com/JuliaLang/julia/tree/82e96382251a1e163860df03c846acec86d07c36/base/docs/Docs.jl#L87' class='documenter-source'>source</a><br></p>
<p><a id='LightGraphs.loadgraph-Tuple{AbstractString,AbstractString,LightGraphs.AbstractGraphFormat}' href='#LightGraphs.loadgraph-Tuple{AbstractString,AbstractString,LightGraphs.AbstractGraphFormat}'>#</a>
<strong><code>LightGraphs.loadgraph</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>loadgraph(file, gname=&quot;graph&quot;, format=LGFormat)
</code></pre>

<p>Read a graph named <code>gname</code> from <code>file</code> in the format <code>format</code>.</p>
<p><strong>Implementation Notes</strong></p>
<p><code>gname</code> is graph-format dependent and is only used if the file contains multiple graphs; if the file format does not support multiple graphs, this value is ignored. The default value may change in the future.</p>
<p><a target='_blank' href='https://github.com/JuliaLang/julia/tree/82e96382251a1e163860df03c846acec86d07c36/base/docs/Docs.jl#L3-L12' class='documenter-source'>source</a><br></p>
<p><a id='LightGraphs.loadgraphs-Tuple{AbstractString,LightGraphs.AbstractGraphFormat}' href='#LightGraphs.loadgraphs-Tuple{AbstractString,LightGraphs.AbstractGraphFormat}'>#</a>
<strong><code>LightGraphs.loadgraphs</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>loadgraphs(file, format=LGFormat)
</code></pre>

<p>Load multiple graphs from <code>file</code> in the format <code>format</code>. Return a dictionary mapping graph name to graph.</p>
<p><strong>Implementation Notes</strong></p>
<p>For unnamed graphs the default name "graph" will be used. This default may change in the future.</p>
<p><a target='_blank' href='https://github.com/JuliaLang/julia/tree/82e96382251a1e163860df03c846acec86d07c36/base/docs/Docs.jl#L21-L30' class='documenter-source'>source</a><br></p>
<p><a id='LightGraphs.local_clustering-Tuple{LightGraphs.AbstractGraph,Integer}' href='#LightGraphs.local_clustering-Tuple{LightGraphs.AbstractGraph,Integer}'>#</a>
<strong><code>LightGraphs.local_clustering</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>local_clustering(g, v)
local_clustering(g, vs)
</code></pre>

<p>Return a tuple <code>(a, b)</code>, where <code>a</code> is the number of triangles in the neighborhood of <code>v</code> and <code>b</code> is the maximum number of possible triangles. If a list of vertices <code>vs</code> is specified, return two vectors representing the number of triangles and the maximum number of possible triangles, respectively, for each node in the list.</p>
<p>This function is related to the local clustering coefficient <code>r</code> by $r=rac{a}{b}$.</p>
<p><a target='_blank' href='https://github.com/JuliaLang/julia/tree/82e96382251a1e163860df03c846acec86d07c36/base/docs/Docs.jl#L18' class='documenter-source'>source</a><br></p>
<p><a id='LightGraphs.local_clustering_coefficient-Tuple{LightGraphs.AbstractGraph,Integer}' href='#LightGraphs.local_clustering_coefficient-Tuple{LightGraphs.AbstractGraph,Integer}'>#</a>
<strong><code>LightGraphs.local_clustering_coefficient</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>local_clustering_coefficient(g, v)
local_clustering_coefficient(g, vs)
</code></pre>

<p>Return the <a href="https://en.wikipedia.org/wiki/Clustering_coefficient">local clustering coefficient</a> for node <code>v</code> in graph <code>g</code>. If a list of vertices <code>vs</code> is specified, return a vector of coefficients for each node in the list.</p>
<p><a target='_blank' href='https://github.com/JuliaLang/julia/tree/82e96382251a1e163860df03c846acec86d07c36/base/docs/Docs.jl#L1-L8' class='documenter-source'>source</a><br></p>
<p><a id='LightGraphs.make_edgestream-Tuple{LightGraphs.StochasticBlockModel}' href='#LightGraphs.make_edgestream-Tuple{LightGraphs.StochasticBlockModel}'>#</a>
<strong><code>LightGraphs.make_edgestream</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>make_edgestream(sbm)
</code></pre>

<p>Take an infinite sample from the Stochastic Block Model <code>sbm</code>. Pass to <code>Graph(nvg, neg, edgestream)</code> to get a Graph object based on <code>sbm</code>.</p>
<p><a target='_blank' href='https://github.com/JuliaLang/julia/tree/82e96382251a1e163860df03c846acec86d07c36/base/docs/Docs.jl#L781-L786' class='documenter-source'>source</a><br></p>
<p><a id='LightGraphs.maximal_cliques' href='#LightGraphs.maximal_cliques'>#</a>
<strong><code>LightGraphs.maximal_cliques</code></strong> &mdash; <em>Function</em>.</p>
<pre><code>maximal_cliques(g)
</code></pre>

<p>Return a vector of vectors representing the node indices in each of the maximal cliques found in the undirected graph <code>g</code>.</p>
<pre><code class="jldoctest">julia&gt; using LightGraphs
julia&gt; g = Graph(3)
julia&gt; add_edge!(g, 1, 2)
julia&gt; add_edge!(g, 2, 3)
julia&gt; maximal_cliques(g)
2-element Array{Array{Int64,N},1}:
 [2,3]
 [2,1]
</code></pre>

<p><a target='_blank' href='https://github.com/JuliaLang/julia/tree/82e96382251a1e163860df03c846acec86d07c36/base/docs/Docs.jl#L8-L24' class='documenter-source'>source</a><br></p>
<p><a id='LightGraphs.maximum_adjacency_visit-Union{Tuple{LightGraphs.AbstractGraph,AbstractArray{T,2},Bool,IO}, Tuple{T}} where T' href='#LightGraphs.maximum_adjacency_visit-Union{Tuple{LightGraphs.AbstractGraph,AbstractArray{T,2},Bool,IO}, Tuple{T}} where T'>#</a>
<strong><code>LightGraphs.maximum_adjacency_visit</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>maximum_adjacency_visit(g[, distmx][, log][, io])
</code></pre>

<p>Return the vertices in <code>g</code> traversed by maximum adjacency search. An optional <code>distmx</code> matrix may be specified; if omitted, edge distances are assumed to be 1. If <code>log</code> (default <code>false</code>) is <code>true</code>, visitor events will be printed to <code>io</code>, which defaults to <code>STDOUT</code>; otherwise, no event information will be displayed.</p>
<p><a target='_blank' href='https://github.com/JuliaLang/julia/tree/82e96382251a1e163860df03c846acec86d07c36/base/docs/Docs.jl#L196-L204' class='documenter-source'>source</a><br></p>
<p><a id='LightGraphs.maximum_flow' href='#LightGraphs.maximum_flow'>#</a>
<strong><code>LightGraphs.maximum_flow</code></strong> &mdash; <em>Function</em>.</p>
<pre><code>maximum_flow(flow_graph, source, target[, capacity_matrix][, algorithm][, restriction])
</code></pre>

<p>Generic maximum_flow function for <code>flow_graph</code> from <code>source</code> to <code>target</code> with capacities in <code>capacity_matrix</code>. Uses flow algorithm <code>algorithm</code> and cutoff restriction <code>restriction</code>.</p>
<ul>
<li>If <code>capacity_matrix</code> is not specified, <code>DefaultCapacity(flow_graph)</code> will be used.</li>
<li>If <code>algorithm</code> is not specified, it will default to <a href="./#LightGraphs.PushRelabelAlgorithm"><code>PushRelabelAlgorithm</code></a>.</li>
<li>If <code>restriction</code> is not specified, it will default to <code>0</code>.</li>
</ul>
<p>Return a tuple of (maximum flow, flow matrix). For the Boykov-Kolmogorov algorithm, the associated mincut is returned as a third output.</p>
<p><strong>Usage Example:</strong></p>
<pre><code class="jldoctest">julia&gt; flow_graph = DiGraph(8) # Create a flow-graph
julia&gt; flow_edges = [
(1,2,10),(1,3,5),(1,4,15),(2,3,4),(2,5,9),
(2,6,15),(3,4,4),(3,6,8),(4,7,16),(5,6,15),
(5,8,10),(6,7,15),(6,8,10),(7,3,6),(7,8,10)
]

julia&gt; capacity_matrix = zeros(Int, 8, 8)  # Create a capacity matrix

julia&gt; for e in flow_edges
    u, v, f = e
    add_edge!(flow_graph, u, v)
    capacity_matrix[u,v] = f
end

julia&gt; f, F = maximum_flow(flow_graph, 1, 8) # Run default maximum_flow without the capacity_matrix

julia&gt; f, F = maximum_flow(flow_graph, 1, 8) # Run default maximum_flow with the capacity_matrix

julia&gt; f, F = maximum_flow(flow_graph,1,8,capacity_matrix,algorithm=EdmondsKarpAlgorithm()) # Run Edmonds-Karp algorithm

julia&gt; f, F = maximum_flow(flow_graph,1,8,capacity_matrix,algorithm=DinicAlgorithm()) # Run Dinic's algorithm

julia&gt; f, F, labels = maximum_flow(flow_graph,1,8,capacity_matrix,algorithm=BoykovKolmogorovAlgorithm()) # Run Boykov-Kolmogorov algorithm

</code></pre>

<p><a target='_blank' href='https://github.com/JuliaLang/julia/tree/82e96382251a1e163860df03c846acec86d07c36/base/docs/Docs.jl#L122-L165' class='documenter-source'>source</a><br></p>
<p><a id='LightGraphs.maxsimplecycles' href='#LightGraphs.maxsimplecycles'>#</a>
<strong><code>LightGraphs.maxsimplecycles</code></strong> &mdash; <em>Function</em>.</p>
<pre><code>maxsimplecycles(dg::::IsDirected, byscc::Bool = true)
</code></pre>

<p>Compute the theoretical maximum number of cycles in the directed graph <code>dg</code>.</p>
<p>The computation can be performed assuming the graph is complete or taking into account the decomposition in strongly connected components (<code>byscc</code> parameter). The formula is coming from <a href="../Johnson">Johnson, 1973</a>.</p>
<p><strong>Performance</strong></p>
<p>A more efficient version is possible.</p>
<p><strong>References</strong></p>
<ul>
<li><a href="http://epubs.siam.org/doi/abs/10.1137/0204007">Johnson</a></li>
</ul>
<p><a target='_blank' href='https://github.com/JuliaLang/julia/tree/82e96382251a1e163860df03c846acec86d07c36/base/docs/Docs.jl#L26' class='documenter-source'>source</a><br></p>
<p><a id='LightGraphs.maxsimplecycles-Tuple{Integer}' href='#LightGraphs.maxsimplecycles-Tuple{Integer}'>#</a>
<strong><code>LightGraphs.maxsimplecycles</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>maxsimplecycles(n::Integer)
</code></pre>

<p>Compute the theoretical maximum number of cycles in a directed graph of <code>n</code> vertices, assuming there are no self-loops. The formula is coming from <a href="../Johnson">Johnson, 1973</a>.</p>
<p><strong>References</strong></p>
<ul>
<li><a href="http://epubs.siam.org/doi/abs/10.1137/0204007">Johnson</a>.</li>
</ul>
<p><a target='_blank' href='https://github.com/JuliaLang/julia/tree/82e96382251a1e163860df03c846acec86d07c36/base/docs/Docs.jl#L12-L21' class='documenter-source'>source</a><br></p>
<p><a id='LightGraphs.mincut-Union{Tuple{LightGraphs.AbstractGraph,AbstractArray{T,2}}, Tuple{LightGraphs.AbstractGraph}, Tuple{T}} where T' href='#LightGraphs.mincut-Union{Tuple{LightGraphs.AbstractGraph,AbstractArray{T,2}}, Tuple{LightGraphs.AbstractGraph}, Tuple{T}} where T'>#</a>
<strong><code>LightGraphs.mincut</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>mincut(g, distmx=DefaultDistance())
</code></pre>

<p>Return a tuple <code>(parity, bestcut)</code>, where <code>parity</code> is a vector of integer values that determines the partition in <code>g</code> (1 or 2) and <code>bestcut</code> is the weight of the cut that makes this partition. An optional <code>distmx</code> matrix may be specified; if omitted, edge distances are assumed to be 1.</p>
<p><a target='_blank' href='https://github.com/JuliaLang/julia/tree/82e96382251a1e163860df03c846acec86d07c36/base/docs/Docs.jl#L177-L184' class='documenter-source'>source</a><br></p>
<p><a id='LightGraphs.modularity' href='#LightGraphs.modularity'>#</a>
<strong><code>LightGraphs.modularity</code></strong> &mdash; <em>Function</em>.</p>
<pre><code>modularity(g, c)
</code></pre>

<p>Return a value representing Newman's modularity <code>Q</code> for the undirected graph <code>g</code> given the partitioning vector <code>c</code>.</p>
<p><a target='_blank' href='https://github.com/JuliaLang/julia/tree/82e96382251a1e163860df03c846acec86d07c36/base/docs/Docs.jl#L1-L6' class='documenter-source'>source</a><br></p>
<p><a id='LightGraphs.multiroute_flow-Union{Tuple{LightGraphs.AbstractGraph,Integer,Integer,AbstractArray{T,2} where T}, Tuple{LightGraphs.AbstractGraph,Integer,Integer}, Tuple{R}} where R<:Real' href='#LightGraphs.multiroute_flow-Union{Tuple{LightGraphs.AbstractGraph,Integer,Integer,AbstractArray{T,2} where T}, Tuple{LightGraphs.AbstractGraph,Integer,Integer}, Tuple{R}} where R<:Real'>#</a>
<strong><code>LightGraphs.multiroute_flow</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>multiroute_flow(flow_graph, source, target[, DefaultCapacity][, flow_algorithm][, mrf_algorithm][, routes])
</code></pre>

<p>The generic multiroute_flow function.</p>
<p>The output will vary depending on the input:</p>
<ul>
<li>When the number of <code>route</code>s is <code>0</code>, return the set of breaking points of</li>
</ul>
<p>the multiroute flow.</p>
<ul>
<li>When the number of <code>route</code>s is <code>1</code>, return a flow with a set of 1-disjoint paths</li>
</ul>
<p>(this is the classical max-flow implementation).</p>
<ul>
<li>When the input is limited to a set of breaking points and a route value <code>k</code>,</li>
</ul>
<p>return only the k-route flow.</p>
<ul>
<li>Otherwise, a tuple with 1) the maximum flow and 2) the flow matrix. When the</li>
</ul>
<p>max-flow subroutine is the Boykov-Kolmogorov algorithm, the associated mincut is returned as a third output.</p>
<p>When the input is a network, it requires the following arguments:</p>
<ul>
<li><code>flow_graph</code>: the input graph</li>
<li><code>source</code>: the source vertex</li>
<li><code>target</code>: the target vertex</li>
<li><code>capacity_matrix</code>: matrix of edge flow capacities</li>
<li><code>flow_algorithm</code>: keyword argument for flow algorithm</li>
<li><code>mrf_algorithm</code>: keyword argument for multiroute flow algorithm</li>
<li><code>routes</code>: keyword argument for the number of routes</li>
</ul>
<p>When the input is only the set of (breaking) points and the number of route, it requires the following arguments:</p>
<ul>
<li><code>breakingpoints</code>: vector of breaking points</li>
<li><code>routes</code>: number of routes</li>
</ul>
<p>When the input is the set of (breaking) points, the number of routes, and the network descriptors, it requires the following arguments:</p>
<ul>
<li><code>breakingpoints</code>: vector of breaking points</li>
<li><code>routes</code>: number of routes</li>
<li><code>flow_graph</code>: the input graph</li>
<li><code>source</code>: the source vertex</li>
<li><code>target</code>: the target vertex</li>
<li><code>capacity_matrix</code>: matrix of edge flow capacities</li>
<li><code>flow_algorithm</code>: keyword argument for flow algorithm</li>
</ul>
<p>The function defaults to the Push-relabel (classical flow) and Kishimoto (multiroute) algorithms. Alternatively, the algorithms to be used can also be specified through  keyword arguments. A default capacity of <code>1</code> is assumed for each link if no capacity matrix is provided.</p>
<p>The <code>mrf_algorithm</code> keyword is inforced to Extended Multiroute Flow in the following cases:</p>
<ul>
<li>The number of routes is non-integer</li>
<li>The number of routes is 0 or non-specified</li>
</ul>
<p><strong>Usage Example :</strong></p>
<p>(please consult the  <a href="../@ref"><code>max_flow</code></a> section for options about flow_algorithm and capacity_matrix)</p>
<pre><code class="jldoctest">julia&gt; flow_graph = DiGraph(8) # Create a flow graph

julia&gt; flow_edges = [
(1, 2, 10), (1, 3, 5),  (1, 4, 15), (2, 3, 4),  (2, 5, 9),
(2, 6, 15), (3, 4, 4),  (3, 6, 8),  (4, 7, 16), (5, 6, 15),
(5, 8, 10), (6, 7, 15), (6, 8, 10), (7, 3, 6),  (7, 8, 10)
]

julia&gt; capacity_matrix = zeros(Int, 8, 8) # Create a capacity matrix

julia&gt; for e in flow_edges
    u, v, f = e
    add_edge!(flow_graph, u, v)
    capacity_matrix[u, v] = f
end

julia&gt; f, F = multiroute_flow(flow_graph, 1, 8, capacity_matrix, routes = 2) # Run default multiroute_flow with an integer number of routes = 2

julia&gt; f, F = multiroute_flow(flow_graph, 1, 8, capacity_matrix, routes = 1.5) # Run default multiroute_flow with a noninteger number of routes = 1.5

julia&gt; points = multiroute_flow(flow_graph, 1, 8, capacity_matrix) # Run default multiroute_flow for all the breaking points values

julia&gt; f, F = multiroute_flow(points, 1.5) # Then run multiroute flow algorithm for any positive number of routes

julia&gt; f = multiroute_flow(points, 1.5, valueonly = true)

julia&gt; f, F, labels = multiroute_flow(flow_graph, 1, 8, capacity_matrix, algorithm = BoykovKolmogorovAlgorithm(), routes = 2) # Run multiroute flow algorithm using Boykov-Kolmogorov algorithm as max_flow routine

</code></pre>

<p><a target='_blank' href='https://github.com/JuliaLang/julia/tree/82e96382251a1e163860df03c846acec86d07c36/base/docs/Docs.jl#L100-L189' class='documenter-source'>source</a><br></p>
<p><a id='LightGraphs.ne-Tuple{LightGraphs.AbstractGraph}' href='#LightGraphs.ne-Tuple{LightGraphs.AbstractGraph}'>#</a>
<strong><code>LightGraphs.ne</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>ne(g)
</code></pre>

<p>Return the number of edges in <code>g</code>.</p>
<p><a target='_blank' href='https://github.com/JuliaLang/julia/tree/82e96382251a1e163860df03c846acec86d07c36/base/docs/Docs.jl#L86-L90' class='documenter-source'>source</a><br></p>
<p><a id='LightGraphs.neighborhood-Tuple{LightGraphs.AbstractGraph,Integer,Integer}' href='#LightGraphs.neighborhood-Tuple{LightGraphs.AbstractGraph,Integer,Integer}'>#</a>
<strong><code>LightGraphs.neighborhood</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>neighborhood(g, v, d)
</code></pre>

<p>Return a vector of the vertices in <code>g</code> at a geodesic distance less or equal to <code>d</code> from <code>v</code>.</p>
<p><strong>Optional Arguments</strong></p>
<ul>
<li><code>dir=:out</code>: If <code>g</code> is directed, this argument specifies the edge direction</li>
</ul>
<p>with respect to <code>v</code> of the edges to be considered. Possible values: <code>:in</code> or <code>:out</code>.</p>
<p><a target='_blank' href='https://github.com/JuliaLang/julia/tree/82e96382251a1e163860df03c846acec86d07c36/base/docs/Docs.jl#L293-L302' class='documenter-source'>source</a><br></p>
<p><a id='LightGraphs.neighbors-Tuple{LightGraphs.AbstractGraph,Integer}' href='#LightGraphs.neighbors-Tuple{LightGraphs.AbstractGraph,Integer}'>#</a>
<strong><code>LightGraphs.neighbors</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>neighbors(g, v)
</code></pre>

<p>Return a list of all neighbors reachable from vertex <code>v</code> in <code>g</code>. For directed graphs, the default is equivalent to <a href="./#LightGraphs.out_neighbors-Tuple"><code>out_neighbors</code></a>; use <a href="./#LightGraphs.all_neighbors"><code>all_neighbors</code></a> to list inbound and outbound neighbors.</p>
<p><strong>Implementation Notes</strong></p>
<p>Returns a reference, not a copy. Do not modify result.</p>
<p><a target='_blank' href='https://github.com/JuliaLang/julia/tree/82e96382251a1e163860df03c846acec86d07c36/base/docs/Docs.jl#L127-L136' class='documenter-source'>source</a><br></p>
<p><a id='LightGraphs.non_backtracking_matrix-Tuple{LightGraphs.AbstractGraph}' href='#LightGraphs.non_backtracking_matrix-Tuple{LightGraphs.AbstractGraph}'>#</a>
<strong><code>LightGraphs.non_backtracking_matrix</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>non_backtracking_matrix(g)
</code></pre>

<p>Return a non-backtracking matrix <code>B</code> and an edgemap storing the oriented edges' positions in <code>B</code>.</p>
<p>Given two arcs $A_{i j}<code>and</code>A_{k l}<code>in</code>g`, the non-backtraking matrix$B`` is defined as</p>
<p>$B_{A_{i j}, A_{k l}} = δ_{j k} * (1 - δ_{i l})$</p>
<p><a target='_blank' href='https://github.com/JuliaLang/julia/tree/82e96382251a1e163860df03c846acec86d07c36/base/docs/Docs.jl#L6' class='documenter-source'>source</a><br></p>
<p><a id='LightGraphs.non_backtracking_randomwalk' href='#LightGraphs.non_backtracking_randomwalk'>#</a>
<strong><code>LightGraphs.non_backtracking_randomwalk</code></strong> &mdash; <em>Function</em>.</p>
<pre><code>non_backtracking_randomwalk(g, s, niter)
</code></pre>

<p>Perform a non-backtracking random walk on directed graph <code>g</code> starting at vertex <code>s</code> and continuing for a maximum of <code>niter</code> steps. Return a vector of vertices visited in order.</p>
<p><a target='_blank' href='https://github.com/JuliaLang/julia/tree/82e96382251a1e163860df03c846acec86d07c36/base/docs/Docs.jl#L24-L30' class='documenter-source'>source</a><br></p>
<p><a id='LightGraphs.num_self_loops-Tuple{LightGraphs.AbstractGraph}' href='#LightGraphs.num_self_loops-Tuple{LightGraphs.AbstractGraph}'>#</a>
<strong><code>LightGraphs.num_self_loops</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>num_self_loops(g)
</code></pre>

<p>Return the number of self loops in <code>g</code>.</p>
<p><a target='_blank' href='https://github.com/JuliaLang/julia/tree/82e96382251a1e163860df03c846acec86d07c36/base/docs/Docs.jl#L173-L177' class='documenter-source'>source</a><br></p>
<p><a id='LightGraphs.nv-Tuple{LightGraphs.AbstractGraph}' href='#LightGraphs.nv-Tuple{LightGraphs.AbstractGraph}'>#</a>
<strong><code>LightGraphs.nv</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>nv(g)
</code></pre>

<p>Return the number of vertices in <code>g</code>.</p>
<p><a target='_blank' href='https://github.com/JuliaLang/julia/tree/82e96382251a1e163860df03c846acec86d07c36/base/docs/Docs.jl#L79-L83' class='documenter-source'>source</a><br></p>
<p><a id='LightGraphs.out_neighbors-Tuple' href='#LightGraphs.out_neighbors-Tuple'>#</a>
<strong><code>LightGraphs.out_neighbors</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>out_neighbors(g, v)
</code></pre>

<p>Return a list of all neighbors connected to vertex <code>v</code> by an outgoing edge.</p>
<p><strong>Implementation Notes</strong></p>
<p>Returns a reference, not a copy. Do not modify result.</p>
<p><a target='_blank' href='https://github.com/JuliaLang/julia/tree/82e96382251a1e163860df03c846acec86d07c36/base/docs/Docs.jl#L173-L180' class='documenter-source'>source</a><br></p>
<p><a id='LightGraphs.outdegree-Tuple{LightGraphs.AbstractGraph,Integer}' href='#LightGraphs.outdegree-Tuple{LightGraphs.AbstractGraph,Integer}'>#</a>
<strong><code>LightGraphs.outdegree</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>outdegree(g[, v])
</code></pre>

<p>Return a vector corresponding to the number of edges which start at each vertex in graph <code>g</code>. If <code>v</code> is specified, only return degrees for vertices in <code>v</code>.</p>
<p><a target='_blank' href='https://github.com/JuliaLang/julia/tree/82e96382251a1e163860df03c846acec86d07c36/base/docs/Docs.jl#L29-L34' class='documenter-source'>source</a><br></p>
<p><a id='LightGraphs.pagerank' href='#LightGraphs.pagerank'>#</a>
<strong><code>LightGraphs.pagerank</code></strong> &mdash; <em>Function</em>.</p>
<pre><code>pagerank(g, α=0.85, n=100, ϵ=1.0e-6)
</code></pre>

<p>Calculate the <a href="https://en.wikipedia.org/wiki/PageRank">PageRank</a> of the directed graph <code>g</code> parameterized by damping factor <code>α</code>, number of iterations <code>n</code>, and convergence threshold <code>ϵ</code>. Return a vector representing the centrality calculated for each node in <code>g</code>, or an error if convergence is not reached within <code>n</code> iterations.</p>
<p><a target='_blank' href='https://github.com/JuliaLang/julia/tree/82e96382251a1e163860df03c846acec86d07c36/base/docs/Docs.jl#L4-L12' class='documenter-source'>source</a><br></p>
<p><a id='LightGraphs.periphery-Tuple{Array{T,1} where T}' href='#LightGraphs.periphery-Tuple{Array{T,1} where T}'>#</a>
<strong><code>LightGraphs.periphery</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>periphery(g, distmx=DefaultDistance())
periphery(eccentricities)
</code></pre>

<p>Given a graph and optional distance matrix, or a vector of precomputed eccentricities, return the set of all vertices whose eccentricity is equal to the graph's diameter (that is, the set of vertices with the largest eccentricity).</p>
<p><a target='_blank' href='https://github.com/JuliaLang/julia/tree/82e96382251a1e163860df03c846acec86d07c36/base/docs/Docs.jl#L70-L78' class='documenter-source'>source</a><br></p>
<p><a id='LightGraphs.prim_mst' href='#LightGraphs.prim_mst'>#</a>
<strong><code>LightGraphs.prim_mst</code></strong> &mdash; <em>Function</em>.</p>
<pre><code>prim_mst(g, distmx=DefaultDistance())
</code></pre>

<p>Return a vector of edges representing the minimum spanning tree of a connected, undirected graph <code>g</code> with optional distance matrix <code>distmx</code> using <a href="https://en.wikipedia.org/wiki/Prim%27s_algorithm">Prim's algorithm</a>. Return a vector of edges.</p>
<p><a target='_blank' href='https://github.com/JuliaLang/julia/tree/82e96382251a1e163860df03c846acec86d07c36/base/docs/Docs.jl#L8-L14' class='documenter-source'>source</a><br></p>
<p><a id='LightGraphs.radius-Tuple{Array{T,1} where T}' href='#LightGraphs.radius-Tuple{Array{T,1} where T}'>#</a>
<strong><code>LightGraphs.radius</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>radius(g, distmx=DefaultDistance())
radius(eccentricities)
</code></pre>

<p>Given a graph and optional distance matrix, or a vector of precomputed eccentricities, return the minimum eccentricity of the graph.</p>
<p><a target='_blank' href='https://github.com/JuliaLang/julia/tree/82e96382251a1e163860df03c846acec86d07c36/base/docs/Docs.jl#L87-L93' class='documenter-source'>source</a><br></p>
<p><a id='LightGraphs.random_configuration_model-Union{Tuple{Integer,Array{T,N} where N}, Tuple{T}} where T<:Integer' href='#LightGraphs.random_configuration_model-Union{Tuple{Integer,Array{T,N} where N}, Tuple{T}} where T<:Integer'>#</a>
<strong><code>LightGraphs.random_configuration_model</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>random_configuration_model(n, ks)
</code></pre>

<p>Create a random undirected graph according to the <a href="http://tuvalu.santafe.edu/~aaronc/courses/5352/fall2013/csci5352_2013_L11.pdf">configuration model</a> containing <code>n</code> vertices, with each node <code>i</code> having degree <code>k[i]</code>.</p>
<p><strong>Optional Arguments</strong></p>
<ul>
<li><code>seed=-1</code>: set the RNG seed.</li>
<li><code>check_graphical=false</code>: if true, ensure that <code>k</code> is a graphical sequence</li>
</ul>
<p>(see <a href="./#LightGraphs.isgraphical-Tuple{Array{Int64,1}}"><code>isgraphical</code></a>).</p>
<p><strong>Performance</strong></p>
<p>Time complexity is approximately $\mathcal{O}(n \bar{k}^2)$.</p>
<p><strong>Implementation Notes</strong></p>
<p>Allocates an array of $n \bar{k}$ <code>Int</code>s.</p>
<p><a target='_blank' href='https://github.com/JuliaLang/julia/tree/82e96382251a1e163860df03c846acec86d07c36/base/docs/Docs.jl#L513' class='documenter-source'>source</a><br></p>
<p><a id='LightGraphs.random_regular_digraph-Tuple{Integer,Integer}' href='#LightGraphs.random_regular_digraph-Tuple{Integer,Integer}'>#</a>
<strong><code>LightGraphs.random_regular_digraph</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>random_regular_digraph(n, k)
</code></pre>

<p>Create a random directed <a href="https://en.wikipedia.org/wiki/Regular_graph">regular graph</a> with <code>n</code> vertices, each with degree <code>k</code>.</p>
<p><strong>Optional Arguments</strong></p>
<ul>
<li><code>dir=:out</code>: the direction of the edges for degree parameter.</li>
<li><code>seed=-1</code>: set the RNG seed.</li>
</ul>
<p><strong>Implementation Notes</strong></p>
<p>Allocates an $n × n$ sparse matrix of boolean as an adjacency matrix and uses that to generate the directed graph.</p>
<p><a target='_blank' href='https://github.com/JuliaLang/julia/tree/82e96382251a1e163860df03c846acec86d07c36/base/docs/Docs.jl#L553' class='documenter-source'>source</a><br></p>
<p><a id='LightGraphs.random_regular_graph-Tuple{Integer,Integer}' href='#LightGraphs.random_regular_graph-Tuple{Integer,Integer}'>#</a>
<strong><code>LightGraphs.random_regular_graph</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>random_regular_graph(n, k)
</code></pre>

<p>Create a random undirected <a href="https://en.wikipedia.org/wiki/Regular_graph">regular graph</a> with <code>n</code> vertices, each with degree <code>k</code>.</p>
<p><strong>Optional Arguments</strong></p>
<ul>
<li><code>seed=-1</code>: set the RNG seed.</li>
</ul>
<p><strong>Performance</strong></p>
<p>Time complexity is approximately $\mathcal{O}(nk^2)$.</p>
<p><strong>Implementation Notes</strong></p>
<p>Allocates an array of <code>nk</code> <code>Int</code>s, and . For $k &gt; \frac{n}{2}$, generates a graph of degree $n-k-1$ and returns its complement.</p>
<p><a target='_blank' href='https://github.com/JuliaLang/julia/tree/82e96382251a1e163860df03c846acec86d07c36/base/docs/Docs.jl#L471' class='documenter-source'>source</a><br></p>
<p><a id='LightGraphs.randomwalk-Tuple{LightGraphs.AbstractGraph,Integer,Integer}' href='#LightGraphs.randomwalk-Tuple{LightGraphs.AbstractGraph,Integer,Integer}'>#</a>
<strong><code>LightGraphs.randomwalk</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>randomwalk(g, s, niter)
</code></pre>

<p>Perform a random walk on graph <code>g</code> starting at vertex <code>s</code> and continuing for a maximum of <code>niter</code> steps. Return a vector of vertices visited in order.</p>
<p><a target='_blank' href='https://github.com/JuliaLang/julia/tree/82e96382251a1e163860df03c846acec86d07c36/base/docs/Docs.jl#L1-L6' class='documenter-source'>source</a><br></p>
<p><a id='LightGraphs.rem_edge!-Tuple' href='#LightGraphs.rem_edge!-Tuple'>#</a>
<strong><code>LightGraphs.rem_edge!</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>rem_edge!(g, e)
</code></pre>

<p>Remove the edge <code>e</code> from <code>g</code>. Return false if edge removal fails (e.g., if edge does not exist), true otherwise.</p>
<p><a target='_blank' href='https://github.com/JuliaLang/julia/tree/82e96382251a1e163860df03c846acec86d07c36/base/docs/Docs.jl#L141-L146' class='documenter-source'>source</a><br></p>
<p><a id='LightGraphs.rem_vertex!-Tuple' href='#LightGraphs.rem_vertex!-Tuple'>#</a>
<strong><code>LightGraphs.rem_vertex!</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>rem_vertex!(g)
</code></pre>

<p>Remove the vertex <code>v</code> from graph <code>g</code>. Return false if removal fails (e.g., if vertex is not in the graph), true otherwise.</p>
<p><a target='_blank' href='https://github.com/JuliaLang/julia/tree/82e96382251a1e163860df03c846acec86d07c36/base/docs/Docs.jl#L133-L138' class='documenter-source'>source</a><br></p>
<p><a id='LightGraphs.savegraph-Tuple{AbstractString,LightGraphs.AbstractGraph,AbstractString,LightGraphs.AbstractGraphFormat}' href='#LightGraphs.savegraph-Tuple{AbstractString,LightGraphs.AbstractGraph,AbstractString,LightGraphs.AbstractGraphFormat}'>#</a>
<strong><code>LightGraphs.savegraph</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>savegraph(file, g, gname=&quot;graph&quot;, format=LGFormat; compress=true)
</code></pre>

<p>Saves a graph <code>g</code> with name <code>gname</code> to <code>file</code> in the format <code>format</code>. If <code>compress = true</code>, use GZip compression when writing the file. Return the number of graphs written.</p>
<p><strong>Implementation Notes</strong></p>
<p>The default graph name assigned to <code>gname</code> may change in the future.</p>
<p><a target='_blank' href='https://github.com/JuliaLang/julia/tree/82e96382251a1e163860df03c846acec86d07c36/base/docs/Docs.jl#L40-L49' class='documenter-source'>source</a><br></p>
<p><a id='LightGraphs.savegraph-Union{Tuple{AbstractString,Dict{T,U},LightGraphs.AbstractGraphFormat}, Tuple{T}, Tuple{U}} where T<:AbstractString where U<:LightGraphs.AbstractGraph' href='#LightGraphs.savegraph-Union{Tuple{AbstractString,Dict{T,U},LightGraphs.AbstractGraphFormat}, Tuple{T}, Tuple{U}} where T<:AbstractString where U<:LightGraphs.AbstractGraph'>#</a>
<strong><code>LightGraphs.savegraph</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>savegraph(file, g, d, format=LGFormat; compress=true)
</code></pre>

<p>Save a dictionary of <code>graphname =&gt; graph</code> to <code>file</code> in the format <code>format</code>. If <code>compress = true</code>, use GZip compression when writing the file. Return the number of graphs written.</p>
<p><strong>Implementation Notes</strong></p>
<p>Will only work if the file format supports multiple graph types.</p>
<p><a target='_blank' href='https://github.com/JuliaLang/julia/tree/82e96382251a1e163860df03c846acec86d07c36/base/docs/Docs.jl#L66-L75' class='documenter-source'>source</a><br></p>
<p><a id='LightGraphs.saw-Tuple{LightGraphs.AbstractGraph,Integer,Integer}' href='#LightGraphs.saw-Tuple{LightGraphs.AbstractGraph,Integer,Integer}'>#</a>
<strong><code>LightGraphs.saw</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>saw(g, s, niter)
</code></pre>

<p>Perform a <a href="https://en.wikipedia.org/wiki/Self-avoiding_walk">self-avoiding walk</a> on graph <code>g</code> starting at vertex <code>s</code> and continuing for a maximum of <code>niter</code> steps. Return a vector of vertices visited in order.</p>
<p><a target='_blank' href='https://github.com/JuliaLang/julia/tree/82e96382251a1e163860df03c846acec86d07c36/base/docs/Docs.jl#L93-L98' class='documenter-source'>source</a><br></p>
<p><a id='LightGraphs.simplecycles' href='#LightGraphs.simplecycles'>#</a>
<strong><code>LightGraphs.simplecycles</code></strong> &mdash; <em>Function</em>.</p>
<pre><code>simplecycles(dg::::IsDirected)
</code></pre>

<p>Compute all cycles of the given directed graph, using <a href="../Johnson">Johnson, 1973</a>'s algorithm and return them.</p>
<p>/! The number of cycles grow more than exponentially with the number of vertices, you might want to use the algorithm with a ceiling – <code>getcycles</code> – on large directed graphs (slightly slower). If you want to have an idea of the possible number of cycles, look at function <code>maxsimplecycles(dg::DiGraph, byscc::Bool = true)</code>.</p>
<p><strong>References</strong></p>
<ul>
<li><a href="http://epubs.siam.org/doi/abs/10.1137/0204007">Johnson</a></li>
</ul>
<p><a target='_blank' href='https://github.com/JuliaLang/julia/tree/82e96382251a1e163860df03c846acec86d07c36/base/docs/Docs.jl#L159' class='documenter-source'>source</a><br></p>
<p><a id='LightGraphs.simplecycles_hadwick_james' href='#LightGraphs.simplecycles_hadwick_james'>#</a>
<strong><code>LightGraphs.simplecycles_hadwick_james</code></strong> &mdash; <em>Function</em>.</p>
<pre><code>simplecycles_hadwick_james(g)
</code></pre>

<p>Find circuits (including self-loops) in <code>g</code> using the algorithm of Hadwick &amp; James.</p>
<p><strong>References</strong></p>
<ul>
<li>Hadwick &amp; James, "Enumerating Circuits and Loops in Graphs with Self-Arcs and Multiple-Arcs", 2008</li>
</ul>
<p><a target='_blank' href='https://github.com/JuliaLang/julia/tree/82e96382251a1e163860df03c846acec86d07c36/base/docs/Docs.jl#L1-L9' class='documenter-source'>source</a><br></p>
<p><a id='LightGraphs.simplecycles_iter' href='#LightGraphs.simplecycles_iter'>#</a>
<strong><code>LightGraphs.simplecycles_iter</code></strong> &mdash; <em>Function</em>.</p>
<pre><code>simplecycles_iter(dg::DiGraph, ceiling = 10^6)
</code></pre>

<p>Search all cycles of the given directed graph, using <a href="../Johnson">Johnson, 1973</a>'s algorithm, up to the ceiling (avoid memory overload).</p>
<p>If the graph is small, the ceiling will not be reached and $simplecycles(dg::DiGraph)$ is more efficient. It avoids the overhead of the counting and testing if the ceiling is reached. It returns all the cycles of the directed graph if the <code>ceiling</code> is not reached, a subset of them otherwise.</p>
<p>To get an idea of the possible number of cycles, using function <code>maxsimplecycles(dg::DiGraph, byscc::Bool = true)</code> on the directed graph.</p>
<p><strong>References</strong></p>
<ul>
<li><a href="http://epubs.siam.org/doi/abs/10.1137/0204007">Johnson</a></li>
</ul>
<p><a target='_blank' href='https://github.com/JuliaLang/julia/tree/82e96382251a1e163860df03c846acec86d07c36/base/docs/Docs.jl#L296' class='documenter-source'>source</a><br></p>
<p><a id='LightGraphs.simplecyclescount' href='#LightGraphs.simplecyclescount'>#</a>
<strong><code>LightGraphs.simplecyclescount</code></strong> &mdash; <em>Function</em>.</p>
<pre><code>simplecyclescount(dg::DiGraph, ceiling = 10^6)
</code></pre>

<p>Count the number of cycles in a directed graph, using <a href="../Johnson">Johnson, 1973</a>'s algorithm.</p>
<p>The <code>ceiling</code> is here to avoid memory overload if there are a lot of cycles in the graph. Default value is 10^6, but it can be higher or lower. You can use the function <code>maxsimplecycles(dg::DiGraph, byscc::Bool = true)</code> to get an idea of the theoretical maximum number or cycles.</p>
<p>Returns the minimum of the ceiling and the number of cycles.</p>
<p><strong>References</strong></p>
<ul>
<li><a href="http://epubs.siam.org/doi/abs/10.1137/0204007">Johnson</a></li>
</ul>
<p><a target='_blank' href='https://github.com/JuliaLang/julia/tree/82e96382251a1e163860df03c846acec86d07c36/base/docs/Docs.jl#L271' class='documenter-source'>source</a><br></p>
<p><a id='LightGraphs.simplecycleslength' href='#LightGraphs.simplecycleslength'>#</a>
<strong><code>LightGraphs.simplecycleslength</code></strong> &mdash; <em>Function</em>.</p>
<pre><code>simplecycleslength(dg::DiGraph, ceiling = 10^6)
</code></pre>

<p>Search all cycles of the given directed graph, using <a href="../Johnson">Johnson, 1973</a>'s algorithm, and return their length.</p>
<p>To get an idea of the possible number of cycles, using function <code>maxsimplecycles(dg::DiGraph, byscc::Bool = true)</code> on the directed graph.</p>
<p>It returns <code>cyclelengths</code> and <code>ncycles</code>, the lengths of all cycles and the  number of cycles. The index in the array is the length of the cycle.  If the <code>ceiling</code> is reached (<code>ncycles = ceiling</code>), the output is only a subset of the cycles lengths.</p>
<p><strong>References</strong></p>
<ul>
<li><a href="http://epubs.siam.org/doi/abs/10.1137/0204007">Johnson</a></li>
</ul>
<p><a target='_blank' href='https://github.com/JuliaLang/julia/tree/82e96382251a1e163860df03c846acec86d07c36/base/docs/Docs.jl#L317' class='documenter-source'>source</a><br></p>
<p><a id='LightGraphs.smallgraph-Tuple{Symbol}' href='#LightGraphs.smallgraph-Tuple{Symbol}'>#</a>
<strong><code>LightGraphs.smallgraph</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>smallgraph(s)
smallgraph(s)
</code></pre>

<p>Create a small graph of type <code>s</code>. Admissible values for <code>s</code> are:</p>
<table>
<thead>
<tr>
<th align="left"><code>s</code></th>
<th align="left">graph type</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left">:bull</td>
<td align="left">A <a href="https://en.wikipedia.org/wiki/Bull_graph">bull graph</a>.</td>
</tr>
<tr>
<td align="left">:chvatal</td>
<td align="left">A <a href="https://en.wikipedia.org/wiki/Chvátal_graph">Chvátal graph</a>.</td>
</tr>
<tr>
<td align="left">:cubical</td>
<td align="left">A <a href="https://en.wikipedia.org/wiki/Platonic_graph">Platonic cubical graph</a>.</td>
</tr>
<tr>
<td align="left">:desargues</td>
<td align="left">A <a href="https://en.wikipedia.org/wiki/Desargues_graph">Desarguesgraph</a>.</td>
</tr>
<tr>
<td align="left">:diamond</td>
<td align="left">A <a href="http://en.wikipedia.org/wiki/Diamond_graph">diamond graph</a>.</td>
</tr>
<tr>
<td align="left">:dodecahedral</td>
<td align="left">A <a href="https://en.wikipedia.org/wiki/Platonic_graph">Platonic dodecahedral  graph</a>.</td>
</tr>
<tr>
<td align="left">:frucht</td>
<td align="left">A <a href="https://en.wikipedia.org/wiki/Frucht_graph">Frucht graph</a>.</td>
</tr>
<tr>
<td align="left">:heawood</td>
<td align="left">A <a href="https://en.wikipedia.org/wiki/Heawood_graph">Heawood graph</a>.</td>
</tr>
<tr>
<td align="left">:house</td>
<td align="left">A graph mimicing the classic outline of a house.</td>
</tr>
<tr>
<td align="left">:housex</td>
<td align="left">A house graph, with two edges crossing the bottom square.</td>
</tr>
<tr>
<td align="left">:icosahedral</td>
<td align="left">A <a href="https://en.wikipedia.org/wiki/Platonic_graph">Platonic icosahedral   graph</a>.</td>
</tr>
<tr>
<td align="left">:krackhardtkite</td>
<td align="left">A <a href="http://mathworld.wolfram.com/KrackhardtKite.html">Krackhardt-Kite social network  graph</a>.</td>
</tr>
<tr>
<td align="left">:moebiuskantor</td>
<td align="left">A <a href="http://en.wikipedia.org/wiki/Möbius–Kantor_graph">Möbius-Kantor graph</a>.</td>
</tr>
<tr>
<td align="left">:octahedral</td>
<td align="left">A <a href="https://en.wikipedia.org/wiki/Platonic_graph">Platonic octahedral graph</a>.</td>
</tr>
<tr>
<td align="left">:pappus</td>
<td align="left">A <a href="http://en.wikipedia.org/wiki/Pappus_graph">Pappus graph</a>.</td>
</tr>
<tr>
<td align="left">:petersen</td>
<td align="left">A <a href="http://en.wikipedia.org/wiki/Petersen_graph">Petersen graph</a>.</td>
</tr>
<tr>
<td align="left">:sedgewickmaze</td>
<td align="left">A simple maze graph used in Sedgewick's <em>Algorithms in C++: Graph  Algorithms (3rd ed.)</em></td>
</tr>
<tr>
<td align="left">:tetrahedral</td>
<td align="left">A <a href="https://en.wikipedia.org/wiki/Platonic_graph">Platonic tetrahedral  graph</a>.</td>
</tr>
<tr>
<td align="left">:truncatedcube</td>
<td align="left">A skeleton of the <a href="https://en.wikipedia.org/wiki/Truncated_cube">truncated cube graph</a>.</td>
</tr>
<tr>
<td align="left">:truncatedtetrahedron</td>
<td align="left">A skeleton of the <a href="https://en.wikipedia.org/wiki/Truncated_tetrahedron">truncated tetrahedron  graph</a>.</td>
</tr>
<tr>
<td align="left">:truncatedtetrahedron_dir</td>
<td align="left">A skeleton of the <a href="https://en.wikipedia.org/wiki/Truncated_tetrahedron">truncated tetrahedron digraph</a>.</td>
</tr>
<tr>
<td align="left">:tutte</td>
<td align="left">A <a href="https://en.wikipedia.org/wiki/Tutte_graph">Tutte graph</a>.</td>
</tr>
</tbody>
</table>
<p><a target='_blank' href='https://github.com/JuliaLang/julia/tree/82e96382251a1e163860df03c846acec86d07c36/base/docs/Docs.jl#L21' class='documenter-source'>source</a><br></p>
<p><a id='LightGraphs.spectral_distance' href='#LightGraphs.spectral_distance'>#</a>
<strong><code>LightGraphs.spectral_distance</code></strong> &mdash; <em>Function</em>.</p>
<pre><code>spectral_distance(G₁, G₂ [, k])
</code></pre>

<p>Compute the spectral distance between undirected n-vertex graphs <code>G₁</code> and <code>G₂</code> using the top <code>k</code> greatest eigenvalues. If <code>k</code> is ommitted, uses full spectrum.</p>
<p><strong>References</strong></p>
<ul>
<li>JOVANOVIC, I.; STANIC, Z., 2014. Spectral Distances of Graphs Based on their Different Matrix Representations</li>
</ul>
<p><a target='_blank' href='https://github.com/JuliaLang/julia/tree/82e96382251a1e163860df03c846acec86d07c36/base/docs/Docs.jl#L163' class='documenter-source'>source</a><br></p>
<p><a id='LightGraphs.squash-Tuple{LightGraphs.AbstractGraph}' href='#LightGraphs.squash-Tuple{LightGraphs.AbstractGraph}'>#</a>
<strong><code>LightGraphs.squash</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>squash(g)
</code></pre>

<p>Return a copy of a graph with the smallest practical type that can accommodate all vertices.</p>
<p><a target='_blank' href='https://github.com/JuliaLang/julia/tree/82e96382251a1e163860df03c846acec86d07c36/base/docs/Docs.jl#L194-L199' class='documenter-source'>source</a><br></p>
<p><a id='LightGraphs.src-Tuple{LightGraphs.AbstractEdge}' href='#LightGraphs.src-Tuple{LightGraphs.AbstractEdge}'>#</a>
<strong><code>LightGraphs.src</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>src(e)
</code></pre>

<p>Return the source vertex of edge <code>e</code>.</p>
<p><a target='_blank' href='https://github.com/JuliaLang/julia/tree/82e96382251a1e163860df03c846acec86d07c36/base/docs/Docs.jl#L35-L39' class='documenter-source'>source</a><br></p>
<p><a id='LightGraphs.static_fitness_model-Union{Tuple{Integer,Array{T,1},Array{S,1}}, Tuple{S}, Tuple{T}} where T<:Real where S<:Real' href='#LightGraphs.static_fitness_model-Union{Tuple{Integer,Array{T,1},Array{S,1}}, Tuple{S}, Tuple{T}} where T<:Real where S<:Real'>#</a>
<strong><code>LightGraphs.static_fitness_model</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>static_fitness_model(m, fitness_out, fitness_in)
</code></pre>

<p>Generate a random graph with $|fitness_out + fitness_in|$ vertices and <code>m</code> edges, in which the probability of the existence of $Edge_{ij}$ is proportional with respect to $i ∝ fitness_out$ and $j ∝ fitness_in$.</p>
<p><strong>Optional Arguments</strong></p>
<ul>
<li><code>seed=-1</code>: set the RNG seed.</li>
</ul>
<p><strong>Performance</strong></p>
<p>Time complexity is $\mathcal{O}(|V| + |E| log |E|)$.</p>
<p><strong>References</strong></p>
<ul>
<li>Goh K-I, Kahng B, Kim D: Universal behaviour of load distribution in scale-free networks. Phys Rev Lett 87(27):278701, 2001.</li>
</ul>
<p><a target='_blank' href='https://github.com/JuliaLang/julia/tree/82e96382251a1e163860df03c846acec86d07c36/base/docs/Docs.jl#L341' class='documenter-source'>source</a><br></p>
<p><a id='LightGraphs.static_fitness_model-Union{Tuple{Integer,Array{T,1}}, Tuple{T}} where T<:Real' href='#LightGraphs.static_fitness_model-Union{Tuple{Integer,Array{T,1}}, Tuple{T}} where T<:Real'>#</a>
<strong><code>LightGraphs.static_fitness_model</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>static_fitness_model(m, fitness)
</code></pre>

<p>Generate a random graph with $|fitness|$ vertices and <code>m</code> edges, in which the probability of the existence of $Edge_{ij}$ is proportional to $fitness_i  × fitness_j$.</p>
<p><strong>Optional Arguments</strong></p>
<ul>
<li><code>seed=-1</code>: set the RNG seed.</li>
</ul>
<p><strong>Performance</strong></p>
<p>Time complexity is $\mathcal{O}(|V| + |E| log |E|)$.</p>
<p><strong>References</strong></p>
<ul>
<li>Goh K-I, Kahng B, Kim D: Universal behaviour of load distribution in scale-free networks. Phys Rev Lett 87(27):278701, 2001.</li>
</ul>
<p><a target='_blank' href='https://github.com/JuliaLang/julia/tree/82e96382251a1e163860df03c846acec86d07c36/base/docs/Docs.jl#L305' class='documenter-source'>source</a><br></p>
<p><a id='LightGraphs.static_scale_free-Tuple{Integer,Integer,Real,Float64}' href='#LightGraphs.static_scale_free-Tuple{Integer,Integer,Real,Float64}'>#</a>
<strong><code>LightGraphs.static_scale_free</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>static_scale_free(n, m, α_out, α_in)
</code></pre>

<p>Generate a random graph with <code>n</code> vertices, <code>m</code> edges and expected power-law degree distribution with exponent <code>α_out</code> for outbound edges and <code>α_in</code> for inbound edges.</p>
<p><strong>Optional Arguments</strong></p>
<ul>
<li><code>seed=-1</code>: set the RNG seed.</li>
<li><code>finite_size_correction=true</code>: determines whether to use the finite size correction</li>
</ul>
<p>proposed by Cho et al.</p>
<p><strong>Performance</strong></p>
<p>Time complexity is $\mathcal{O}(|V| + |E| log |E|)$.</p>
<p><strong>References</strong></p>
<ul>
<li>Goh K-I, Kahng B, Kim D: Universal behaviour of load distribution in scale-free networks. Phys Rev Lett 87(27):278701, 2001.</li>
<li>Chung F and Lu L: Connected components in a random graph with given degree sequences. Annals of Combinatorics 6, 125-145, 2002.</li>
<li>Cho YS, Kim JS, Park J, Kahng B, Kim D: Percolation transitions in scale-free networks under the Achlioptas process. Phys Rev Lett 103:135702, 2009.</li>
</ul>
<p><a target='_blank' href='https://github.com/JuliaLang/julia/tree/82e96382251a1e163860df03c846acec86d07c36/base/docs/Docs.jl#L423' class='documenter-source'>source</a><br></p>
<p><a id='LightGraphs.static_scale_free-Tuple{Integer,Integer,Real}' href='#LightGraphs.static_scale_free-Tuple{Integer,Integer,Real}'>#</a>
<strong><code>LightGraphs.static_scale_free</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>static_scale_free(n, m, α)
</code></pre>

<p>Generate a random graph with <code>n</code> vertices, <code>m</code> edges and expected power-law degree distribution with exponent <code>α</code>.</p>
<p><strong>Optional Arguments</strong></p>
<ul>
<li><code>seed=-1</code>: set the RNG seed.</li>
<li><code>finite_size_correction=true</code>: determines whether to use the finite size correction</li>
</ul>
<p>proposed by Cho et al.</p>
<p><strong>Performance</strong></p>
<p>Time complexity is $\mathcal{O}(|V| + |E| log |E|)$.</p>
<p><strong>References</strong></p>
<ul>
<li>Goh K-I, Kahng B, Kim D: Universal behaviour of load distribution in scale-free networks. Phys Rev Lett 87(27):278701, 2001.</li>
<li>Chung F and Lu L: Connected components in a random graph with given degree sequences. Annals of Combinatorics 6, 125-145, 2002.</li>
<li>Cho YS, Kim JS, Park J, Kahng B, Kim D: Percolation transitions in scale-free networks under the Achlioptas process. Phys Rev Lett 103:135702, 2009.</li>
</ul>
<p><a target='_blank' href='https://github.com/JuliaLang/julia/tree/82e96382251a1e163860df03c846acec86d07c36/base/docs/Docs.jl#L397' class='documenter-source'>source</a><br></p>
<p><a id='LightGraphs.stochastic_block_model-Union{Tuple{Array{T,2},Array{U,1}}, Tuple{T}, Tuple{U}} where T<:Real where U<:Integer' href='#LightGraphs.stochastic_block_model-Union{Tuple{Array{T,2},Array{U,1}}, Tuple{T}, Tuple{U}} where T<:Real where U<:Integer'>#</a>
<strong><code>LightGraphs.stochastic_block_model</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>stochastic_block_model(c, n)
</code></pre>

<p>Return a Graph generated according to the Stochastic Block Model (SBM).</p>
<p><code>c[a,b]</code> : Mean number of neighbors of a vertex in block <code>a</code> belonging to block <code>b</code>.            Only the upper triangular part is considered, since the lower traingular is            determined by $c[b,a] = c[a,b] * \frac{n[a]}{n[b]}$. <code>n[a]</code> : Number of vertices in block <code>a</code></p>
<p><strong>Optional Arguments</strong></p>
<ul>
<li><code>seed=-1</code>: set the RNG seed.</li>
</ul>
<p>For a dynamic version of the SBM see the <a href="./#LightGraphs.StochasticBlockModel"><code>StochasticBlockModel</code></a> type and related functions.</p>
<p><a target='_blank' href='https://github.com/JuliaLang/julia/tree/82e96382251a1e163860df03c846acec86d07c36/base/docs/Docs.jl#L597' class='documenter-source'>source</a><br></p>
<p><a id='LightGraphs.stochastic_block_model-Union{Tuple{T,T,Array{U,1}}, Tuple{T}, Tuple{U}} where T<:Real where U<:Integer' href='#LightGraphs.stochastic_block_model-Union{Tuple{T,T,Array{U,1}}, Tuple{T}, Tuple{U}} where T<:Real where U<:Integer'>#</a>
<strong><code>LightGraphs.stochastic_block_model</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>stochastic_block_model(cint, cext, n)
</code></pre>

<p>Return a Graph generated according to the Stochastic Block Model (SBM), sampling from an SBM with $c_{a,a}=cint$, and $c_{a,b}=cext$.</p>
<p><a target='_blank' href='https://github.com/JuliaLang/julia/tree/82e96382251a1e163860df03c846acec86d07c36/base/docs/Docs.jl#L647' class='documenter-source'>source</a><br></p>
<p><a id='LightGraphs.symmetric_difference-Union{Tuple{T,T}, Tuple{T}} where T<:LightGraphs.AbstractGraph' href='#LightGraphs.symmetric_difference-Union{Tuple{T,T}, Tuple{T}} where T<:LightGraphs.AbstractGraph'>#</a>
<strong><code>LightGraphs.symmetric_difference</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>symmetric_difference(g, h)
</code></pre>

<p>Return a graph with edges from graph <code>g</code> that do not exist in graph <code>h</code>, and vice versa.</p>
<p><strong>Implementation Notes</strong></p>
<p>Note that this function may produce a graph with 0-degree vertices. Preserves the eltype of the input graph. Will error if the number of vertices in the generated graph exceeds the eltype.</p>
<p><a target='_blank' href='https://github.com/JuliaLang/julia/tree/82e96382251a1e163860df03c846acec86d07c36/base/docs/Docs.jl#L127-L137' class='documenter-source'>source</a><br></p>
<p><a id='LightGraphs.tensor_product-Union{Tuple{G,G}, Tuple{G}} where G<:LightGraphs.AbstractGraph' href='#LightGraphs.tensor_product-Union{Tuple{G,G}, Tuple{G}} where G<:LightGraphs.AbstractGraph'>#</a>
<strong><code>LightGraphs.tensor_product</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>tensor_product(g, h)
</code></pre>

<p>Return the (tensor product)[https://en.wikipedia.org/wiki/Tensor_product_of_graphs] of <code>g</code> and <code>h</code>.</p>
<p><strong>Implementation Notes</strong></p>
<p>Preserves the eltype of the input graph. Will error if the number of vertices in the generated graph exceeds the eltype.</p>
<p><a target='_blank' href='https://github.com/JuliaLang/julia/tree/82e96382251a1e163860df03c846acec86d07c36/base/docs/Docs.jl#L316-L325' class='documenter-source'>source</a><br></p>
<p><a id='LightGraphs.transitiveclosure' href='#LightGraphs.transitiveclosure'>#</a>
<strong><code>LightGraphs.transitiveclosure</code></strong> &mdash; <em>Function</em>.</p>
<pre><code>transitiveclosure(g, selflooped=false)
</code></pre>

<p>Compute the transitive closure of a directed graph, using the Floyd-Warshall algorithm. Return a graph representing the transitive closure. If <code>selflooped</code> is <code>true</code>, add self loops to the graph.</p>
<p><strong>Performance</strong></p>
<p>Time complexity is \mathcal{O}(|V|^3).</p>
<p><a target='_blank' href='https://github.com/JuliaLang/julia/tree/82e96382251a1e163860df03c846acec86d07c36/base/docs/Docs.jl#L31-L40' class='documenter-source'>source</a><br></p>
<p><a id='LightGraphs.transitiveclosure!' href='#LightGraphs.transitiveclosure!'>#</a>
<strong><code>LightGraphs.transitiveclosure!</code></strong> &mdash; <em>Function</em>.</p>
<pre><code>transitiveclosure!(g, selflooped=false)
</code></pre>

<p>Compute the transitive closure of a directed graph, using the Floyd-Warshall algorithm. If <code>selflooped</code> is true, add self loops to the graph.</p>
<p><strong>Performance</strong></p>
<p>Time complexity is \mathcal{O}(|V|^3).</p>
<p><strong>Implementation Notes</strong></p>
<p>This version of the function modifies the original graph.</p>
<p><a target='_blank' href='https://github.com/JuliaLang/julia/tree/82e96382251a1e163860df03c846acec86d07c36/base/docs/Docs.jl#L1' class='documenter-source'>source</a><br></p>
<p><a id='LightGraphs.triangles-Tuple{LightGraphs.AbstractGraph,Integer}' href='#LightGraphs.triangles-Tuple{LightGraphs.AbstractGraph,Integer}'>#</a>
<strong><code>LightGraphs.triangles</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>triangles(g[, v])
triangles(g, vs)
</code></pre>

<p>Return the number of triangles in the neighborhood of node <code>v</code> in graph <code>g</code>. If a list of vertices <code>vs</code> is specified, return a vector of number of triangles for each node in the list. If no vertices are specified, return the number of triangles for each node in the graph.</p>
<p><a target='_blank' href='https://github.com/JuliaLang/julia/tree/82e96382251a1e163860df03c846acec86d07c36/base/docs/Docs.jl#L53-L61' class='documenter-source'>source</a><br></p>
<p><a id='LightGraphs.vertices-Tuple{LightGraphs.AbstractGraph}' href='#LightGraphs.vertices-Tuple{LightGraphs.AbstractGraph}'>#</a>
<strong><code>LightGraphs.vertices</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>vertices(g)
</code></pre>

<p>Return (an iterator to or collection of) the vertices of a graph.</p>
<p><strong>Implementation Notes</strong></p>
<p>A returned iterator is valid for one pass over the edges, and is invalidated by changes to <code>g</code>.</p>
<p><a target='_blank' href='https://github.com/JuliaLang/julia/tree/82e96382251a1e163860df03c846acec86d07c36/base/docs/Docs.jl#L93-L102' class='documenter-source'>source</a><br></p>
<p><a id='LightGraphs.watts_strogatz-Tuple{Integer,Integer,Real}' href='#LightGraphs.watts_strogatz-Tuple{Integer,Integer,Real}'>#</a>
<strong><code>LightGraphs.watts_strogatz</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>watts_strogatz(n, k, β)
</code></pre>

<p>Return a <a href="https://en.wikipedia.org/wiki/Watts_and_Strogatz_model">Watts-Strogatz</a> small model random graph with <code>n</code> vertices, each with degree <code>k</code>. Edges are randomized per the model based on probability <code>β</code>.</p>
<p><strong>Optional Arguments</strong></p>
<ul>
<li><code>is_directed=false</code>: if true, return a directed graph.</li>
<li><code>seed=-1</code>: set the RNG seed.</li>
</ul>
<p><a target='_blank' href='https://github.com/JuliaLang/julia/tree/82e96382251a1e163860df03c846acec86d07c36/base/docs/Docs.jl#L88-L98' class='documenter-source'>source</a><br></p>
<p><a id='LightGraphs.yen_k_shortest_paths-Union{Tuple{LightGraphs.AbstractGraph,U,U,AbstractArray{T,2},Int64}, Tuple{LightGraphs.AbstractGraph,U,U,AbstractArray{T,2}}, Tuple{LightGraphs.AbstractGraph,U,U}, Tuple{T}, Tuple{U}} where T<:Real where U<:Integer' href='#LightGraphs.yen_k_shortest_paths-Union{Tuple{LightGraphs.AbstractGraph,U,U,AbstractArray{T,2},Int64}, Tuple{LightGraphs.AbstractGraph,U,U,AbstractArray{T,2}}, Tuple{LightGraphs.AbstractGraph,U,U}, Tuple{T}, Tuple{U}} where T<:Real where U<:Integer'>#</a>
<strong><code>LightGraphs.yen_k_shortest_paths</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>yen_k_shortest_paths(g, source, target, distmx=DefaultDistance(), K=1; maxdist=Inf);
</code></pre>

<p>Perform <a href="http://en.wikipedia.org/wiki/Yen%27s_algorithm">Yen's algorithm</a> on a graph, computing k-shortest distances between <code>source</code> and <code>target</code> other vertices. Return a <a href="./#LightGraphs.YenState"><code>YenState</code></a> that contains distances and paths.</p>
<p><a target='_blank' href='https://github.com/JuliaLang/julia/tree/82e96382251a1e163860df03c846acec86d07c36/base/docs/Docs.jl#L12-L18' class='documenter-source'>source</a><br></p>
<p><a id='LightGraphs.Δ-Tuple{Any}' href='#LightGraphs.Δ-Tuple{Any}'>#</a>
<strong><code>LightGraphs.Δ</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>Δ(g)
</code></pre>

<p>Return the maximum <a href="./#LightGraphs.degree"><code>degree</code></a> of vertices in <code>g</code>.</p>
<p><a target='_blank' href='https://github.com/JuliaLang/julia/tree/82e96382251a1e163860df03c846acec86d07c36/base/docs/Docs.jl#L78-L82' class='documenter-source'>source</a><br></p>
<p><a id='LightGraphs.Δin-Tuple{Any}' href='#LightGraphs.Δin-Tuple{Any}'>#</a>
<strong><code>LightGraphs.Δin</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>Δin(g)
</code></pre>

<p>Return the maximum <a href="./#LightGraphs.indegree-Tuple{LightGraphs.AbstractGraph,Integer}"><code>indegree</code></a> of vertices in <code>g</code>.</p>
<p><a target='_blank' href='https://github.com/JuliaLang/julia/tree/82e96382251a1e163860df03c846acec86d07c36/base/docs/Docs.jl#L64-L68' class='documenter-source'>source</a><br></p>
<p><a id='LightGraphs.Δout-Tuple{Any}' href='#LightGraphs.Δout-Tuple{Any}'>#</a>
<strong><code>LightGraphs.Δout</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>Δout(g)
</code></pre>

<p>Return the maximum <a href="./#LightGraphs.outdegree-Tuple{LightGraphs.AbstractGraph,Integer}"><code>outdegree</code></a> of vertices in <code>g</code>.</p>
<p><a target='_blank' href='https://github.com/JuliaLang/julia/tree/82e96382251a1e163860df03c846acec86d07c36/base/docs/Docs.jl#L51-L55' class='documenter-source'>source</a><br></p>
<p><a id='LightGraphs.δ-Tuple{Any}' href='#LightGraphs.δ-Tuple{Any}'>#</a>
<strong><code>LightGraphs.δ</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>δ(g)
</code></pre>

<p>Return the minimum <a href="./#LightGraphs.degree"><code>degree</code></a> of vertices in <code>g</code>.</p>
<p><a target='_blank' href='https://github.com/JuliaLang/julia/tree/82e96382251a1e163860df03c846acec86d07c36/base/docs/Docs.jl#L85-L88' class='documenter-source'>source</a><br></p>
<p><a id='LightGraphs.δin-Tuple{Any}' href='#LightGraphs.δin-Tuple{Any}'>#</a>
<strong><code>LightGraphs.δin</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>δin(g)
</code></pre>

<p>Return the minimum <a href="../ref"><code>indegree</code></a> of vertices in <code>g</code>.</p>
<p><a target='_blank' href='https://github.com/JuliaLang/julia/tree/82e96382251a1e163860df03c846acec86d07c36/base/docs/Docs.jl#L71-L75' class='documenter-source'>source</a><br></p>
<p><a id='LightGraphs.δout-Tuple{Any}' href='#LightGraphs.δout-Tuple{Any}'>#</a>
<strong><code>LightGraphs.δout</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>δout(g)
</code></pre>

<p>Return the minimum <a href="./#LightGraphs.outdegree-Tuple{LightGraphs.AbstractGraph,Integer}"><code>outdegree</code></a> of vertices in <code>g</code>.</p>
<p><a target='_blank' href='https://github.com/JuliaLang/julia/tree/82e96382251a1e163860df03c846acec86d07c36/base/docs/Docs.jl#L57-L61' class='documenter-source'>source</a><br></p>
<p><a id='LightGraphs.Articulations' href='#LightGraphs.Articulations'>#</a>
<strong><code>LightGraphs.Articulations</code></strong> &mdash; <em>Type</em>.</p>
<pre><code>Articulations{T}
</code></pre>

<p>A state type for the depth-first search that finds the articulation points in a graph.</p>
<p><a target='_blank' href='https://github.com/JuliaLang/julia/tree/82e96382251a1e163860df03c846acec86d07c36/base/docs/Docs.jl#L1-L5' class='documenter-source'>source</a><br></p>
<p><a id='LightGraphs.BellmanFordState' href='#LightGraphs.BellmanFordState'>#</a>
<strong><code>LightGraphs.BellmanFordState</code></strong> &mdash; <em>Type</em>.</p>
<pre><code>BellmanFordState{T, U}
</code></pre>

<p>An <code>AbstractPathState</code> designed for Bellman-Ford shortest-paths calculations.</p>
<p><a target='_blank' href='https://github.com/JuliaLang/julia/tree/82e96382251a1e163860df03c846acec86d07c36/base/docs/Docs.jl#L15-L19' class='documenter-source'>source</a><br></p>
<p><a id='LightGraphs.ComponentVisitorVector' href='#LightGraphs.ComponentVisitorVector'>#</a>
<strong><code>LightGraphs.ComponentVisitorVector</code></strong> &mdash; <em>Type</em>.</p>
<pre><code>ComponentVisitorVector{T}
</code></pre>

<p>A type of <code>AbstractGraphVisitor</code> that represents connected components with BFS starting from a given seed.</p>
<p><a target='_blank' href='https://github.com/JuliaLang/julia/tree/82e96382251a1e163860df03c846acec86d07c36/base/docs/Docs.jl#L167-L172' class='documenter-source'>source</a><br></p>
<p><a id='LightGraphs.DefaultCapacity' href='#LightGraphs.DefaultCapacity'>#</a>
<strong><code>LightGraphs.DefaultCapacity</code></strong> &mdash; <em>Type</em>.</p>
<pre><code>DefaultCapacity{T}
</code></pre>

<p>Structure that returns <code>1</code> if a forward edge exists in <code>flow_graph</code>, and <code>0</code> otherwise.</p>
<p><a target='_blank' href='https://github.com/JuliaLang/julia/tree/82e96382251a1e163860df03c846acec86d07c36/base/docs/Docs.jl#L34-L38' class='documenter-source'>source</a><br></p>
<p><a id='LightGraphs.DijkstraState' href='#LightGraphs.DijkstraState'>#</a>
<strong><code>LightGraphs.DijkstraState</code></strong> &mdash; <em>Type</em>.</p>
<pre><code>struct DijkstraState{T, U}
</code></pre>

<p>An <a href="../@ref"><code>AbstractPathState</code></a> designed for Dijkstra shortest-paths calculations.</p>
<p><a target='_blank' href='https://github.com/JuliaLang/julia/tree/82e96382251a1e163860df03c846acec86d07c36/base/docs/Docs.jl#L8-L12' class='documenter-source'>source</a><br></p>
<p><a id='LightGraphs.FloydWarshallState' href='#LightGraphs.FloydWarshallState'>#</a>
<strong><code>LightGraphs.FloydWarshallState</code></strong> &mdash; <em>Type</em>.</p>
<pre><code>struct FloydWarshallState{T, U}
</code></pre>

<p>An <a href="../@ref"><code>AbstractPathState</code></a> designed for Floyd-Warshall shortest-paths calculations.</p>
<p><a target='_blank' href='https://github.com/JuliaLang/julia/tree/82e96382251a1e163860df03c846acec86d07c36/base/docs/Docs.jl#L5-L9' class='documenter-source'>source</a><br></p>
<p><a id='LightGraphs.JohnsonVisitor' href='#LightGraphs.JohnsonVisitor'>#</a>
<strong><code>LightGraphs.JohnsonVisitor</code></strong> &mdash; <em>Type</em>.</p>
<pre><code>type JohnsonVisitor{T&lt;:Integer} &lt;: Visitor{T}
    stack::Vector{T}
    blocked::BitArray
    blockedmap::Vector{Set{T}}
end
</code></pre>

<p>Composite type that regroups the information needed for Johnson's algorithm.</p>
<p><code>stack</code> is the stack of visited vertices. <code>blocked</code> is a boolean for each  vertex that tells whether it is blocked or not. <code>blockedmap</code> tells which  vertices to unblock if the key vertex is unblocked.</p>
<p><a target='_blank' href='https://github.com/JuliaLang/julia/tree/82e96382251a1e163860df03c846acec86d07c36/base/docs/Docs.jl#L58-L72' class='documenter-source'>source</a><br></p>
<p><a id='LightGraphs.JohnsonVisitor-Union{Tuple{LightGraphs.SimpleGraphs.SimpleDiGraph{T}}, Tuple{T}} where T<:Integer' href='#LightGraphs.JohnsonVisitor-Union{Tuple{LightGraphs.SimpleGraphs.SimpleDiGraph{T}}, Tuple{T}} where T<:Integer'>#</a>
<strong><code>LightGraphs.JohnsonVisitor</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>JohnsonVisitor(dg::::IsDirected)
</code></pre>

<p>Constructor of the visitor, using the directed graph information.</p>
<p><a target='_blank' href='https://github.com/JuliaLang/julia/tree/82e96382251a1e163860df03c846acec86d07c36/base/docs/Docs.jl#L79-L83' class='documenter-source'>source</a><br></p>
<p><a id='LightGraphs.NeighComm' href='#LightGraphs.NeighComm'>#</a>
<strong><code>LightGraphs.NeighComm</code></strong> &mdash; <em>Type</em>.</p>
<pre><code>NeighComm{T}
</code></pre>

<p>Type to record neighbor labels and their counts.</p>
<p><a target='_blank' href='https://github.com/JuliaLang/julia/tree/82e96382251a1e163860df03c846acec86d07c36/base/docs/Docs.jl#L49-L53' class='documenter-source'>source</a><br></p>
<p><a id='LightGraphs.ThreadQueue' href='#LightGraphs.ThreadQueue'>#</a>
<strong><code>LightGraphs.ThreadQueue</code></strong> &mdash; <em>Type</em>.</p>
<pre><code>ThreadQueue
</code></pre>

<p>A thread safe queue implementation for using as the queue for BFS.</p>
<p><a target='_blank' href='https://github.com/JuliaLang/julia/tree/82e96382251a1e163860df03c846acec86d07c36/base/docs/Docs.jl#L20-L24' class='documenter-source'>source</a><br></p>
<p><a id='LightGraphs.TreeBFSVisitorVector' href='#LightGraphs.TreeBFSVisitorVector'>#</a>
<strong><code>LightGraphs.TreeBFSVisitorVector</code></strong> &mdash; <em>Type</em>.</p>
<pre><code>TreeBFSVisitorVector{T}
</code></pre>

<p>A type for representing a BFS traversal of the graph as a parents array.</p>
<p><a target='_blank' href='https://github.com/JuliaLang/julia/tree/82e96382251a1e163860df03c846acec86d07c36/base/docs/Docs.jl#L90-L94' class='documenter-source'>source</a><br></p>
<p><a id='LightGraphs.YenState' href='#LightGraphs.YenState'>#</a>
<strong><code>LightGraphs.YenState</code></strong> &mdash; <em>Type</em>.</p>
<pre><code>struct YenState{T, U}
</code></pre>

<p>Designed for yen k-shortest-paths calculations.</p>
<p><a target='_blank' href='https://github.com/JuliaLang/julia/tree/82e96382251a1e163860df03c846acec86d07c36/base/docs/Docs.jl#L1-L5' class='documenter-source'>source</a><br></p>
<p><a id='LightGraphs.AbstractEdgeIter' href='#LightGraphs.AbstractEdgeIter'>#</a>
<strong><code>LightGraphs.AbstractEdgeIter</code></strong> &mdash; <em>Type</em>.</p>
<pre><code>AbstractEdgeIter
</code></pre>

<p>An abstract type representing an edge iterator.</p>
<p><a target='_blank' href='https://github.com/JuliaLang/julia/tree/82e96382251a1e163860df03c846acec86d07c36/base/docs/Docs.jl#L12-L16' class='documenter-source'>source</a><br></p>
<p><a id='LightGraphs.AbstractFlowAlgorithm' href='#LightGraphs.AbstractFlowAlgorithm'>#</a>
<strong><code>LightGraphs.AbstractFlowAlgorithm</code></strong> &mdash; <em>Type</em>.</p>
<pre><code>AbstractFlowAlgorithm
</code></pre>

<p>Abstract type that allows users to pass in their preferred algorithm</p>
<p><a target='_blank' href='https://github.com/JuliaLang/julia/tree/82e96382251a1e163860df03c846acec86d07c36/base/docs/Docs.jl#L1-L5' class='documenter-source'>source</a><br></p>
<p><a id='LightGraphs.AbstractMultirouteFlowAlgorithm' href='#LightGraphs.AbstractMultirouteFlowAlgorithm'>#</a>
<strong><code>LightGraphs.AbstractMultirouteFlowAlgorithm</code></strong> &mdash; <em>Type</em>.</p>
<pre><code>AbstractMultirouteFlowAlgorithm
</code></pre>

<p>Abstract type that allows users to pass in their preferred algorithm.</p>
<p><a target='_blank' href='https://github.com/JuliaLang/julia/tree/82e96382251a1e163860df03c846acec86d07c36/base/docs/Docs.jl#L1-L5' class='documenter-source'>source</a><br></p>
<p><a id='LightGraphs.Biconnections' href='#LightGraphs.Biconnections'>#</a>
<strong><code>LightGraphs.Biconnections</code></strong> &mdash; <em>Type</em>.</p>
<pre><code>Biconnections
</code></pre>

<p>A state type for depth-first search that finds the biconnected components.</p>
<p><a target='_blank' href='https://github.com/JuliaLang/julia/tree/82e96382251a1e163860df03c846acec86d07c36/base/docs/Docs.jl#L1-L5' class='documenter-source'>source</a><br></p>
<p><a id='Base.SparseArrays.sparse-Tuple{LightGraphs.AbstractGraph}' href='#Base.SparseArrays.sparse-Tuple{LightGraphs.AbstractGraph}'>#</a>
<strong><code>Base.SparseArrays.sparse</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>sparse(g)
</code></pre>

<p>Return the default adjacency matrix of <code>g</code>.</p>
<p><a target='_blank' href='https://github.com/JuliaLang/julia/tree/82e96382251a1e163860df03c846acec86d07c36/base/docs/Docs.jl#L274-L278' class='documenter-source'>source</a><br></p>
<p><a id='Base.eltype-Tuple{LightGraphs.AbstractGraph}' href='#Base.eltype-Tuple{LightGraphs.AbstractGraph}'>#</a>
<strong><code>Base.eltype</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>eltype(g)
</code></pre>

<p>Return the type of the graph's vertices (must be &lt;: Integer)</p>
<p><a target='_blank' href='https://github.com/JuliaLang/julia/tree/82e96382251a1e163860df03c846acec86d07c36/base/docs/Docs.jl#L72-L76' class='documenter-source'>source</a><br></p>
<p><a id='Base.getindex-Tuple{LightGraphs.AbstractGraph,Any}' href='#Base.getindex-Tuple{LightGraphs.AbstractGraph,Any}'>#</a>
<strong><code>Base.getindex</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>g[iter]
</code></pre>

<p>Return the subgraph induced by <code>iter</code>. Equivalent to <a href="./#LightGraphs.induced_subgraph-Union{Tuple{T,AbstractArray{U,1}}, Tuple{T}, Tuple{U}} where T&lt;:LightGraphs.AbstractGraph where U&lt;:Integer"><code>induced_subgraph</code></a><code>(g, iter)[1]</code>.</p>
<p><a target='_blank' href='https://github.com/JuliaLang/julia/tree/82e96382251a1e163860df03c846acec86d07c36/base/docs/Docs.jl#L424-L429' class='documenter-source'>source</a><br></p>
<p><a id='Base.size-Tuple{LightGraphs.SimpleGraphs.SimpleGraph,Int64}' href='#Base.size-Tuple{LightGraphs.SimpleGraphs.SimpleGraph,Int64}'>#</a>
<strong><code>Base.size</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>size(g, i)
</code></pre>

<p>Return the number of vertices in <code>g</code> if <code>i</code>=1 or <code>i</code>=2, or <code>1</code> otherwise.</p>
<p><a target='_blank' href='https://github.com/JuliaLang/julia/tree/82e96382251a1e163860df03c846acec86d07c36/base/docs/Docs.jl#L260-L264' class='documenter-source'>source</a><br></p>
<p><a id='Base.sum-Tuple{LightGraphs.AbstractGraph,Int64}' href='#Base.sum-Tuple{LightGraphs.AbstractGraph,Int64}'>#</a>
<strong><code>Base.sum</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>sum(g, i)
</code></pre>

<p>Return a vector of indegree (<code>i</code>=1) or outdegree (<code>i</code>=2) values for graph <code>g</code>.</p>
<p><a target='_blank' href='https://github.com/JuliaLang/julia/tree/82e96382251a1e163860df03c846acec86d07c36/base/docs/Docs.jl#L247-L251' class='documenter-source'>source</a><br></p>
<p><a id='Base.sum-Tuple{LightGraphs.AbstractGraph}' href='#Base.sum-Tuple{LightGraphs.AbstractGraph}'>#</a>
<strong><code>Base.sum</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>sum(g)
</code></pre>

<p>Return the number of edges in <code>g</code></p>
<p><a target='_blank' href='https://github.com/JuliaLang/julia/tree/82e96382251a1e163860df03c846acec86d07c36/base/docs/Docs.jl#L267-L271' class='documenter-source'>source</a><br></p>
<p><a id='Base.zero-Tuple{LightGraphs.AbstractGraph}' href='#Base.zero-Tuple{LightGraphs.AbstractGraph}'>#</a>
<strong><code>Base.zero</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>zero(g)
</code></pre>

<p>Return a zero-vertex, zero-edge version of the same type of graph as <code>g</code>.</p>
<p><a target='_blank' href='https://github.com/JuliaLang/julia/tree/82e96382251a1e163860df03c846acec86d07c36/base/docs/Docs.jl#L183-L187' class='documenter-source'>source</a><br></p>
<p><a id='LightGraphs.approximately_equal-Union{Tuple{T}, Tuple{Tuple{T,T},Tuple{T,T}}} where T<:AbstractFloat' href='#LightGraphs.approximately_equal-Union{Tuple{T}, Tuple{Tuple{T,T},Tuple{T,T}}} where T<:AbstractFloat'>#</a>
<strong><code>LightGraphs.approximately_equal</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>approximately_equal(a, b)
</code></pre>

<p>Return true if each element in the tuple is approximately equal to its counterpart.</p>
<p><strong>Implementation Notes:</strong></p>
<p>This is a separate function because we don't want to hijack isapprox for tuples.</p>
<p><a target='_blank' href='https://github.com/JuliaLang/julia/tree/82e96382251a1e163860df03c846acec86d07c36/base/docs/Docs.jl#L245-L252' class='documenter-source'>source</a><br></p>
<p><a id='LightGraphs.augment_path!-Tuple{Array{Int64,1},AbstractArray{T,2} where T,AbstractArray{T,2} where T}' href='#LightGraphs.augment_path!-Tuple{Array{Int64,1},AbstractArray{T,2} where T,AbstractArray{T,2} where T}'>#</a>
<strong><code>LightGraphs.augment_path!</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>augment_path!(path, flow_matrix, capacity_matrix)
</code></pre>

<p>Calculate the amount by which flow can be augmented in the given path. Augment the flow and returns the augment value.</p>
<p><a target='_blank' href='https://github.com/JuliaLang/julia/tree/82e96382251a1e163860df03c846acec86d07c36/base/docs/Docs.jl#L53-L58' class='documenter-source'>source</a><br></p>
<p><a id='LightGraphs.auxiliaryPoints' href='#LightGraphs.auxiliaryPoints'>#</a>
<strong><code>LightGraphs.auxiliaryPoints</code></strong> &mdash; <em>Function</em>.</p>
<pre><code>auxiliaryPoints(flow_graph, source, target, capacity_matrix)
</code></pre>

<p>Output a set of (point, slope) that compose the restricted max-flow function of <code>flow_graph</code> from <code>source to</code>target<code>using capacities in</code>capacity_matrix`.</p>
<p><strong>Performance</strong></p>
<p>One point by possible slope is enough (hence mathcal{O}(λ×max_flow) complexity).</p>
<p><a target='_blank' href='https://github.com/JuliaLang/julia/tree/82e96382251a1e163860df03c846acec86d07c36/base/docs/Docs.jl#L34' class='documenter-source'>source</a><br></p>
<p><a id='LightGraphs.bfs_tree!-Union{Tuple{LightGraphs.LevelSynchronousBFS,LightGraphs.ThreadQueue,LightGraphs.AbstractGraph,T,Array{Base.Threads.Atomic{T},N} where N}, Tuple{T}} where T<:Integer' href='#LightGraphs.bfs_tree!-Union{Tuple{LightGraphs.LevelSynchronousBFS,LightGraphs.ThreadQueue,LightGraphs.AbstractGraph,T,Array{Base.Threads.Atomic{T},N} where N}, Tuple{T}} where T<:Integer'>#</a>
<strong><code>LightGraphs.bfs_tree!</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>bfs_tree!(LevelSynchronousBFS(), g, src, parents)
</code></pre>

<p>Provide a parallel breadth-first traversal of the graph <code>g</code> starting with source vertex <code>s</code>, and return a parents array. The returned array is an Array of <code>Atomic</code> integers.</p>
<p><strong>Implementation Notes</strong></p>
<p>This function uses <code>@threads</code> for parallelism which depends on the <code>JULIA_NUM_THREADS</code> environment variable to decide the number of threads to use. Refer <code>@threads</code> documentation for more details.</p>
<p><a target='_blank' href='https://github.com/JuliaLang/julia/tree/82e96382251a1e163860df03c846acec86d07c36/base/docs/Docs.jl#L78-L88' class='documenter-source'>source</a><br></p>
<p><a id='LightGraphs.blocking_flow!' href='#LightGraphs.blocking_flow!'>#</a>
<strong><code>LightGraphs.blocking_flow!</code></strong> &mdash; <em>Function</em>.</p>
<pre><code>blocking_flow!(residual_graph, source, target, capacity_matrix, flow-matrix, P)
</code></pre>

<p>Like <code>blocking_flow</code>, but requires a preallocated parent vector <code>P</code>.</p>
<p><a target='_blank' href='https://github.com/JuliaLang/julia/tree/82e96382251a1e163860df03c846acec86d07c36/base/docs/Docs.jl#L34-L38' class='documenter-source'>source</a><br></p>
<p><a id='LightGraphs.blocking_flow-Tuple{LightGraphs.AbstractGraph,Integer,Integer,AbstractArray{T,2} where T,AbstractArray{T,2} where T}' href='#LightGraphs.blocking_flow-Tuple{LightGraphs.AbstractGraph,Integer,Integer,AbstractArray{T,2} where T,AbstractArray{T,2} where T}'>#</a>
<strong><code>LightGraphs.blocking_flow</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>blocking_flow(residual_graph, source, target, capacity_matrix, flow-matrix)
</code></pre>

<p>Use BFS to identify a blocking flow in the <code>residual_graph</code> with current flow matrix <code>flow_matrix</code>and then backtrack from <code>target</code> to <code>source</code>, augmenting flow along all possible paths.</p>
<p><a target='_blank' href='https://github.com/JuliaLang/julia/tree/82e96382251a1e163860df03c846acec86d07c36/base/docs/Docs.jl#L101-L107' class='documenter-source'>source</a><br></p>
<p><a id='LightGraphs.boykov_kolmogorov_impl' href='#LightGraphs.boykov_kolmogorov_impl'>#</a>
<strong><code>LightGraphs.boykov_kolmogorov_impl</code></strong> &mdash; <em>Function</em>.</p>
<pre><code>boykov_kolmogorov_impl(residual_graph, source, target, capacity_matrix)
</code></pre>

<p>Compute the max-flow/min-cut between <code>source</code> and <code>target</code> for <code>residual_graph</code> using the Boykov-Kolmogorov algorithm.</p>
<p>Return the maximum flow in the network, the flow matrix and the partition <code>{S,T}</code> in the form of a vector of 0's, 1's and 2's.</p>
<p><strong>References</strong></p>
<ul>
<li>BOYKOV, Y.; KOLMOGOROV, V., 2004. An Experimental Comparison of</li>
</ul>
<p>Min-Cut/Max-Flow Algorithms for Energy Minimization in Vision.</p>
<p><strong>Author</strong></p>
<ul>
<li>Júlio Hoffimann Mendes (juliohm@stanford.edu)</li>
</ul>
<p><a target='_blank' href='https://github.com/JuliaLang/julia/tree/82e96382251a1e163860df03c846acec86d07c36/base/docs/Docs.jl#L1-L16' class='documenter-source'>source</a><br></p>
<p><a id='LightGraphs.breakingPoints' href='#LightGraphs.breakingPoints'>#</a>
<strong><code>LightGraphs.breakingPoints</code></strong> &mdash; <em>Function</em>.</p>
<pre><code>breakingPoints(flow_graph::::IsDirected, source, target, capacity_matrix)
</code></pre>

<p>Calculates the breaking of the restricted max-flow from a set of auxiliary points for <code>flow_graph</code> from <code>source to</code>target<code>using capacities in</code>capacity_matrix`.</p>
<p><a target='_blank' href='https://github.com/JuliaLang/julia/tree/82e96382251a1e163860df03c846acec86d07c36/base/docs/Docs.jl#L100-L105' class='documenter-source'>source</a><br></p>
<p><a id='LightGraphs.circuit' href='#LightGraphs.circuit'>#</a>
<strong><code>LightGraphs.circuit</code></strong> &mdash; <em>Function</em>.</p>
<pre><code>circuit{T&lt;:Integer}(v::T, dg::::IsDirected, vis::JohnsonVisitor{T}, 
allcycles::Vector{Vector{T}}, vmap::Vector{T}, startnode::T = v)
</code></pre>

<p>One step of the recursive version of simple cycle detection, using a DFS algorithm.</p>
<p>The CIRCUIT function from <a href="../Johnson">Johnson, 1973</a>, recursive version. Modify the vector of cycles, when needed.</p>
<ul>
<li><code>v</code>: the vertex considered in this iteration of the DFS</li>
<li><code>dg</code>: the digraph from which cycles are computed</li>
<li>
<p><code>visitor</code>: Informations needed for the cycle computation, contains:</p>
<ul>
<li><code>stack</code>: the stack of parent vertices</li>
<li><code>blocked</code>: tells whether a vertex has already been explored or not</li>
<li><code>blockedmap</code>: mapping of the blocking / unblocking consequences</li>
<li><code>allcycles</code>: output containing the cycles already detected</li>
<li><code>vmap</code>: vector map containing the link from the old to the new nodes of the directed graph</li>
<li><code>startnode = v</code>: optional argument giving the starting node. In the first iteration,</li>
</ul>
</li>
</ul>
<p>the same as v, otherwise it should be passed.</p>
<p><strong>References</strong></p>
<ul>
<li><a href="http://epubs.siam.org/doi/abs/10.1137/0204007">Johnson</a></li>
</ul>
<p><a target='_blank' href='https://github.com/JuliaLang/julia/tree/82e96382251a1e163860df03c846acec86d07c36/base/docs/Docs.jl#L107' class='documenter-source'>source</a><br></p>
<p><a id='LightGraphs.circuit_iter' href='#LightGraphs.circuit_iter'>#</a>
<strong><code>LightGraphs.circuit_iter</code></strong> &mdash; <em>Function</em>.</p>
<pre><code>circuit_iter{T&lt;:Integer}(v::T, dg::::IsDirected, vis::JohnsonVisitor{T}, 
vmap::Vector{T}, cycle::Channel, startnode::T = v)
</code></pre>

<p>One step of the recursive version of simple cycle detection, using a DFS algorithm.</p>
<p>The CIRCUIT function from <a href="../Johnson">Johnson, 1973</a>'s algorithm,  recursive and iterative version. Produce a cycle when needed, can be used only inside a  Channel.</p>
<p><strong>Arguments</strong></p>
<ul>
<li>v: the vertex considered in this iteration of the DFS</li>
<li>dg: the digraph from which cycles are computed</li>
<li>
<p>visitor: Informations needed for the cycle computation, contains:</p>
<ul>
<li>stack: the stack of parent vertices</li>
<li>blocked: tells whether a vertex has already been explored or not</li>
<li>blockedmap: mapping of the blocking / unblocking consequences</li>
<li><code>vmap</code>: vector map containing the link from the old to the new nodes of the directed graph</li>
<li><code>cycle</code>: storage of the channel</li>
<li>startnode = v: optional argument giving the starting node. In the first iteration,</li>
</ul>
</li>
</ul>
<p>the same as v, otherwise it should be passed.</p>
<p><strong>Returns</strong></p>
<ul>
<li>done: tells whether a circuit has been found in the current exploration.</li>
</ul>
<p><strong>References</strong></p>
<ul>
<li><a href="http://epubs.siam.org/doi/abs/10.1137/0204007">Johnson</a></li>
</ul>
<p><a target='_blank' href='https://github.com/JuliaLang/julia/tree/82e96382251a1e163860df03c846acec86d07c36/base/docs/Docs.jl#L190' class='documenter-source'>source</a><br></p>
<p><a id='LightGraphs.circuit_recursive!' href='#LightGraphs.circuit_recursive!'>#</a>
<strong><code>LightGraphs.circuit_recursive!</code></strong> &mdash; <em>Function</em>.</p>
<pre><code>circuit_recursive!(g, v1, v2, blocked, B, stack, cycles)
</code></pre>

<p>Find circuits in <code>g</code> recursively starting from v1.</p>
<p><a target='_blank' href='https://github.com/JuliaLang/julia/tree/82e96382251a1e163860df03c846acec86d07c36/base/docs/Docs.jl#L43-L47' class='documenter-source'>source</a><br></p>
<p><a id='LightGraphs.components-Union{Tuple{Array{T,1}}, Tuple{T}} where T<:Integer' href='#LightGraphs.components-Union{Tuple{Array{T,1}}, Tuple{T}} where T<:Integer'>#</a>
<strong><code>LightGraphs.components</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>components(labels)
</code></pre>

<p>Given a vector of component labels, return a vector of vectors representing the vertices associated with a given component id.</p>
<p><a target='_blank' href='https://github.com/JuliaLang/julia/tree/82e96382251a1e163860df03c846acec86d07c36/base/docs/Docs.jl#L53-L58' class='documenter-source'>source</a><br></p>
<p><a id='LightGraphs.components_dict-Union{Tuple{Array{T,1}}, Tuple{T}} where T<:Integer' href='#LightGraphs.components_dict-Union{Tuple{Array{T,1}}, Tuple{T}} where T<:Integer'>#</a>
<strong><code>LightGraphs.components_dict</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>components_dict(labels)
</code></pre>

<p>Convert an array of labels to a map of component id to vertices, and return a map with each key corresponding to a given component id and each value containing the vertices associated with that component.</p>
<p><a target='_blank' href='https://github.com/JuliaLang/julia/tree/82e96382251a1e163860df03c846acec86d07c36/base/docs/Docs.jl#L36-L42' class='documenter-source'>source</a><br></p>
<p><a id='LightGraphs.connected_components!' href='#LightGraphs.connected_components!'>#</a>
<strong><code>LightGraphs.connected_components!</code></strong> &mdash; <em>Function</em>.</p>
<pre><code>connected_components!(label, g)
</code></pre>

<p>Fill <code>label</code> with the <code>id</code> of the connected component in the undirected graph <code>g</code> to which it belongs. Return a vector representing the component assigned to each vertex. The component value is the smallest vertex ID in the component.</p>
<p><a target='_blank' href='https://github.com/JuliaLang/julia/tree/82e96382251a1e163860df03c846acec86d07c36/base/docs/Docs.jl#L3-L9' class='documenter-source'>source</a><br></p>
<p><a id='LightGraphs.dinic_impl' href='#LightGraphs.dinic_impl'>#</a>
<strong><code>LightGraphs.dinic_impl</code></strong> &mdash; <em>Function</em>.</p>
<pre><code>function dinic_impl(residual_graph, source, target, capacity_matrix)
</code></pre>

<p>Compute the maximum flow between the <code>source</code> and <code>target</code> for <code>residual_graph</code> with edge flow capacities in <code>capacity_matrix</code> using <a href="https://en.wikipedia.org/wiki/Dinic%27s_algorithm">Dinic's Algorithm</a>. Return the value of the maximum flow as well as the final flow matrix.</p>
<p><a target='_blank' href='https://github.com/JuliaLang/julia/tree/82e96382251a1e163860df03c846acec86d07c36/base/docs/Docs.jl#L1-L8' class='documenter-source'>source</a><br></p>
<p><a id='LightGraphs.discharge!' href='#LightGraphs.discharge!'>#</a>
<strong><code>LightGraphs.discharge!</code></strong> &mdash; <em>Function</em>.</p>
<pre><code>discharge!(residual_graph, v, capacity_matrix, flow_matrix, excess, height, active, count, Q)
</code></pre>

<p>Drain the excess flow out of node <code>v</code>. Run the gap heuristic or relabel the vertex if the excess remains non-zero.</p>
<p><a target='_blank' href='https://github.com/JuliaLang/julia/tree/82e96382251a1e163860df03c846acec86d07c36/base/docs/Docs.jl#L175-L180' class='documenter-source'>source</a><br></p>
<p><a id='LightGraphs.edmonds_karp_impl' href='#LightGraphs.edmonds_karp_impl'>#</a>
<strong><code>LightGraphs.edmonds_karp_impl</code></strong> &mdash; <em>Function</em>.</p>
<pre><code>edmonds_karp_impl(residual_graph, source, target, capacity_matrix)
</code></pre>

<p>Compute the maximum flow in flow graph <code>residual_graph</code> between <code>source</code> and <code>target</code> and capacities defined in <code>capacity_matrix</code> using the <a href="https://en.wikipedia.org/wiki/Edmondss%E2%80%93Karp_algorithm">Edmonds-Karp algorithm</a>. Return the value of the maximum flow as well as the final flow matrix.</p>
<p><a target='_blank' href='https://github.com/JuliaLang/julia/tree/82e96382251a1e163860df03c846acec86d07c36/base/docs/Docs.jl#L1-L8' class='documenter-source'>source</a><br></p>
<p><a id='LightGraphs.emrf' href='#LightGraphs.emrf'>#</a>
<strong><code>LightGraphs.emrf</code></strong> &mdash; <em>Function</em>.</p>
<pre><code>emrf(flow_graph, source, target, capacity_matrix, flow_algorithm, routes=0)
</code></pre>

<p>Compute the maximum multiroute flow (for any number of <code>route</code>s) between <code>source</code> and <code>target</code> in <code>flow_graph</code> via flow algorithm <code>flow_algorithm</code>.</p>
<p>If a number of routes is given, return the value of the multiroute flow as well as the final flow matrix, along with a multiroute cut if the Boykov-Kolmogorov max-flow algorithm is used as a subroutine. Otherwise, return the vector of breaking points of the parametric multiroute flow function.</p>
<p><strong>References</strong></p>
<ul>
<li><a href="http://dx.doi.org/10.1016/j.disopt.2016.05.002">Extended Multiroute Flow algorithm</a></li>
</ul>
<p><a target='_blank' href='https://github.com/JuliaLang/julia/tree/82e96382251a1e163860df03c846acec86d07c36/base/docs/Docs.jl#L1-L15' class='documenter-source'>source</a><br></p>
<p><a id='LightGraphs.enqueue_vertex!-Tuple{AbstractArray{T,1} where T,Integer,AbstractArray{Bool,1},AbstractArray{T,1} where T}' href='#LightGraphs.enqueue_vertex!-Tuple{AbstractArray{T,1} where T,Integer,AbstractArray{Bool,1},AbstractArray{T,1} where T}'>#</a>
<strong><code>LightGraphs.enqueue_vertex!</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>enqueue_vertex!(Q, v, active, excess)
</code></pre>

<p>Push inactive node <code>v</code> into queue <code>Q</code> and activates it. Requires preallocated <code>active</code> and <code>excess</code> vectors.</p>
<p><a target='_blank' href='https://github.com/JuliaLang/julia/tree/82e96382251a1e163860df03c846acec86d07c36/base/docs/Docs.jl#L53-L58' class='documenter-source'>source</a><br></p>
<p><a id='LightGraphs.fetch_path' href='#LightGraphs.fetch_path'>#</a>
<strong><code>LightGraphs.fetch_path</code></strong> &mdash; <em>Function</em>.</p>
<pre><code>fetch_path(residual_graph, source, target, flow_matrix, capacity_matrix)
</code></pre>

<p>Use bidirectional BFS to look for augmentable paths from <code>source</code> to <code>target</code> in <code>residual_graph</code>. Return the vertex where the two BFS searches intersect, the parent table of the path, the successor table of the path found, and a flag indicating success (0 =&gt; success; 1 =&gt; no path to target, 2 =&gt; no path to source).</p>
<p><a target='_blank' href='https://github.com/JuliaLang/julia/tree/82e96382251a1e163860df03c846acec86d07c36/base/docs/Docs.jl#L142-L151' class='documenter-source'>source</a><br></p>
<p><a id='LightGraphs.fetch_path!' href='#LightGraphs.fetch_path!'>#</a>
<strong><code>LightGraphs.fetch_path!</code></strong> &mdash; <em>Function</em>.</p>
<pre><code>fetch_path!(residual_graph, source, target, flow_matrix, capacity_matrix, P, S)
</code></pre>

<p>Like <code>fetch_path</code>, but requires preallocated parent vector <code>P</code> and successor vector <code>S</code>.</p>
<p><a target='_blank' href='https://github.com/JuliaLang/julia/tree/82e96382251a1e163860df03c846acec86d07c36/base/docs/Docs.jl#L82-L87' class='documenter-source'>source</a><br></p>
<p><a id='LightGraphs.gap!' href='#LightGraphs.gap!'>#</a>
<strong><code>LightGraphs.gap!</code></strong> &mdash; <em>Function</em>.</p>
<pre><code>gap!(residual_graph, h, excess, height, active, count, Q)
</code></pre>

<p>Implement the push-relabel gap heuristic. Relabel all vertices above a cutoff height. Reduce the number of relabels required.</p>
<p>Requires arguments:</p>
<ul>
<li>residual_graph::DiGraph                # the input graph</li>
<li>h::Int                                 # cutoff height</li>
<li>excess::AbstractVector</li>
<li>height::AbstractVector{Int}</li>
<li>active::AbstractVector{Bool}</li>
<li>count::AbstractVector{Int}</li>
<li>Q::AbstractVector</li>
</ul>
<p><a target='_blank' href='https://github.com/JuliaLang/julia/tree/82e96382251a1e163860df03c846acec86d07c36/base/docs/Docs.jl#L107-L122' class='documenter-source'>source</a><br></p>
<p><a id='LightGraphs.intersection-Union{Tuple{Array{Tuple{T,T,I},1},R}, Tuple{I}, Tuple{R}, Tuple{T}} where T<:AbstractFloat where I<:Integer where R<:Real' href='#LightGraphs.intersection-Union{Tuple{Array{Tuple{T,T,I},1},R}, Tuple{I}, Tuple{R}, Tuple{T}} where T<:AbstractFloat where I<:Integer where R<:Real'>#</a>
<strong><code>LightGraphs.intersection</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>intersection(points, k)
</code></pre>

<p>Return the intersection of a set of line segments and a line of slope <code>k</code> passing by the origin. Segments are defined as a triple (x, y, slope).</p>
<p><a target='_blank' href='https://github.com/JuliaLang/julia/tree/82e96382251a1e163860df03c846acec86d07c36/base/docs/Docs.jl#L220-L225' class='documenter-source'>source</a><br></p>
<p><a id='LightGraphs.intersection-Union{Tuple{R}, Tuple{T,T,Integer,T,T,R}, Tuple{T}} where T<:AbstractFloat where R<:Real' href='#LightGraphs.intersection-Union{Tuple{R}, Tuple{T,T,Integer,T,T,R}, Tuple{T}} where T<:AbstractFloat where R<:Real'>#</a>
<strong><code>LightGraphs.intersection</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>    intersection(x1, y1, a1, x2, y2, a2)
</code></pre>

<p>Return the intersection of two lines defined by <code>x</code> and <code>y</code> with slopes <code>a</code>.</p>
<ol>
<li>A set of segments and a linear function of slope k passing by the origin.</li>
</ol>
<p>Requires argument:</p>
<ol>
<li>
<ul>
<li>x1, y1, a1, x2, y2, a2::T&lt;:AbstractFloat # Coordinates/slopes</li>
</ul>
</li>
<li>
<ul>
<li>points::Vector{Tuple{T, T, Int}}         # vector of points with T&lt;:AbstractFloat</li>
</ul>
</li>
<li>
<p>k::R&lt;:Real                             # number of routes (slope of the line)</p>
</li>
</ol>
<p><a target='_blank' href='https://github.com/JuliaLang/julia/tree/82e96382251a1e163860df03c846acec86d07c36/base/docs/Docs.jl#L192-L201' class='documenter-source'>source</a><br></p>
<p><a id='LightGraphs.itercycles' href='#LightGraphs.itercycles'>#</a>
<strong><code>LightGraphs.itercycles</code></strong> &mdash; <em>Function</em>.</p>
<pre><code>itercycles(dg::::IsDirected, cycle::Channel)
</code></pre>

<p>Compute all cycles of the given directed graph, using <a href="../Johnson">Johnson, 1973</a>'s algorithm.</p>
<p>Iterative version of the algorithm, using Channels to stop the exploration after a given number of cycles.</p>
<p><strong>References</strong></p>
<ul>
<li><a href="http://epubs.siam.org/doi/abs/10.1137/0204007">Johnson</a></li>
</ul>
<p><a target='_blank' href='https://github.com/JuliaLang/julia/tree/82e96382251a1e163860df03c846acec86d07c36/base/docs/Docs.jl#L246-L257' class='documenter-source'>source</a><br></p>
<p><a id='LightGraphs.kishimoto' href='#LightGraphs.kishimoto'>#</a>
<strong><code>LightGraphs.kishimoto</code></strong> &mdash; <em>Function</em>.</p>
<pre><code>kishimoto(flow_graph, source, target, capacity_matrix, flow_algorithm, routes)
</code></pre>

<p>Compute the maximum multiroute flow (for an integer number of <code>route</code>s) between <code>source</code> and <code>target</code> in <code>flow_graph</code> with capacities in <code>capacity_matrix</code> using the <a href="http://dx.doi.org/10.1109/ICCS.1992.255031">Kishimoto algorithm</a>. Return the value of the multiroute flow as well as the final flow matrix, along with a multiroute cut if Boykov-Kolmogorov is used as a subroutine.</p>
<p><a target='_blank' href='https://github.com/JuliaLang/julia/tree/82e96382251a1e163860df03c846acec86d07c36/base/docs/Docs.jl#L33-L41' class='documenter-source'>source</a><br></p>
<p><a id='LightGraphs.loadlg_mult-Tuple{IO}' href='#LightGraphs.loadlg_mult-Tuple{IO}'>#</a>
<strong><code>LightGraphs.loadlg_mult</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>loadlg_mult(io)
</code></pre>

<p>Return a dictionary of (name=&gt;graph) loaded from IO stream <code>io</code>.</p>
<p><a target='_blank' href='https://github.com/JuliaLang/julia/tree/82e96382251a1e163860df03c846acec86d07c36/base/docs/Docs.jl#L40-L44' class='documenter-source'>source</a><br></p>
<p><a id='LightGraphs.minmaxCapacity-Tuple{AbstractArray{T,2} where T}' href='#LightGraphs.minmaxCapacity-Tuple{AbstractArray{T,2} where T}'>#</a>
<strong><code>LightGraphs.minmaxCapacity</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>minmaxCapacity(capacity_matrix)
</code></pre>

<p>Return the nonzero min and max function of <code>capacity_matrix</code>.</p>
<p>Note: this is more efficient than maximum() / minimum() / extrema() since we have to ignore zero values.</p>
<p><a target='_blank' href='https://github.com/JuliaLang/julia/tree/82e96382251a1e163860df03c846acec86d07c36/base/docs/Docs.jl#L135-L142' class='documenter-source'>source</a><br></p>
<p><a id='LightGraphs.ncycles_n_i-Tuple{Integer,Integer}' href='#LightGraphs.ncycles_n_i-Tuple{Integer,Integer}'>#</a>
<strong><code>LightGraphs.ncycles_n_i</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>ncycles_n_i(n::Integer, i::Integer)
</code></pre>

<p>Compute the theoretical maximum number of cycles of size <code>i</code> in a directed graph of <code>n</code>  vertices.</p>
<p><a target='_blank' href='https://github.com/JuliaLang/julia/tree/82e96382251a1e163860df03c846acec86d07c36/base/docs/Docs.jl#L3-L8' class='documenter-source'>source</a><br></p>
<p><a id='LightGraphs.nearbipartiteaffinity-Union{Tuple{Array{T,1},Real,Real}, Tuple{T}} where T<:Integer' href='#LightGraphs.nearbipartiteaffinity-Union{Tuple{Array{T,1},Real,Real}, Tuple{T}} where T<:Integer'>#</a>
<strong><code>LightGraphs.nearbipartiteaffinity</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>nearbipartiteaffinity(sizes, between, intra)
</code></pre>

<p>Construct the affinity matrix for a near bipartite SBM. <code>between</code> is the affinity between the two parts of each bipartite community. <code>intra</code> is the probability of an edge within the parts of the partitions.</p>
<p>This is a specific type of SBM with <code>`\frac{k}{2} blocks each with two halves. Each half is connected as a random bipartite graph with probability</code>intra<code>The blocks are connected with probability</code>between`.</p>
<p><a target='_blank' href='https://github.com/JuliaLang/julia/tree/82e96382251a1e163860df03c846acec86d07c36/base/docs/Docs.jl#L738' class='documenter-source'>source</a><br></p>
<p><a id='LightGraphs.noallocextreme-NTuple{4,Any}' href='#LightGraphs.noallocextreme-NTuple{4,Any}'>#</a>
<strong><code>LightGraphs.noallocextreme</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>noallocextreme(f, comparison, initial, g)
</code></pre>

<p>Compute the extreme value of <code>[f(g,i) for i=i:nv(g)]</code> without gathering them all</p>
<p><a target='_blank' href='https://github.com/JuliaLang/julia/tree/82e96382251a1e163860df03c846acec86d07c36/base/docs/Docs.jl#L92-L95' class='documenter-source'>source</a><br></p>
<p><a id='LightGraphs.push_flow!' href='#LightGraphs.push_flow!'>#</a>
<strong><code>LightGraphs.push_flow!</code></strong> &mdash; <em>Function</em>.</p>
<pre><code>push_flow!(residual_graph, u, v, capacity_matrix, flow_matrix, excess, height, active, Q)
</code></pre>

<p>Using <code>residual_graph</code> with capacities in <code>capacity_matrix</code>, push as much flow as possible through the given edge(<code>u</code>, <code>v</code>). Requires preallocated <code>flow_matrix</code> matrix, and <code>excess</code>, <code>height,</code>active<code>, and</code>Q` vectors.</p>
<p><a target='_blank' href='https://github.com/JuliaLang/julia/tree/82e96382251a1e163860df03c846acec86d07c36/base/docs/Docs.jl#L73-L79' class='documenter-source'>source</a><br></p>
<p><a id='LightGraphs.push_relabel' href='#LightGraphs.push_relabel'>#</a>
<strong><code>LightGraphs.push_relabel</code></strong> &mdash; <em>Function</em>.</p>
<pre><code>push_relabel(residual_graph, source, target, capacity_matrix)
</code></pre>

<p>Return the maximum flow of <code>residual_graph</code> from <code>source</code> to <code>target</code> using the FIFO push relabel algorithm with gap heuristic.</p>
<p><strong>Performance</strong></p>
<p>Takes approximately $\mathcal{O}(|V|^{3})$ time.</p>
<p><a target='_blank' href='https://github.com/JuliaLang/julia/tree/82e96382251a1e163860df03c846acec86d07c36/base/docs/Docs.jl#L1' class='documenter-source'>source</a><br></p>
<p><a id='LightGraphs.quick_find!-Tuple{Any,Any,Any}' href='#LightGraphs.quick_find!-Tuple{Any,Any,Any}'>#</a>
<strong><code>LightGraphs.quick_find!</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>quick_find!(vs, p, q)
</code></pre>

<p>Perform <a href="https://en.wikipedia.org/wiki/Disjoint-set_data_structure">Quick-Find algorithm</a> on a given pair of vertices <code>p</code>and <code>q</code>, and make a connection between them in the vector <code>vs</code>.</p>
<p><a target='_blank' href='https://github.com/JuliaLang/julia/tree/82e96382251a1e163860df03c846acec86d07c36/base/docs/Docs.jl#L8-L13' class='documenter-source'>source</a><br></p>
<p><a id='LightGraphs.randbn' href='#LightGraphs.randbn'>#</a>
<strong><code>LightGraphs.randbn</code></strong> &mdash; <em>Function</em>.</p>
<pre><code>randbn(n, p, seed=-1)
</code></pre>

<p>Return a binomally-distribted random number with parameters <code>n</code> and <code>p</code> and optional <code>seed</code>.</p>
<p><strong>References</strong></p>
<ul>
<li>"Non-Uniform Random Variate Generation," Luc Devroye, p. 522. Retrieved via http://www.eirene.de/Devroye.pdf.</li>
<li>http://stackoverflow.com/questions/23561551/a-efficient-binomial-random-number-generator-code-in-java</li>
</ul>
<p><a target='_blank' href='https://github.com/JuliaLang/julia/tree/82e96382251a1e163860df03c846acec86d07c36/base/docs/Docs.jl#L34-L42' class='documenter-source'>source</a><br></p>
<p><a id='LightGraphs.random_pair-Tuple{AbstractRNG,Integer}' href='#LightGraphs.random_pair-Tuple{AbstractRNG,Integer}'>#</a>
<strong><code>LightGraphs.random_pair</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>random_pair(rng, n)
</code></pre>

<p>Generate a stream of random pairs in <code>1:n</code> using random number generator <code>RNG</code>.</p>
<p><a target='_blank' href='https://github.com/JuliaLang/julia/tree/82e96382251a1e163860df03c846acec86d07c36/base/docs/Docs.jl#L766-L770' class='documenter-source'>source</a><br></p>
<p><a id='LightGraphs.range_shuffle!-Tuple{UnitRange,AbstractArray{T,1} where T}' href='#LightGraphs.range_shuffle!-Tuple{UnitRange,AbstractArray{T,1} where T}'>#</a>
<strong><code>LightGraphs.range_shuffle!</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>range_shuffle!(r, a)
</code></pre>

<p>Fast shuffle Array <code>a</code> in UnitRange <code>r</code>.</p>
<p><a target='_blank' href='https://github.com/JuliaLang/julia/tree/82e96382251a1e163860df03c846acec86d07c36/base/docs/Docs.jl#L60-L64' class='documenter-source'>source</a><br></p>
<p><a id='LightGraphs.relabel!' href='#LightGraphs.relabel!'>#</a>
<strong><code>LightGraphs.relabel!</code></strong> &mdash; <em>Function</em>.</p>
<pre><code>relabel!(residual_graph, v, capacity_matrix, flow_matrix, excess, height, active, count, Q)
</code></pre>

<p>Relabel a node <code>v</code> with respect to its neighbors to produce an admissable edge.</p>
<p><a target='_blank' href='https://github.com/JuliaLang/julia/tree/82e96382251a1e163860df03c846acec86d07c36/base/docs/Docs.jl#L144-L148' class='documenter-source'>source</a><br></p>
<p><a id='LightGraphs.resetB!-Tuple{Any}' href='#LightGraphs.resetB!-Tuple{Any}'>#</a>
<strong><code>LightGraphs.resetB!</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>resetB!(B)
</code></pre>

<p>Reset B work structure.</p>
<p><a target='_blank' href='https://github.com/JuliaLang/julia/tree/82e96382251a1e163860df03c846acec86d07c36/base/docs/Docs.jl#L29-L33' class='documenter-source'>source</a><br></p>
<p><a id='LightGraphs.resetblocked!-Tuple{Any}' href='#LightGraphs.resetblocked!-Tuple{Any}'>#</a>
<strong><code>LightGraphs.resetblocked!</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>resetblocked!(blocked)
</code></pre>

<p>Reset vector of <code>blocked</code> vertices.</p>
<p><a target='_blank' href='https://github.com/JuliaLang/julia/tree/82e96382251a1e163860df03c846acec86d07c36/base/docs/Docs.jl#L36-L40' class='documenter-source'>source</a><br></p>
<p><a id='LightGraphs.residual' href='#LightGraphs.residual'>#</a>
<strong><code>LightGraphs.residual</code></strong> &mdash; <em>Function</em>.</p>
<pre><code>residual(flow_graph)
</code></pre>

<p>Return a directed residual graph for a directed <code>flow_graph</code>.</p>
<p>The residual graph comprises the same node list as the orginal flow graph, but ensures that for each edge (u,v), (v,u) also exists in the graph. This allows flow in the reverse direction.</p>
<p>If only the forward edge exists, a reverse edge is created with capacity 0. If both forward and reverse edges exist, their capacities are left unchanged. Since the capacities in <a href="../@ref"><code>DefaultDistance</code></a> cannot be changed, an array of ones is created.</p>
<p><a target='_blank' href='https://github.com/JuliaLang/julia/tree/82e96382251a1e163860df03c846acec86d07c36/base/docs/Docs.jl#L53-L66' class='documenter-source'>source</a><br></p>
<p><a id='LightGraphs.sample!-Tuple{AbstractRNG,AbstractArray,Integer}' href='#LightGraphs.sample!-Tuple{AbstractRNG,AbstractArray,Integer}'>#</a>
<strong><code>LightGraphs.sample!</code></strong> &mdash; <em>Method</em>.</p>
<p>sample!([rng, ]a, k)</p>
<p>Sample <code>k</code> element from array <code>a</code> without repetition and eventually excluding elements in <code>exclude</code>.</p>
<p><strong>Optional Arguments</strong></p>
<ul>
<li><code>exclude=()</code>: elements in <code>a</code> to exclude from sampling.</li>
</ul>
<p><strong>Implementation Notes</strong></p>
<p>Changes the order of the elements in <code>a</code>. For a non-mutating version, see <a href="./#LightGraphs.sample-Tuple{UnitRange,Integer}"><code>sample</code></a>.</p>
<p><a target='_blank' href='https://github.com/JuliaLang/julia/tree/82e96382251a1e163860df03c846acec86d07c36/base/docs/Docs.jl#L1-L11' class='documenter-source'>source</a><br></p>
<p><a id='LightGraphs.sample-Tuple{UnitRange,Integer}' href='#LightGraphs.sample-Tuple{UnitRange,Integer}'>#</a>
<strong><code>LightGraphs.sample</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>sample([rng,] r, k)
</code></pre>

<p>Sample <code>k</code> element from unit range <code>r</code> without repetition and eventually excluding elements in <code>exclude</code>.</p>
<p><strong>Optional Arguments</strong></p>
<ul>
<li><code>exclude=()</code>: elements in <code>a</code> to exclude from sampling.</li>
</ul>
<p><strong>Implementation Notes</strong></p>
<p>Unlike <a href="./#LightGraphs.sample!-Tuple{AbstractRNG,AbstractArray,Integer}"><code>sample!</code></a>, does not produce side effects.</p>
<p><a target='_blank' href='https://github.com/JuliaLang/julia/tree/82e96382251a1e163860df03c846acec86d07c36/base/docs/Docs.jl#L31-L41' class='documenter-source'>source</a><br></p>
<p><a id='LightGraphs.savelg-Tuple{IO,LightGraphs.AbstractGraph,String}' href='#LightGraphs.savelg-Tuple{IO,LightGraphs.AbstractGraph,String}'>#</a>
<strong><code>LightGraphs.savelg</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>savelg(io, g, gname)
</code></pre>

<p>Write a graph <code>g</code> with name <code>gname</code> in a proprietary format to the IO stream designated by <code>io</code>. Return 1 (number of graphs written).</p>
<p><a target='_blank' href='https://github.com/JuliaLang/julia/tree/82e96382251a1e163860df03c846acec86d07c36/base/docs/Docs.jl#L85-L90' class='documenter-source'>source</a><br></p>
<p><a id='LightGraphs.savelg_mult-Tuple{IO,Dict}' href='#LightGraphs.savelg_mult-Tuple{IO,Dict}'>#</a>
<strong><code>LightGraphs.savelg_mult</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>savelg_mult(io, graphs)
</code></pre>

<p>Write a dictionary of (name=&gt;graph) to an IO stream <code>io</code>, with default <code>GZip</code> compression. Return number of graphs written.</p>
<p><a target='_blank' href='https://github.com/JuliaLang/julia/tree/82e96382251a1e163860df03c846acec86d07c36/base/docs/Docs.jl#L103-L108' class='documenter-source'>source</a><br></p>
<p><a id='LightGraphs.sbmaffinity-Union{Tuple{Array{T,1},Real,Array{U,1}}, Tuple{T}, Tuple{U}} where T<:Real where U<:Integer' href='#LightGraphs.sbmaffinity-Union{Tuple{Array{T,1},Real,Array{U,1}}, Tuple{T}, Tuple{U}} where T<:Real where U<:Integer'>#</a>
<strong><code>LightGraphs.sbmaffinity</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>sbmaffinity(internalp, externalp, sizes)
</code></pre>

<p>Produce the sbm affinity matrix with internal probabilities <code>internalp</code> and external probabilities <code>externalp</code>.</p>
<p><a target='_blank' href='https://github.com/JuliaLang/julia/tree/82e96382251a1e163860df03c846acec86d07c36/base/docs/Docs.jl#L705-L710' class='documenter-source'>source</a><br></p>
<p><a id='LightGraphs.slope' href='#LightGraphs.slope'>#</a>
<strong><code>LightGraphs.slope</code></strong> &mdash; <em>Function</em>.</p>
<pre><code>slope(flow_graph, capacity_matrix, cut, restriction)
</code></pre>

<p>Return the slope of <code>flow_graph</code> using capacities in <code>capacity_matrix</code> and a cut vector <code>cut</code>. The slope is initialized at 0 and is incremented for each edge whose capacity does not exceed <code>restriction</code>.</p>
<p><a target='_blank' href='https://github.com/JuliaLang/julia/tree/82e96382251a1e163860df03c846acec86d07c36/base/docs/Docs.jl#L161-L167' class='documenter-source'>source</a><br></p>
<p><a id='LightGraphs.tree-Union{Tuple{AbstractArray{T,1}}, Tuple{T}} where T<:Integer' href='#LightGraphs.tree-Union{Tuple{AbstractArray{T,1}}, Tuple{T}} where T<:Integer'>#</a>
<strong><code>LightGraphs.tree</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>tree(parents)
</code></pre>

<p>Convert a parents array into a directed graph.</p>
<p><a target='_blank' href='https://github.com/JuliaLang/julia/tree/82e96382251a1e163860df03c846acec86d07c36/base/docs/Docs.jl#L103-L107' class='documenter-source'>source</a><br></p>
<p><a id='LightGraphs.unblock!-Union{Tuple{T,BitArray,Array{Array{T,1},1}}, Tuple{T}} where T' href='#LightGraphs.unblock!-Union{Tuple{T,BitArray,Array{Array{T,1},1}}, Tuple{T}} where T'>#</a>
<strong><code>LightGraphs.unblock!</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>unblock!(v, blocked, B)
</code></pre>

<p>Unblock the value <code>v</code> from the <code>blocked</code> list and remove from <code>B</code>.</p>
<p><a target='_blank' href='https://github.com/JuliaLang/julia/tree/82e96382251a1e163860df03c846acec86d07c36/base/docs/Docs.jl#L78-L82' class='documenter-source'>source</a><br></p>
<p><a id='LightGraphs.unblock!-Union{Tuple{T,BitArray,Array{Set{T},1}}, Tuple{T}} where T<:Integer' href='#LightGraphs.unblock!-Union{Tuple{T,BitArray,Array{Set{T},1}}, Tuple{T}} where T<:Integer'>#</a>
<strong><code>LightGraphs.unblock!</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>unblock!{T&lt;:Integer}(v::T, blocked::BitArray, B::Vector{Set{T}})
</code></pre>

<p>Unblock the vertices recursively. </p>
<p><code>v</code> is the vertex to unblock, <code>blocked</code> tells whether a vertex is blocked or  not and <code>B</code> is the map that tells if the unblocking of one vertex should  unblock other vertices.</p>
<p><a target='_blank' href='https://github.com/JuliaLang/julia/tree/82e96382251a1e163860df03c846acec86d07c36/base/docs/Docs.jl#L88-L96' class='documenter-source'>source</a><br></p>
<p><a id='LightGraphs.visit!-Tuple{LightGraphs.AbstractGraph,Integer,AbstractArray{Bool,1},AbstractArray{T,1} where T,AbstractArray{T,2} where T}' href='#LightGraphs.visit!-Tuple{LightGraphs.AbstractGraph,Integer,AbstractArray{Bool,1},AbstractArray{T,1} where T,AbstractArray{T,2} where T}'>#</a>
<strong><code>LightGraphs.visit!</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>visit!(g, v, marked, pq, distmx)
</code></pre>

<p>Mark the vertex <code>v</code> of graph <code>g</code> true in the array <code>marked</code> and enter all its edges into priority queue <code>pq</code> with its <code>distmx</code> values as a PrimHeapEntry.</p>
<p><a target='_blank' href='https://github.com/JuliaLang/julia/tree/82e96382251a1e163860df03c846acec86d07c36/base/docs/Docs.jl#L43-L48' class='documenter-source'>source</a><br></p>
<p><a id='LightGraphs.visit!-Tuple{LightGraphs.AbstractGraph,LightGraphs.Biconnections,Integer,Integer}' href='#LightGraphs.visit!-Tuple{LightGraphs.AbstractGraph,LightGraphs.Biconnections,Integer,Integer}'>#</a>
<strong><code>LightGraphs.visit!</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>visit!(g, state, u, v)
</code></pre>

<p>Perform a DFS visit storing the depth and low-points of each vertex.</p>
<p><a target='_blank' href='https://github.com/JuliaLang/julia/tree/82e96382251a1e163860df03c846acec86d07c36/base/docs/Docs.jl#L20-L24' class='documenter-source'>source</a><br></p>
<p><a id='LightGraphs.visit!-Tuple{LightGraphs.Articulations,LightGraphs.AbstractGraph,Integer,Integer}' href='#LightGraphs.visit!-Tuple{LightGraphs.Articulations,LightGraphs.AbstractGraph,Integer,Integer}'>#</a>
<strong><code>LightGraphs.visit!</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>visit!(state, g, u, v)
</code></pre>

<p>Perform a depth first search storing the depth (in <code>depth</code>) and low-points (in <code>low</code>) of each vertex. Call this function repeatedly to complete the DFS (see <a href="./#LightGraphs.articulation-Tuple{LightGraphs.AbstractGraph}"><code>articulation</code></a> for usage).</p>
<p><a target='_blank' href='https://github.com/JuliaLang/julia/tree/82e96382251a1e163860df03c846acec86d07c36/base/docs/Docs.jl#L19-L25' class='documenter-source'>source</a><br></p>
<p><a id='LightGraphs.vote!-Tuple{LightGraphs.AbstractGraph,Array{T,1} where T,LightGraphs.NeighComm,Integer}' href='#LightGraphs.vote!-Tuple{LightGraphs.AbstractGraph,Array{T,1} where T,LightGraphs.NeighComm,Integer}'>#</a>
<strong><code>LightGraphs.vote!</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>vote!(g, m, c, u)
</code></pre>

<p>Return the label with greatest frequency.</p>
<p><a target='_blank' href='https://github.com/JuliaLang/julia/tree/82e96382251a1e163860df03c846acec86d07c36/base/docs/Docs.jl#L75-L79' class='documenter-source'>source</a><br></p>
                
                  
                
              
              
                
              
            </article>
          </div>
        </div>
      </main>
      
        
<footer class="md-footer">
  
    <div class="md-footer-nav">
      <nav class="md-footer-nav__inner md-grid">
        
          <a href="../community/" title="Community Structures" class="md-flex md-footer-nav__link md-footer-nav__link--prev" rel="prev">
            <div class="md-flex__cell md-flex__cell--shrink">
              <i class="md-icon md-icon--arrow-back md-footer-nav__button"></i>
            </div>
            <div class="md-flex__cell md-flex__cell--stretch md-footer-nav__title">
              <span class="md-flex__ellipsis">
                <span class="md-footer-nav__direction">
                  Previous
                </span>
                Community Structures
              </span>
            </div>
          </a>
        
        
          <a href="../generators/" title="Graph Generators" class="md-flex md-footer-nav__link md-footer-nav__link--next" rel="next">
            <div class="md-flex__cell md-flex__cell--stretch md-footer-nav__title">
              <span class="md-flex__ellipsis">
                <span class="md-footer-nav__direction">
                  Next
                </span>
                Graph Generators
              </span>
            </div>
            <div class="md-flex__cell md-flex__cell--shrink">
              <i class="md-icon md-icon--arrow-forward md-footer-nav__button"></i>
            </div>
          </a>
        
      </nav>
    </div>
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-footer-copyright">
        
        powered by
        <a href="http://www.mkdocs.org" title="MkDocs">MkDocs</a>
        and
        <a href="http://squidfunk.github.io/mkdocs-material/" title="Material for MkDocs">
          Material for MkDocs</a>
      </div>
      
        
      
    </div>
  </div>
</footer>
      
    </div>
    
      <script src="../assets/javascripts/application-06a3e72efd.js"></script>
      <script>app.initialize({url:{base:".."}})</script>
      
        <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML"></script>
      
        <script src="../assets/mathjaxhelper.js"></script>
      
    
    
      
    
  </body>
</html>